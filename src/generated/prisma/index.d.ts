
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyInvoice
 * 
 */
export type CompanyInvoice = $Result.DefaultSelection<Prisma.$CompanyInvoicePayload>
/**
 * Model CompanyInvoiceItem
 * 
 */
export type CompanyInvoiceItem = $Result.DefaultSelection<Prisma.$CompanyInvoiceItemPayload>
/**
 * Model CompanyEmployee
 * 
 */
export type CompanyEmployee = $Result.DefaultSelection<Prisma.$CompanyEmployeePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model UserLocation
 * 
 */
export type UserLocation = $Result.DefaultSelection<Prisma.$UserLocationPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model PromotionBanner
 * 
 */
export type PromotionBanner = $Result.DefaultSelection<Prisma.$PromotionBannerPayload>
/**
 * Model MenuPromotionBanner
 * 
 */
export type MenuPromotionBanner = $Result.DefaultSelection<Prisma.$MenuPromotionBannerPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model Dish
 * 
 */
export type Dish = $Result.DefaultSelection<Prisma.$DishPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model CouponRedemption
 * 
 */
export type CouponRedemption = $Result.DefaultSelection<Prisma.$CouponRedemptionPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Metadata
 * 
 */
export type Metadata = $Result.DefaultSelection<Prisma.$MetadataPayload>
/**
 * Model CustomerSegment
 * 
 */
export type CustomerSegment = $Result.DefaultSelection<Prisma.$CustomerSegmentPayload>
/**
 * Model InAppMessage
 * 
 */
export type InAppMessage = $Result.DefaultSelection<Prisma.$InAppMessagePayload>
/**
 * Model InAppMessageRead
 * 
 */
export type InAppMessageRead = $Result.DefaultSelection<Prisma.$InAppMessageReadPayload>
/**
 * Model MarketingWorkflow
 * 
 */
export type MarketingWorkflow = $Result.DefaultSelection<Prisma.$MarketingWorkflowPayload>
/**
 * Model WorkflowExecutionLog
 * 
 */
export type WorkflowExecutionLog = $Result.DefaultSelection<Prisma.$WorkflowExecutionLogPayload>
/**
 * Model SegmentIncentive
 * 
 */
export type SegmentIncentive = $Result.DefaultSelection<Prisma.$SegmentIncentivePayload>
/**
 * Model MarketingTemplate
 * 
 */
export type MarketingTemplate = $Result.DefaultSelection<Prisma.$MarketingTemplatePayload>
/**
 * Model PushNotification
 * 
 */
export type PushNotification = $Result.DefaultSelection<Prisma.$PushNotificationPayload>
/**
 * Model PushNotificationLog
 * 
 */
export type PushNotificationLog = $Result.DefaultSelection<Prisma.$PushNotificationLogPayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model PaymentProviderConfig
 * 
 */
export type PaymentProviderConfig = $Result.DefaultSelection<Prisma.$PaymentProviderConfigPayload>
/**
 * Model IncentiveGrant
 * 
 */
export type IncentiveGrant = $Result.DefaultSelection<Prisma.$IncentiveGrantPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubsidyType: {
  NONE: 'NONE',
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED'
};

export type SubsidyType = (typeof SubsidyType)[keyof typeof SubsidyType]


export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  KITCHEN_STAFF: 'KITCHEN_STAFF',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const WalletTransactionType: {
  TOP_UP: 'TOP_UP',
  ORDER_PAYMENT: 'ORDER_PAYMENT',
  REFUND: 'REFUND',
  ADJUSTMENT: 'ADJUSTMENT',
  INCENTIVE: 'INCENTIVE'
};

export type WalletTransactionType = (typeof WalletTransactionType)[keyof typeof WalletTransactionType]


export const OrderStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  PREPARING: 'PREPARING',
  READY: 'READY',
  PICKED_UP: 'PICKED_UP',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const CouponType: {
  DISCOUNT_PERCENTAGE: 'DISCOUNT_PERCENTAGE',
  DISCOUNT_FIXED: 'DISCOUNT_FIXED',
  FREE_ITEM: 'FREE_ITEM'
};

export type CouponType = (typeof CouponType)[keyof typeof CouponType]


export const MetadataType: {
  DIET_CATEGORY: 'DIET_CATEGORY',
  ALLERGEN: 'ALLERGEN',
  DISH_CATEGORY: 'DISH_CATEGORY'
};

export type MetadataType = (typeof MetadataType)[keyof typeof MetadataType]


export const MarketingTemplateType: {
  EMAIL: 'EMAIL',
  IN_APP_BANNER: 'IN_APP_BANNER',
  PROMOTION_BANNER: 'PROMOTION_BANNER',
  PUSH: 'PUSH'
};

export type MarketingTemplateType = (typeof MarketingTemplateType)[keyof typeof MarketingTemplateType]


export const MarketingTemplateStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type MarketingTemplateStatus = (typeof MarketingTemplateStatus)[keyof typeof MarketingTemplateStatus]


export const PushNotificationStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type PushNotificationStatus = (typeof PushNotificationStatus)[keyof typeof PushNotificationStatus]


export const PushDeliveryStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED'
};

export type PushDeliveryStatus = (typeof PushDeliveryStatus)[keyof typeof PushDeliveryStatus]

}

export type SubsidyType = $Enums.SubsidyType

export const SubsidyType: typeof $Enums.SubsidyType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type WalletTransactionType = $Enums.WalletTransactionType

export const WalletTransactionType: typeof $Enums.WalletTransactionType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type CouponType = $Enums.CouponType

export const CouponType: typeof $Enums.CouponType

export type MetadataType = $Enums.MetadataType

export const MetadataType: typeof $Enums.MetadataType

export type MarketingTemplateType = $Enums.MarketingTemplateType

export const MarketingTemplateType: typeof $Enums.MarketingTemplateType

export type MarketingTemplateStatus = $Enums.MarketingTemplateStatus

export const MarketingTemplateStatus: typeof $Enums.MarketingTemplateStatus

export type PushNotificationStatus = $Enums.PushNotificationStatus

export const PushNotificationStatus: typeof $Enums.PushNotificationStatus

export type PushDeliveryStatus = $Enums.PushDeliveryStatus

export const PushDeliveryStatus: typeof $Enums.PushDeliveryStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.companyInvoice`: Exposes CRUD operations for the **CompanyInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyInvoices
    * const companyInvoices = await prisma.companyInvoice.findMany()
    * ```
    */
  get companyInvoice(): Prisma.CompanyInvoiceDelegate<ExtArgs>;

  /**
   * `prisma.companyInvoiceItem`: Exposes CRUD operations for the **CompanyInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyInvoiceItems
    * const companyInvoiceItems = await prisma.companyInvoiceItem.findMany()
    * ```
    */
  get companyInvoiceItem(): Prisma.CompanyInvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.companyEmployee`: Exposes CRUD operations for the **CompanyEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyEmployees
    * const companyEmployees = await prisma.companyEmployee.findMany()
    * ```
    */
  get companyEmployee(): Prisma.CompanyEmployeeDelegate<ExtArgs>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs>;

  /**
   * `prisma.userLocation`: Exposes CRUD operations for the **UserLocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLocations
    * const userLocations = await prisma.userLocation.findMany()
    * ```
    */
  get userLocation(): Prisma.UserLocationDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs>;

  /**
   * `prisma.promotionBanner`: Exposes CRUD operations for the **PromotionBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionBanners
    * const promotionBanners = await prisma.promotionBanner.findMany()
    * ```
    */
  get promotionBanner(): Prisma.PromotionBannerDelegate<ExtArgs>;

  /**
   * `prisma.menuPromotionBanner`: Exposes CRUD operations for the **MenuPromotionBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuPromotionBanners
    * const menuPromotionBanners = await prisma.menuPromotionBanner.findMany()
    * ```
    */
  get menuPromotionBanner(): Prisma.MenuPromotionBannerDelegate<ExtArgs>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs>;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **Dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): Prisma.DishDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs>;

  /**
   * `prisma.couponRedemption`: Exposes CRUD operations for the **CouponRedemption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CouponRedemptions
    * const couponRedemptions = await prisma.couponRedemption.findMany()
    * ```
    */
  get couponRedemption(): Prisma.CouponRedemptionDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.metadata`: Exposes CRUD operations for the **Metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metadata
    * const metadata = await prisma.metadata.findMany()
    * ```
    */
  get metadata(): Prisma.MetadataDelegate<ExtArgs>;

  /**
   * `prisma.customerSegment`: Exposes CRUD operations for the **CustomerSegment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerSegments
    * const customerSegments = await prisma.customerSegment.findMany()
    * ```
    */
  get customerSegment(): Prisma.CustomerSegmentDelegate<ExtArgs>;

  /**
   * `prisma.inAppMessage`: Exposes CRUD operations for the **InAppMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InAppMessages
    * const inAppMessages = await prisma.inAppMessage.findMany()
    * ```
    */
  get inAppMessage(): Prisma.InAppMessageDelegate<ExtArgs>;

  /**
   * `prisma.inAppMessageRead`: Exposes CRUD operations for the **InAppMessageRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InAppMessageReads
    * const inAppMessageReads = await prisma.inAppMessageRead.findMany()
    * ```
    */
  get inAppMessageRead(): Prisma.InAppMessageReadDelegate<ExtArgs>;

  /**
   * `prisma.marketingWorkflow`: Exposes CRUD operations for the **MarketingWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingWorkflows
    * const marketingWorkflows = await prisma.marketingWorkflow.findMany()
    * ```
    */
  get marketingWorkflow(): Prisma.MarketingWorkflowDelegate<ExtArgs>;

  /**
   * `prisma.workflowExecutionLog`: Exposes CRUD operations for the **WorkflowExecutionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowExecutionLogs
    * const workflowExecutionLogs = await prisma.workflowExecutionLog.findMany()
    * ```
    */
  get workflowExecutionLog(): Prisma.WorkflowExecutionLogDelegate<ExtArgs>;

  /**
   * `prisma.segmentIncentive`: Exposes CRUD operations for the **SegmentIncentive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SegmentIncentives
    * const segmentIncentives = await prisma.segmentIncentive.findMany()
    * ```
    */
  get segmentIncentive(): Prisma.SegmentIncentiveDelegate<ExtArgs>;

  /**
   * `prisma.marketingTemplate`: Exposes CRUD operations for the **MarketingTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingTemplates
    * const marketingTemplates = await prisma.marketingTemplate.findMany()
    * ```
    */
  get marketingTemplate(): Prisma.MarketingTemplateDelegate<ExtArgs>;

  /**
   * `prisma.pushNotification`: Exposes CRUD operations for the **PushNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushNotifications
    * const pushNotifications = await prisma.pushNotification.findMany()
    * ```
    */
  get pushNotification(): Prisma.PushNotificationDelegate<ExtArgs>;

  /**
   * `prisma.pushNotificationLog`: Exposes CRUD operations for the **PushNotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushNotificationLogs
    * const pushNotificationLogs = await prisma.pushNotificationLog.findMany()
    * ```
    */
  get pushNotificationLog(): Prisma.PushNotificationLogDelegate<ExtArgs>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.paymentProviderConfig`: Exposes CRUD operations for the **PaymentProviderConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentProviderConfigs
    * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany()
    * ```
    */
  get paymentProviderConfig(): Prisma.PaymentProviderConfigDelegate<ExtArgs>;

  /**
   * `prisma.incentiveGrant`: Exposes CRUD operations for the **IncentiveGrant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncentiveGrants
    * const incentiveGrants = await prisma.incentiveGrant.findMany()
    * ```
    */
  get incentiveGrant(): Prisma.IncentiveGrantDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    Company: 'Company',
    CompanyInvoice: 'CompanyInvoice',
    CompanyInvoiceItem: 'CompanyInvoiceItem',
    CompanyEmployee: 'CompanyEmployee',
    Location: 'Location',
    User: 'User',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    UserLocation: 'UserLocation',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Menu: 'Menu',
    PromotionBanner: 'PromotionBanner',
    MenuPromotionBanner: 'MenuPromotionBanner',
    MenuItem: 'MenuItem',
    Dish: 'Dish',
    Order: 'Order',
    Coupon: 'Coupon',
    CouponRedemption: 'CouponRedemption',
    OrderItem: 'OrderItem',
    Metadata: 'Metadata',
    CustomerSegment: 'CustomerSegment',
    InAppMessage: 'InAppMessage',
    InAppMessageRead: 'InAppMessageRead',
    MarketingWorkflow: 'MarketingWorkflow',
    WorkflowExecutionLog: 'WorkflowExecutionLog',
    SegmentIncentive: 'SegmentIncentive',
    MarketingTemplate: 'MarketingTemplate',
    PushNotification: 'PushNotification',
    PushNotificationLog: 'PushNotificationLog',
    PushSubscription: 'PushSubscription',
    PaymentProviderConfig: 'PaymentProviderConfig',
    IncentiveGrant: 'IncentiveGrant'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "organization" | "company" | "companyInvoice" | "companyInvoiceItem" | "companyEmployee" | "location" | "user" | "wallet" | "walletTransaction" | "userLocation" | "account" | "session" | "verificationToken" | "menu" | "promotionBanner" | "menuPromotionBanner" | "menuItem" | "dish" | "order" | "coupon" | "couponRedemption" | "orderItem" | "metadata" | "customerSegment" | "inAppMessage" | "inAppMessageRead" | "marketingWorkflow" | "workflowExecutionLog" | "segmentIncentive" | "marketingTemplate" | "pushNotification" | "pushNotificationLog" | "pushSubscription" | "paymentProviderConfig" | "incentiveGrant"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyInvoice: {
        payload: Prisma.$CompanyInvoicePayload<ExtArgs>
        fields: Prisma.CompanyInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          findFirst: {
            args: Prisma.CompanyInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          findMany: {
            args: Prisma.CompanyInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>[]
          }
          create: {
            args: Prisma.CompanyInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          createMany: {
            args: Prisma.CompanyInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>[]
          }
          delete: {
            args: Prisma.CompanyInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          update: {
            args: Prisma.CompanyInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          deleteMany: {
            args: Prisma.CompanyInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoicePayload>
          }
          aggregate: {
            args: Prisma.CompanyInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyInvoice>
          }
          groupBy: {
            args: Prisma.CompanyInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvoiceCountAggregateOutputType> | number
          }
        }
      }
      CompanyInvoiceItem: {
        payload: Prisma.$CompanyInvoiceItemPayload<ExtArgs>
        fields: Prisma.CompanyInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.CompanyInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.CompanyInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.CompanyInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.CompanyInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.CompanyInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          update: {
            args: Prisma.CompanyInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.CompanyInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.CompanyInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyInvoiceItem>
          }
          groupBy: {
            args: Prisma.CompanyInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      CompanyEmployee: {
        payload: Prisma.$CompanyEmployeePayload<ExtArgs>
        fields: Prisma.CompanyEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          findFirst: {
            args: Prisma.CompanyEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          findMany: {
            args: Prisma.CompanyEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>[]
          }
          create: {
            args: Prisma.CompanyEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          createMany: {
            args: Prisma.CompanyEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>[]
          }
          delete: {
            args: Prisma.CompanyEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          update: {
            args: Prisma.CompanyEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          deleteMany: {
            args: Prisma.CompanyEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyEmployeePayload>
          }
          aggregate: {
            args: Prisma.CompanyEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyEmployee>
          }
          groupBy: {
            args: Prisma.CompanyEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyEmployeeCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      UserLocation: {
        payload: Prisma.$UserLocationPayload<ExtArgs>
        fields: Prisma.UserLocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          findFirst: {
            args: Prisma.UserLocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          findMany: {
            args: Prisma.UserLocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>[]
          }
          create: {
            args: Prisma.UserLocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          createMany: {
            args: Prisma.UserLocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>[]
          }
          delete: {
            args: Prisma.UserLocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          update: {
            args: Prisma.UserLocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          deleteMany: {
            args: Prisma.UserLocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLocationPayload>
          }
          aggregate: {
            args: Prisma.UserLocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLocation>
          }
          groupBy: {
            args: Prisma.UserLocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLocationCountArgs<ExtArgs>
            result: $Utils.Optional<UserLocationCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      PromotionBanner: {
        payload: Prisma.$PromotionBannerPayload<ExtArgs>
        fields: Prisma.PromotionBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          findFirst: {
            args: Prisma.PromotionBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          findMany: {
            args: Prisma.PromotionBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>[]
          }
          create: {
            args: Prisma.PromotionBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          createMany: {
            args: Prisma.PromotionBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionBannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>[]
          }
          delete: {
            args: Prisma.PromotionBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          update: {
            args: Prisma.PromotionBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          deleteMany: {
            args: Prisma.PromotionBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionBannerPayload>
          }
          aggregate: {
            args: Prisma.PromotionBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionBanner>
          }
          groupBy: {
            args: Prisma.PromotionBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionBannerCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionBannerCountAggregateOutputType> | number
          }
        }
      }
      MenuPromotionBanner: {
        payload: Prisma.$MenuPromotionBannerPayload<ExtArgs>
        fields: Prisma.MenuPromotionBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuPromotionBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuPromotionBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          findFirst: {
            args: Prisma.MenuPromotionBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuPromotionBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          findMany: {
            args: Prisma.MenuPromotionBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>[]
          }
          create: {
            args: Prisma.MenuPromotionBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          createMany: {
            args: Prisma.MenuPromotionBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuPromotionBannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>[]
          }
          delete: {
            args: Prisma.MenuPromotionBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          update: {
            args: Prisma.MenuPromotionBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          deleteMany: {
            args: Prisma.MenuPromotionBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuPromotionBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuPromotionBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPromotionBannerPayload>
          }
          aggregate: {
            args: Prisma.MenuPromotionBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuPromotionBanner>
          }
          groupBy: {
            args: Prisma.MenuPromotionBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuPromotionBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuPromotionBannerCountArgs<ExtArgs>
            result: $Utils.Optional<MenuPromotionBannerCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      Dish: {
        payload: Prisma.$DishPayload<ExtArgs>
        fields: Prisma.DishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findFirst: {
            args: Prisma.DishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findMany: {
            args: Prisma.DishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          create: {
            args: Prisma.DishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          createMany: {
            args: Prisma.DishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          delete: {
            args: Prisma.DishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          update: {
            args: Prisma.DishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          deleteMany: {
            args: Prisma.DishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          aggregate: {
            args: Prisma.DishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDish>
          }
          groupBy: {
            args: Prisma.DishGroupByArgs<ExtArgs>
            result: $Utils.Optional<DishGroupByOutputType>[]
          }
          count: {
            args: Prisma.DishCountArgs<ExtArgs>
            result: $Utils.Optional<DishCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      CouponRedemption: {
        payload: Prisma.$CouponRedemptionPayload<ExtArgs>
        fields: Prisma.CouponRedemptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponRedemptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findFirst: {
            args: Prisma.CouponRedemptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponRedemptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          findMany: {
            args: Prisma.CouponRedemptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          create: {
            args: Prisma.CouponRedemptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          createMany: {
            args: Prisma.CouponRedemptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponRedemptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>[]
          }
          delete: {
            args: Prisma.CouponRedemptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          update: {
            args: Prisma.CouponRedemptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          deleteMany: {
            args: Prisma.CouponRedemptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponRedemptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponRedemptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponRedemptionPayload>
          }
          aggregate: {
            args: Prisma.CouponRedemptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouponRedemption>
          }
          groupBy: {
            args: Prisma.CouponRedemptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponRedemptionCountArgs<ExtArgs>
            result: $Utils.Optional<CouponRedemptionCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Metadata: {
        payload: Prisma.$MetadataPayload<ExtArgs>
        fields: Prisma.MetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          findFirst: {
            args: Prisma.MetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          findMany: {
            args: Prisma.MetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>[]
          }
          create: {
            args: Prisma.MetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          createMany: {
            args: Prisma.MetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>[]
          }
          delete: {
            args: Prisma.MetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          update: {
            args: Prisma.MetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          deleteMany: {
            args: Prisma.MetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetadataPayload>
          }
          aggregate: {
            args: Prisma.MetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetadata>
          }
          groupBy: {
            args: Prisma.MetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetadataCountArgs<ExtArgs>
            result: $Utils.Optional<MetadataCountAggregateOutputType> | number
          }
        }
      }
      CustomerSegment: {
        payload: Prisma.$CustomerSegmentPayload<ExtArgs>
        fields: Prisma.CustomerSegmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerSegmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerSegmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          findFirst: {
            args: Prisma.CustomerSegmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerSegmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          findMany: {
            args: Prisma.CustomerSegmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>[]
          }
          create: {
            args: Prisma.CustomerSegmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          createMany: {
            args: Prisma.CustomerSegmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerSegmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>[]
          }
          delete: {
            args: Prisma.CustomerSegmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          update: {
            args: Prisma.CustomerSegmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          deleteMany: {
            args: Prisma.CustomerSegmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerSegmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerSegmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerSegmentPayload>
          }
          aggregate: {
            args: Prisma.CustomerSegmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerSegment>
          }
          groupBy: {
            args: Prisma.CustomerSegmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerSegmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerSegmentCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerSegmentCountAggregateOutputType> | number
          }
        }
      }
      InAppMessage: {
        payload: Prisma.$InAppMessagePayload<ExtArgs>
        fields: Prisma.InAppMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InAppMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InAppMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          findFirst: {
            args: Prisma.InAppMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InAppMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          findMany: {
            args: Prisma.InAppMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>[]
          }
          create: {
            args: Prisma.InAppMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          createMany: {
            args: Prisma.InAppMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InAppMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>[]
          }
          delete: {
            args: Prisma.InAppMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          update: {
            args: Prisma.InAppMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          deleteMany: {
            args: Prisma.InAppMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InAppMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InAppMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessagePayload>
          }
          aggregate: {
            args: Prisma.InAppMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInAppMessage>
          }
          groupBy: {
            args: Prisma.InAppMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<InAppMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.InAppMessageCountArgs<ExtArgs>
            result: $Utils.Optional<InAppMessageCountAggregateOutputType> | number
          }
        }
      }
      InAppMessageRead: {
        payload: Prisma.$InAppMessageReadPayload<ExtArgs>
        fields: Prisma.InAppMessageReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InAppMessageReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InAppMessageReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          findFirst: {
            args: Prisma.InAppMessageReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InAppMessageReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          findMany: {
            args: Prisma.InAppMessageReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>[]
          }
          create: {
            args: Prisma.InAppMessageReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          createMany: {
            args: Prisma.InAppMessageReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InAppMessageReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>[]
          }
          delete: {
            args: Prisma.InAppMessageReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          update: {
            args: Prisma.InAppMessageReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          deleteMany: {
            args: Prisma.InAppMessageReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InAppMessageReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InAppMessageReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InAppMessageReadPayload>
          }
          aggregate: {
            args: Prisma.InAppMessageReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInAppMessageRead>
          }
          groupBy: {
            args: Prisma.InAppMessageReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<InAppMessageReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.InAppMessageReadCountArgs<ExtArgs>
            result: $Utils.Optional<InAppMessageReadCountAggregateOutputType> | number
          }
        }
      }
      MarketingWorkflow: {
        payload: Prisma.$MarketingWorkflowPayload<ExtArgs>
        fields: Prisma.MarketingWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          findFirst: {
            args: Prisma.MarketingWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          findMany: {
            args: Prisma.MarketingWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>[]
          }
          create: {
            args: Prisma.MarketingWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          createMany: {
            args: Prisma.MarketingWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>[]
          }
          delete: {
            args: Prisma.MarketingWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          update: {
            args: Prisma.MarketingWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.MarketingWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingWorkflowPayload>
          }
          aggregate: {
            args: Prisma.MarketingWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingWorkflow>
          }
          groupBy: {
            args: Prisma.MarketingWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingWorkflowCountAggregateOutputType> | number
          }
        }
      }
      WorkflowExecutionLog: {
        payload: Prisma.$WorkflowExecutionLogPayload<ExtArgs>
        fields: Prisma.WorkflowExecutionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowExecutionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowExecutionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          findFirst: {
            args: Prisma.WorkflowExecutionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowExecutionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          findMany: {
            args: Prisma.WorkflowExecutionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>[]
          }
          create: {
            args: Prisma.WorkflowExecutionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          createMany: {
            args: Prisma.WorkflowExecutionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowExecutionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>[]
          }
          delete: {
            args: Prisma.WorkflowExecutionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          update: {
            args: Prisma.WorkflowExecutionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowExecutionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowExecutionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkflowExecutionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowExecutionLogPayload>
          }
          aggregate: {
            args: Prisma.WorkflowExecutionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowExecutionLog>
          }
          groupBy: {
            args: Prisma.WorkflowExecutionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowExecutionLogCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowExecutionLogCountAggregateOutputType> | number
          }
        }
      }
      SegmentIncentive: {
        payload: Prisma.$SegmentIncentivePayload<ExtArgs>
        fields: Prisma.SegmentIncentiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SegmentIncentiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SegmentIncentiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          findFirst: {
            args: Prisma.SegmentIncentiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SegmentIncentiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          findMany: {
            args: Prisma.SegmentIncentiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>[]
          }
          create: {
            args: Prisma.SegmentIncentiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          createMany: {
            args: Prisma.SegmentIncentiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SegmentIncentiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>[]
          }
          delete: {
            args: Prisma.SegmentIncentiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          update: {
            args: Prisma.SegmentIncentiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          deleteMany: {
            args: Prisma.SegmentIncentiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SegmentIncentiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SegmentIncentiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SegmentIncentivePayload>
          }
          aggregate: {
            args: Prisma.SegmentIncentiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSegmentIncentive>
          }
          groupBy: {
            args: Prisma.SegmentIncentiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<SegmentIncentiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.SegmentIncentiveCountArgs<ExtArgs>
            result: $Utils.Optional<SegmentIncentiveCountAggregateOutputType> | number
          }
        }
      }
      MarketingTemplate: {
        payload: Prisma.$MarketingTemplatePayload<ExtArgs>
        fields: Prisma.MarketingTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          findFirst: {
            args: Prisma.MarketingTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          findMany: {
            args: Prisma.MarketingTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>[]
          }
          create: {
            args: Prisma.MarketingTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          createMany: {
            args: Prisma.MarketingTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>[]
          }
          delete: {
            args: Prisma.MarketingTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          update: {
            args: Prisma.MarketingTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          deleteMany: {
            args: Prisma.MarketingTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTemplatePayload>
          }
          aggregate: {
            args: Prisma.MarketingTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingTemplate>
          }
          groupBy: {
            args: Prisma.MarketingTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingTemplateCountAggregateOutputType> | number
          }
        }
      }
      PushNotification: {
        payload: Prisma.$PushNotificationPayload<ExtArgs>
        fields: Prisma.PushNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          findFirst: {
            args: Prisma.PushNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          findMany: {
            args: Prisma.PushNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>[]
          }
          create: {
            args: Prisma.PushNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          createMany: {
            args: Prisma.PushNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>[]
          }
          delete: {
            args: Prisma.PushNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          update: {
            args: Prisma.PushNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          deleteMany: {
            args: Prisma.PushNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PushNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationPayload>
          }
          aggregate: {
            args: Prisma.PushNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushNotification>
          }
          groupBy: {
            args: Prisma.PushNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<PushNotificationCountAggregateOutputType> | number
          }
        }
      }
      PushNotificationLog: {
        payload: Prisma.$PushNotificationLogPayload<ExtArgs>
        fields: Prisma.PushNotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushNotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushNotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          findFirst: {
            args: Prisma.PushNotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushNotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          findMany: {
            args: Prisma.PushNotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>[]
          }
          create: {
            args: Prisma.PushNotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          createMany: {
            args: Prisma.PushNotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushNotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>[]
          }
          delete: {
            args: Prisma.PushNotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          update: {
            args: Prisma.PushNotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.PushNotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushNotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PushNotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushNotificationLogPayload>
          }
          aggregate: {
            args: Prisma.PushNotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushNotificationLog>
          }
          groupBy: {
            args: Prisma.PushNotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushNotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushNotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<PushNotificationLogCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PaymentProviderConfig: {
        payload: Prisma.$PaymentProviderConfigPayload<ExtArgs>
        fields: Prisma.PaymentProviderConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentProviderConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          findFirst: {
            args: Prisma.PaymentProviderConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          findMany: {
            args: Prisma.PaymentProviderConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>[]
          }
          create: {
            args: Prisma.PaymentProviderConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          createMany: {
            args: Prisma.PaymentProviderConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>[]
          }
          delete: {
            args: Prisma.PaymentProviderConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          update: {
            args: Prisma.PaymentProviderConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          deleteMany: {
            args: Prisma.PaymentProviderConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentProviderConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentProviderConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentProviderConfigPayload>
          }
          aggregate: {
            args: Prisma.PaymentProviderConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentProviderConfig>
          }
          groupBy: {
            args: Prisma.PaymentProviderConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentProviderConfigCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentProviderConfigCountAggregateOutputType> | number
          }
        }
      }
      IncentiveGrant: {
        payload: Prisma.$IncentiveGrantPayload<ExtArgs>
        fields: Prisma.IncentiveGrantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncentiveGrantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncentiveGrantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          findFirst: {
            args: Prisma.IncentiveGrantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncentiveGrantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          findMany: {
            args: Prisma.IncentiveGrantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>[]
          }
          create: {
            args: Prisma.IncentiveGrantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          createMany: {
            args: Prisma.IncentiveGrantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncentiveGrantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>[]
          }
          delete: {
            args: Prisma.IncentiveGrantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          update: {
            args: Prisma.IncentiveGrantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          deleteMany: {
            args: Prisma.IncentiveGrantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncentiveGrantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncentiveGrantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentiveGrantPayload>
          }
          aggregate: {
            args: Prisma.IncentiveGrantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncentiveGrant>
          }
          groupBy: {
            args: Prisma.IncentiveGrantGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncentiveGrantGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncentiveGrantCountArgs<ExtArgs>
            result: $Utils.Optional<IncentiveGrantCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    locations: number
    users: number
    segments: number
    inAppMessages: number
    workflows: number
    segmentIncentives: number
    marketingTemplates: number
    pushNotifications: number
    paymentConfigs: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | OrganizationCountOutputTypeCountLocationsArgs
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    segments?: boolean | OrganizationCountOutputTypeCountSegmentsArgs
    inAppMessages?: boolean | OrganizationCountOutputTypeCountInAppMessagesArgs
    workflows?: boolean | OrganizationCountOutputTypeCountWorkflowsArgs
    segmentIncentives?: boolean | OrganizationCountOutputTypeCountSegmentIncentivesArgs
    marketingTemplates?: boolean | OrganizationCountOutputTypeCountMarketingTemplatesArgs
    pushNotifications?: boolean | OrganizationCountOutputTypeCountPushNotificationsArgs
    paymentConfigs?: boolean | OrganizationCountOutputTypeCountPaymentConfigsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSegmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSegmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountInAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingWorkflowWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSegmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentIncentiveWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMarketingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingTemplateWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountPaymentConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderConfigWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    employees: number
    orders: number
    invoices: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | CompanyCountOutputTypeCountEmployeesArgs
    orders?: boolean | CompanyCountOutputTypeCountOrdersArgs
    invoices?: boolean | CompanyCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEmployeeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvoiceWhereInput
  }


  /**
   * Count Type CompanyInvoiceCountOutputType
   */

  export type CompanyInvoiceCountOutputType = {
    items: number
  }

  export type CompanyInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CompanyInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CompanyInvoiceCountOutputType without action
   */
  export type CompanyInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceCountOutputType
     */
    select?: CompanyInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyInvoiceCountOutputType without action
   */
  export type CompanyInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvoiceItemWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    menus: number
    orders: number
    users: number
    coupons: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | LocationCountOutputTypeCountMenusArgs
    orders?: boolean | LocationCountOutputTypeCountOrdersArgs
    users?: boolean | LocationCountOutputTypeCountUsersArgs
    coupons?: boolean | LocationCountOutputTypeCountCouponsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountMenusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLocationWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    locations: number
    companyEmployees: number
    orders: number
    sessions: number
    accounts: number
    couponRedemptions: number
    incentiveGrants: number
    walletTransactions: number
    performedWalletActions: number
    pushNotificationLogs: number
    pushSubscriptions: number
    paymentConfigChanges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | UserCountOutputTypeCountLocationsArgs
    companyEmployees?: boolean | UserCountOutputTypeCountCompanyEmployeesArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    couponRedemptions?: boolean | UserCountOutputTypeCountCouponRedemptionsArgs
    incentiveGrants?: boolean | UserCountOutputTypeCountIncentiveGrantsArgs
    walletTransactions?: boolean | UserCountOutputTypeCountWalletTransactionsArgs
    performedWalletActions?: boolean | UserCountOutputTypeCountPerformedWalletActionsArgs
    pushNotificationLogs?: boolean | UserCountOutputTypeCountPushNotificationLogsArgs
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs
    paymentConfigChanges?: boolean | UserCountOutputTypeCountPaymentConfigChangesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLocationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompanyEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCouponRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIncentiveGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveGrantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPerformedWalletActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushNotificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentConfigChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderConfigWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    menuItems: number
    promotionBanners: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItems?: boolean | MenuCountOutputTypeCountMenuItemsArgs
    promotionBanners?: boolean | MenuCountOutputTypeCountPromotionBannersArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountPromotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuPromotionBannerWhereInput
  }


  /**
   * Count Type PromotionBannerCountOutputType
   */

  export type PromotionBannerCountOutputType = {
    menuAssignments: number
  }

  export type PromotionBannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuAssignments?: boolean | PromotionBannerCountOutputTypeCountMenuAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * PromotionBannerCountOutputType without action
   */
  export type PromotionBannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBannerCountOutputType
     */
    select?: PromotionBannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionBannerCountOutputType without action
   */
  export type PromotionBannerCountOutputTypeCountMenuAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuPromotionBannerWhereInput
  }


  /**
   * Count Type MenuItemCountOutputType
   */

  export type MenuItemCountOutputType = {
    orderItems: number
  }

  export type MenuItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | MenuItemCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemCountOutputType
     */
    select?: MenuItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type DishCountOutputType
   */

  export type DishCountOutputType = {
    menuItems: number
    coupons: number
  }

  export type DishCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItems?: boolean | DishCountOutputTypeCountMenuItemsArgs
    coupons?: boolean | DishCountOutputTypeCountCouponsArgs
  }

  // Custom InputTypes
  /**
   * DishCountOutputType without action
   */
  export type DishCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCountOutputType
     */
    select?: DishCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DishCountOutputType without action
   */
  export type DishCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }

  /**
   * DishCountOutputType without action
   */
  export type DishCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    couponRedemptions: number
    walletTransactions: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    couponRedemptions?: boolean | OrderCountOutputTypeCountCouponRedemptionsArgs
    walletTransactions?: boolean | OrderCountOutputTypeCountWalletTransactionsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountCouponRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountWalletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    redemptions: number
    incentiveGrants: number
    segmentIncentives: number
    promotionBanners: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redemptions?: boolean | CouponCountOutputTypeCountRedemptionsArgs
    incentiveGrants?: boolean | CouponCountOutputTypeCountIncentiveGrantsArgs
    segmentIncentives?: boolean | CouponCountOutputTypeCountSegmentIncentivesArgs
    promotionBanners?: boolean | CouponCountOutputTypeCountPromotionBannersArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountIncentiveGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveGrantWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountSegmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentIncentiveWhereInput
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountPromotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionBannerWhereInput
  }


  /**
   * Count Type CustomerSegmentCountOutputType
   */

  export type CustomerSegmentCountOutputType = {
    inAppMessages: number
    workflows: number
    segmentIncentives: number
    pushNotifications: number
  }

  export type CustomerSegmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inAppMessages?: boolean | CustomerSegmentCountOutputTypeCountInAppMessagesArgs
    workflows?: boolean | CustomerSegmentCountOutputTypeCountWorkflowsArgs
    segmentIncentives?: boolean | CustomerSegmentCountOutputTypeCountSegmentIncentivesArgs
    pushNotifications?: boolean | CustomerSegmentCountOutputTypeCountPushNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CustomerSegmentCountOutputType without action
   */
  export type CustomerSegmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegmentCountOutputType
     */
    select?: CustomerSegmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerSegmentCountOutputType without action
   */
  export type CustomerSegmentCountOutputTypeCountInAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageWhereInput
  }

  /**
   * CustomerSegmentCountOutputType without action
   */
  export type CustomerSegmentCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingWorkflowWhereInput
  }

  /**
   * CustomerSegmentCountOutputType without action
   */
  export type CustomerSegmentCountOutputTypeCountSegmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentIncentiveWhereInput
  }

  /**
   * CustomerSegmentCountOutputType without action
   */
  export type CustomerSegmentCountOutputTypeCountPushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationWhereInput
  }


  /**
   * Count Type InAppMessageCountOutputType
   */

  export type InAppMessageCountOutputType = {
    readBy: number
  }

  export type InAppMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readBy?: boolean | InAppMessageCountOutputTypeCountReadByArgs
  }

  // Custom InputTypes
  /**
   * InAppMessageCountOutputType without action
   */
  export type InAppMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageCountOutputType
     */
    select?: InAppMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InAppMessageCountOutputType without action
   */
  export type InAppMessageCountOutputTypeCountReadByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageReadWhereInput
  }


  /**
   * Count Type MarketingWorkflowCountOutputType
   */

  export type MarketingWorkflowCountOutputType = {
    executionLogs: number
  }

  export type MarketingWorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    executionLogs?: boolean | MarketingWorkflowCountOutputTypeCountExecutionLogsArgs
  }

  // Custom InputTypes
  /**
   * MarketingWorkflowCountOutputType without action
   */
  export type MarketingWorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflowCountOutputType
     */
    select?: MarketingWorkflowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketingWorkflowCountOutputType without action
   */
  export type MarketingWorkflowCountOutputTypeCountExecutionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionLogWhereInput
  }


  /**
   * Count Type SegmentIncentiveCountOutputType
   */

  export type SegmentIncentiveCountOutputType = {
    grants: number
  }

  export type SegmentIncentiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grants?: boolean | SegmentIncentiveCountOutputTypeCountGrantsArgs
  }

  // Custom InputTypes
  /**
   * SegmentIncentiveCountOutputType without action
   */
  export type SegmentIncentiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentiveCountOutputType
     */
    select?: SegmentIncentiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SegmentIncentiveCountOutputType without action
   */
  export type SegmentIncentiveCountOutputTypeCountGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveGrantWhereInput
  }


  /**
   * Count Type MarketingTemplateCountOutputType
   */

  export type MarketingTemplateCountOutputType = {
    inAppMessages: number
    promotionBanners: number
    pushNotifications: number
  }

  export type MarketingTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inAppMessages?: boolean | MarketingTemplateCountOutputTypeCountInAppMessagesArgs
    promotionBanners?: boolean | MarketingTemplateCountOutputTypeCountPromotionBannersArgs
    pushNotifications?: boolean | MarketingTemplateCountOutputTypeCountPushNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MarketingTemplateCountOutputType without action
   */
  export type MarketingTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplateCountOutputType
     */
    select?: MarketingTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketingTemplateCountOutputType without action
   */
  export type MarketingTemplateCountOutputTypeCountInAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageWhereInput
  }

  /**
   * MarketingTemplateCountOutputType without action
   */
  export type MarketingTemplateCountOutputTypeCountPromotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionBannerWhereInput
  }

  /**
   * MarketingTemplateCountOutputType without action
   */
  export type MarketingTemplateCountOutputTypeCountPushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationWhereInput
  }


  /**
   * Count Type PushNotificationCountOutputType
   */

  export type PushNotificationCountOutputType = {
    logs: number
  }

  export type PushNotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | PushNotificationCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * PushNotificationCountOutputType without action
   */
  export type PushNotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationCountOutputType
     */
    select?: PushNotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PushNotificationCountOutputType without action
   */
  export type PushNotificationCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logoUrl: number
    primaryColor: number
    secondaryColor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | Organization$locationsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    segments?: boolean | Organization$segmentsArgs<ExtArgs>
    inAppMessages?: boolean | Organization$inAppMessagesArgs<ExtArgs>
    workflows?: boolean | Organization$workflowsArgs<ExtArgs>
    segmentIncentives?: boolean | Organization$segmentIncentivesArgs<ExtArgs>
    marketingTemplates?: boolean | Organization$marketingTemplatesArgs<ExtArgs>
    pushNotifications?: boolean | Organization$pushNotificationsArgs<ExtArgs>
    paymentConfigs?: boolean | Organization$paymentConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Organization$locationsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    segments?: boolean | Organization$segmentsArgs<ExtArgs>
    inAppMessages?: boolean | Organization$inAppMessagesArgs<ExtArgs>
    workflows?: boolean | Organization$workflowsArgs<ExtArgs>
    segmentIncentives?: boolean | Organization$segmentIncentivesArgs<ExtArgs>
    marketingTemplates?: boolean | Organization$marketingTemplatesArgs<ExtArgs>
    pushNotifications?: boolean | Organization$pushNotificationsArgs<ExtArgs>
    paymentConfigs?: boolean | Organization$paymentConfigsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      segments: Prisma.$CustomerSegmentPayload<ExtArgs>[]
      inAppMessages: Prisma.$InAppMessagePayload<ExtArgs>[]
      workflows: Prisma.$MarketingWorkflowPayload<ExtArgs>[]
      segmentIncentives: Prisma.$SegmentIncentivePayload<ExtArgs>[]
      marketingTemplates: Prisma.$MarketingTemplatePayload<ExtArgs>[]
      pushNotifications: Prisma.$PushNotificationPayload<ExtArgs>[]
      paymentConfigs: Prisma.$PaymentProviderConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logoUrl: string | null
      primaryColor: string | null
      secondaryColor: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends Organization$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    segments<T extends Organization$segmentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$segmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findMany"> | Null>
    inAppMessages<T extends Organization$inAppMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$inAppMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends Organization$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    segmentIncentives<T extends Organization$segmentIncentivesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$segmentIncentivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findMany"> | Null>
    marketingTemplates<T extends Organization$marketingTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$marketingTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    pushNotifications<T extends Organization$pushNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$pushNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    paymentConfigs<T extends Organization$paymentConfigsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$paymentConfigsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly logoUrl: FieldRef<"Organization", 'String'>
    readonly primaryColor: FieldRef<"Organization", 'String'>
    readonly secondaryColor: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.locations
   */
  export type Organization$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.segments
   */
  export type Organization$segmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    where?: CustomerSegmentWhereInput
    orderBy?: CustomerSegmentOrderByWithRelationInput | CustomerSegmentOrderByWithRelationInput[]
    cursor?: CustomerSegmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerSegmentScalarFieldEnum | CustomerSegmentScalarFieldEnum[]
  }

  /**
   * Organization.inAppMessages
   */
  export type Organization$inAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    where?: InAppMessageWhereInput
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    cursor?: InAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * Organization.workflows
   */
  export type Organization$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    where?: MarketingWorkflowWhereInput
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    cursor?: MarketingWorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingWorkflowScalarFieldEnum | MarketingWorkflowScalarFieldEnum[]
  }

  /**
   * Organization.segmentIncentives
   */
  export type Organization$segmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    where?: SegmentIncentiveWhereInput
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    cursor?: SegmentIncentiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * Organization.marketingTemplates
   */
  export type Organization$marketingTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    where?: MarketingTemplateWhereInput
    orderBy?: MarketingTemplateOrderByWithRelationInput | MarketingTemplateOrderByWithRelationInput[]
    cursor?: MarketingTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingTemplateScalarFieldEnum | MarketingTemplateScalarFieldEnum[]
  }

  /**
   * Organization.pushNotifications
   */
  export type Organization$pushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    where?: PushNotificationWhereInput
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    cursor?: PushNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * Organization.paymentConfigs
   */
  export type Organization$paymentConfigsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    where?: PaymentProviderConfigWhereInput
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    cursor?: PaymentProviderConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    subsidyValue: Decimal | null
    subsidyMaxPerDay: Decimal | null
  }

  export type CompanySumAggregateOutputType = {
    subsidyValue: Decimal | null
    subsidyMaxPerDay: Decimal | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    contractNumber: string | null
    isActive: boolean | null
    subsidyType: $Enums.SubsidyType | null
    subsidyValue: Decimal | null
    subsidyMaxPerDay: Decimal | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contractNumber: string | null
    isActive: boolean | null
    subsidyType: $Enums.SubsidyType | null
    subsidyValue: Decimal | null
    subsidyMaxPerDay: Decimal | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    contractNumber: number
    isActive: number
    subsidyType: number
    subsidyValue: number
    subsidyMaxPerDay: number
    validFrom: number
    validUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    subsidyValue?: true
    subsidyMaxPerDay?: true
  }

  export type CompanySumAggregateInputType = {
    subsidyValue?: true
    subsidyMaxPerDay?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    contractNumber?: true
    isActive?: true
    subsidyType?: true
    subsidyValue?: true
    subsidyMaxPerDay?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    contractNumber?: true
    isActive?: true
    subsidyType?: true
    subsidyValue?: true
    subsidyMaxPerDay?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    contractNumber?: true
    isActive?: true
    subsidyType?: true
    subsidyValue?: true
    subsidyMaxPerDay?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    contractNumber: string | null
    isActive: boolean
    subsidyType: $Enums.SubsidyType
    subsidyValue: Decimal | null
    subsidyMaxPerDay: Decimal | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contractNumber?: boolean
    isActive?: boolean
    subsidyType?: boolean
    subsidyValue?: boolean
    subsidyMaxPerDay?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Company$employeesArgs<ExtArgs>
    orders?: boolean | Company$ordersArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contractNumber?: boolean
    isActive?: boolean
    subsidyType?: boolean
    subsidyValue?: boolean
    subsidyMaxPerDay?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    contractNumber?: boolean
    isActive?: boolean
    subsidyType?: boolean
    subsidyValue?: boolean
    subsidyMaxPerDay?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Company$employeesArgs<ExtArgs>
    orders?: boolean | Company$ordersArgs<ExtArgs>
    invoices?: boolean | Company$invoicesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      employees: Prisma.$CompanyEmployeePayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$CompanyInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contractNumber: string | null
      isActive: boolean
      subsidyType: $Enums.SubsidyType
      subsidyValue: Prisma.Decimal | null
      subsidyMaxPerDay: Prisma.Decimal | null
      validFrom: Date | null
      validUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Company$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Company$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Company$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Company$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Company$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly contractNumber: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly subsidyType: FieldRef<"Company", 'SubsidyType'>
    readonly subsidyValue: FieldRef<"Company", 'Decimal'>
    readonly subsidyMaxPerDay: FieldRef<"Company", 'Decimal'>
    readonly validFrom: FieldRef<"Company", 'DateTime'>
    readonly validUntil: FieldRef<"Company", 'DateTime'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }

  /**
   * Company.employees
   */
  export type Company$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    where?: CompanyEmployeeWhereInput
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    cursor?: CompanyEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * Company.orders
   */
  export type Company$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Company.invoices
   */
  export type Company$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    where?: CompanyInvoiceWhereInput
    orderBy?: CompanyInvoiceOrderByWithRelationInput | CompanyInvoiceOrderByWithRelationInput[]
    cursor?: CompanyInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvoiceScalarFieldEnum | CompanyInvoiceScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyInvoice
   */

  export type AggregateCompanyInvoice = {
    _count: CompanyInvoiceCountAggregateOutputType | null
    _avg: CompanyInvoiceAvgAggregateOutputType | null
    _sum: CompanyInvoiceSumAggregateOutputType | null
    _min: CompanyInvoiceMinAggregateOutputType | null
    _max: CompanyInvoiceMaxAggregateOutputType | null
  }

  export type CompanyInvoiceAvgAggregateOutputType = {
    year: number | null
    month: number | null
    totalAmount: Decimal | null
  }

  export type CompanyInvoiceSumAggregateOutputType = {
    year: number | null
    month: number | null
    totalAmount: Decimal | null
  }

  export type CompanyInvoiceMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    year: number | null
    month: number | null
    status: string | null
    totalAmount: Decimal | null
    invoicedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvoiceMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    year: number | null
    month: number | null
    status: string | null
    totalAmount: Decimal | null
    invoicedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyInvoiceCountAggregateOutputType = {
    id: number
    companyId: number
    year: number
    month: number
    status: number
    totalAmount: number
    invoicedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyInvoiceAvgAggregateInputType = {
    year?: true
    month?: true
    totalAmount?: true
  }

  export type CompanyInvoiceSumAggregateInputType = {
    year?: true
    month?: true
    totalAmount?: true
  }

  export type CompanyInvoiceMinAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    status?: true
    totalAmount?: true
    invoicedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvoiceMaxAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    status?: true
    totalAmount?: true
    invoicedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyInvoiceCountAggregateInputType = {
    id?: true
    companyId?: true
    year?: true
    month?: true
    status?: true
    totalAmount?: true
    invoicedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvoice to aggregate.
     */
    where?: CompanyInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoices to fetch.
     */
    orderBy?: CompanyInvoiceOrderByWithRelationInput | CompanyInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyInvoices
    **/
    _count?: true | CompanyInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyInvoiceMaxAggregateInputType
  }

  export type GetCompanyInvoiceAggregateType<T extends CompanyInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyInvoice[P]>
      : GetScalarType<T[P], AggregateCompanyInvoice[P]>
  }




  export type CompanyInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvoiceWhereInput
    orderBy?: CompanyInvoiceOrderByWithAggregationInput | CompanyInvoiceOrderByWithAggregationInput[]
    by: CompanyInvoiceScalarFieldEnum[] | CompanyInvoiceScalarFieldEnum
    having?: CompanyInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyInvoiceCountAggregateInputType | true
    _avg?: CompanyInvoiceAvgAggregateInputType
    _sum?: CompanyInvoiceSumAggregateInputType
    _min?: CompanyInvoiceMinAggregateInputType
    _max?: CompanyInvoiceMaxAggregateInputType
  }

  export type CompanyInvoiceGroupByOutputType = {
    id: string
    companyId: string
    year: number
    month: number
    status: string
    totalAmount: Decimal
    invoicedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyInvoiceCountAggregateOutputType | null
    _avg: CompanyInvoiceAvgAggregateOutputType | null
    _sum: CompanyInvoiceSumAggregateOutputType | null
    _min: CompanyInvoiceMinAggregateOutputType | null
    _max: CompanyInvoiceMaxAggregateOutputType | null
  }

  type GetCompanyInvoiceGroupByPayload<T extends CompanyInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type CompanyInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    status?: boolean
    totalAmount?: boolean
    invoicedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | CompanyInvoice$itemsArgs<ExtArgs>
    _count?: boolean | CompanyInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvoice"]>

  export type CompanyInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    status?: boolean
    totalAmount?: boolean
    invoicedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvoice"]>

  export type CompanyInvoiceSelectScalar = {
    id?: boolean
    companyId?: boolean
    year?: boolean
    month?: boolean
    status?: boolean
    totalAmount?: boolean
    invoicedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | CompanyInvoice$itemsArgs<ExtArgs>
    _count?: boolean | CompanyInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyInvoice"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$CompanyInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      year: number
      month: number
      status: string
      totalAmount: Prisma.Decimal
      invoicedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyInvoice"]>
    composites: {}
  }

  type CompanyInvoiceGetPayload<S extends boolean | null | undefined | CompanyInvoiceDefaultArgs> = $Result.GetResult<Prisma.$CompanyInvoicePayload, S>

  type CompanyInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyInvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyInvoiceCountAggregateInputType | true
    }

  export interface CompanyInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyInvoice'], meta: { name: 'CompanyInvoice' } }
    /**
     * Find zero or one CompanyInvoice that matches the filter.
     * @param {CompanyInvoiceFindUniqueArgs} args - Arguments to find a CompanyInvoice
     * @example
     * // Get one CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyInvoiceFindUniqueArgs>(args: SelectSubset<T, CompanyInvoiceFindUniqueArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyInvoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyInvoiceFindUniqueOrThrowArgs} args - Arguments to find a CompanyInvoice
     * @example
     * // Get one CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceFindFirstArgs} args - Arguments to find a CompanyInvoice
     * @example
     * // Get one CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyInvoiceFindFirstArgs>(args?: SelectSubset<T, CompanyInvoiceFindFirstArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceFindFirstOrThrowArgs} args - Arguments to find a CompanyInvoice
     * @example
     * // Get one CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyInvoices
     * const companyInvoices = await prisma.companyInvoice.findMany()
     * 
     * // Get first 10 CompanyInvoices
     * const companyInvoices = await prisma.companyInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyInvoiceWithIdOnly = await prisma.companyInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyInvoiceFindManyArgs>(args?: SelectSubset<T, CompanyInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyInvoice.
     * @param {CompanyInvoiceCreateArgs} args - Arguments to create a CompanyInvoice.
     * @example
     * // Create one CompanyInvoice
     * const CompanyInvoice = await prisma.companyInvoice.create({
     *   data: {
     *     // ... data to create a CompanyInvoice
     *   }
     * })
     * 
     */
    create<T extends CompanyInvoiceCreateArgs>(args: SelectSubset<T, CompanyInvoiceCreateArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyInvoices.
     * @param {CompanyInvoiceCreateManyArgs} args - Arguments to create many CompanyInvoices.
     * @example
     * // Create many CompanyInvoices
     * const companyInvoice = await prisma.companyInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyInvoiceCreateManyArgs>(args?: SelectSubset<T, CompanyInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyInvoices and returns the data saved in the database.
     * @param {CompanyInvoiceCreateManyAndReturnArgs} args - Arguments to create many CompanyInvoices.
     * @example
     * // Create many CompanyInvoices
     * const companyInvoice = await prisma.companyInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyInvoices and only return the `id`
     * const companyInvoiceWithIdOnly = await prisma.companyInvoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyInvoice.
     * @param {CompanyInvoiceDeleteArgs} args - Arguments to delete one CompanyInvoice.
     * @example
     * // Delete one CompanyInvoice
     * const CompanyInvoice = await prisma.companyInvoice.delete({
     *   where: {
     *     // ... filter to delete one CompanyInvoice
     *   }
     * })
     * 
     */
    delete<T extends CompanyInvoiceDeleteArgs>(args: SelectSubset<T, CompanyInvoiceDeleteArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyInvoice.
     * @param {CompanyInvoiceUpdateArgs} args - Arguments to update one CompanyInvoice.
     * @example
     * // Update one CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyInvoiceUpdateArgs>(args: SelectSubset<T, CompanyInvoiceUpdateArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyInvoices.
     * @param {CompanyInvoiceDeleteManyArgs} args - Arguments to filter CompanyInvoices to delete.
     * @example
     * // Delete a few CompanyInvoices
     * const { count } = await prisma.companyInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyInvoiceDeleteManyArgs>(args?: SelectSubset<T, CompanyInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyInvoices
     * const companyInvoice = await prisma.companyInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyInvoiceUpdateManyArgs>(args: SelectSubset<T, CompanyInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyInvoice.
     * @param {CompanyInvoiceUpsertArgs} args - Arguments to update or create a CompanyInvoice.
     * @example
     * // Update or create a CompanyInvoice
     * const companyInvoice = await prisma.companyInvoice.upsert({
     *   create: {
     *     // ... data to create a CompanyInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyInvoice we want to update
     *   }
     * })
     */
    upsert<T extends CompanyInvoiceUpsertArgs>(args: SelectSubset<T, CompanyInvoiceUpsertArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceCountArgs} args - Arguments to filter CompanyInvoices to count.
     * @example
     * // Count the number of CompanyInvoices
     * const count = await prisma.companyInvoice.count({
     *   where: {
     *     // ... the filter for the CompanyInvoices we want to count
     *   }
     * })
    **/
    count<T extends CompanyInvoiceCountArgs>(
      args?: Subset<T, CompanyInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyInvoiceAggregateArgs>(args: Subset<T, CompanyInvoiceAggregateArgs>): Prisma.PrismaPromise<GetCompanyInvoiceAggregateType<T>>

    /**
     * Group by CompanyInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: CompanyInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyInvoice model
   */
  readonly fields: CompanyInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends CompanyInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, CompanyInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyInvoice model
   */ 
  interface CompanyInvoiceFieldRefs {
    readonly id: FieldRef<"CompanyInvoice", 'String'>
    readonly companyId: FieldRef<"CompanyInvoice", 'String'>
    readonly year: FieldRef<"CompanyInvoice", 'Int'>
    readonly month: FieldRef<"CompanyInvoice", 'Int'>
    readonly status: FieldRef<"CompanyInvoice", 'String'>
    readonly totalAmount: FieldRef<"CompanyInvoice", 'Decimal'>
    readonly invoicedAt: FieldRef<"CompanyInvoice", 'DateTime'>
    readonly createdAt: FieldRef<"CompanyInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyInvoice findUnique
   */
  export type CompanyInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoice to fetch.
     */
    where: CompanyInvoiceWhereUniqueInput
  }

  /**
   * CompanyInvoice findUniqueOrThrow
   */
  export type CompanyInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoice to fetch.
     */
    where: CompanyInvoiceWhereUniqueInput
  }

  /**
   * CompanyInvoice findFirst
   */
  export type CompanyInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoice to fetch.
     */
    where?: CompanyInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoices to fetch.
     */
    orderBy?: CompanyInvoiceOrderByWithRelationInput | CompanyInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvoices.
     */
    cursor?: CompanyInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvoices.
     */
    distinct?: CompanyInvoiceScalarFieldEnum | CompanyInvoiceScalarFieldEnum[]
  }

  /**
   * CompanyInvoice findFirstOrThrow
   */
  export type CompanyInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoice to fetch.
     */
    where?: CompanyInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoices to fetch.
     */
    orderBy?: CompanyInvoiceOrderByWithRelationInput | CompanyInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvoices.
     */
    cursor?: CompanyInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvoices.
     */
    distinct?: CompanyInvoiceScalarFieldEnum | CompanyInvoiceScalarFieldEnum[]
  }

  /**
   * CompanyInvoice findMany
   */
  export type CompanyInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoices to fetch.
     */
    where?: CompanyInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoices to fetch.
     */
    orderBy?: CompanyInvoiceOrderByWithRelationInput | CompanyInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyInvoices.
     */
    cursor?: CompanyInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoices.
     */
    skip?: number
    distinct?: CompanyInvoiceScalarFieldEnum | CompanyInvoiceScalarFieldEnum[]
  }

  /**
   * CompanyInvoice create
   */
  export type CompanyInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyInvoice.
     */
    data: XOR<CompanyInvoiceCreateInput, CompanyInvoiceUncheckedCreateInput>
  }

  /**
   * CompanyInvoice createMany
   */
  export type CompanyInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyInvoices.
     */
    data: CompanyInvoiceCreateManyInput | CompanyInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyInvoice createManyAndReturn
   */
  export type CompanyInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyInvoices.
     */
    data: CompanyInvoiceCreateManyInput | CompanyInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyInvoice update
   */
  export type CompanyInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyInvoice.
     */
    data: XOR<CompanyInvoiceUpdateInput, CompanyInvoiceUncheckedUpdateInput>
    /**
     * Choose, which CompanyInvoice to update.
     */
    where: CompanyInvoiceWhereUniqueInput
  }

  /**
   * CompanyInvoice updateMany
   */
  export type CompanyInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyInvoices.
     */
    data: XOR<CompanyInvoiceUpdateManyMutationInput, CompanyInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which CompanyInvoices to update
     */
    where?: CompanyInvoiceWhereInput
  }

  /**
   * CompanyInvoice upsert
   */
  export type CompanyInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyInvoice to update in case it exists.
     */
    where: CompanyInvoiceWhereUniqueInput
    /**
     * In case the CompanyInvoice found by the `where` argument doesn't exist, create a new CompanyInvoice with this data.
     */
    create: XOR<CompanyInvoiceCreateInput, CompanyInvoiceUncheckedCreateInput>
    /**
     * In case the CompanyInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyInvoiceUpdateInput, CompanyInvoiceUncheckedUpdateInput>
  }

  /**
   * CompanyInvoice delete
   */
  export type CompanyInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
    /**
     * Filter which CompanyInvoice to delete.
     */
    where: CompanyInvoiceWhereUniqueInput
  }

  /**
   * CompanyInvoice deleteMany
   */
  export type CompanyInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvoices to delete
     */
    where?: CompanyInvoiceWhereInput
  }

  /**
   * CompanyInvoice.items
   */
  export type CompanyInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    where?: CompanyInvoiceItemWhereInput
    orderBy?: CompanyInvoiceItemOrderByWithRelationInput | CompanyInvoiceItemOrderByWithRelationInput[]
    cursor?: CompanyInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyInvoiceItemScalarFieldEnum | CompanyInvoiceItemScalarFieldEnum[]
  }

  /**
   * CompanyInvoice without action
   */
  export type CompanyInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoice
     */
    select?: CompanyInvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model CompanyInvoiceItem
   */

  export type AggregateCompanyInvoiceItem = {
    _count: CompanyInvoiceItemCountAggregateOutputType | null
    _avg: CompanyInvoiceItemAvgAggregateOutputType | null
    _sum: CompanyInvoiceItemSumAggregateOutputType | null
    _min: CompanyInvoiceItemMinAggregateOutputType | null
    _max: CompanyInvoiceItemMaxAggregateOutputType | null
  }

  export type CompanyInvoiceItemAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CompanyInvoiceItemSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CompanyInvoiceItemMinAggregateOutputType = {
    id: string | null
    companyInvoiceId: string | null
    orderId: string | null
    orderNumber: string | null
    orderDate: Date | null
    employeeName: string | null
    amount: Decimal | null
  }

  export type CompanyInvoiceItemMaxAggregateOutputType = {
    id: string | null
    companyInvoiceId: string | null
    orderId: string | null
    orderNumber: string | null
    orderDate: Date | null
    employeeName: string | null
    amount: Decimal | null
  }

  export type CompanyInvoiceItemCountAggregateOutputType = {
    id: number
    companyInvoiceId: number
    orderId: number
    orderNumber: number
    orderDate: number
    employeeName: number
    amount: number
    _all: number
  }


  export type CompanyInvoiceItemAvgAggregateInputType = {
    amount?: true
  }

  export type CompanyInvoiceItemSumAggregateInputType = {
    amount?: true
  }

  export type CompanyInvoiceItemMinAggregateInputType = {
    id?: true
    companyInvoiceId?: true
    orderId?: true
    orderNumber?: true
    orderDate?: true
    employeeName?: true
    amount?: true
  }

  export type CompanyInvoiceItemMaxAggregateInputType = {
    id?: true
    companyInvoiceId?: true
    orderId?: true
    orderNumber?: true
    orderDate?: true
    employeeName?: true
    amount?: true
  }

  export type CompanyInvoiceItemCountAggregateInputType = {
    id?: true
    companyInvoiceId?: true
    orderId?: true
    orderNumber?: true
    orderDate?: true
    employeeName?: true
    amount?: true
    _all?: true
  }

  export type CompanyInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvoiceItem to aggregate.
     */
    where?: CompanyInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoiceItems to fetch.
     */
    orderBy?: CompanyInvoiceItemOrderByWithRelationInput | CompanyInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyInvoiceItems
    **/
    _count?: true | CompanyInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyInvoiceItemMaxAggregateInputType
  }

  export type GetCompanyInvoiceItemAggregateType<T extends CompanyInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyInvoiceItem[P]>
      : GetScalarType<T[P], AggregateCompanyInvoiceItem[P]>
  }




  export type CompanyInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyInvoiceItemWhereInput
    orderBy?: CompanyInvoiceItemOrderByWithAggregationInput | CompanyInvoiceItemOrderByWithAggregationInput[]
    by: CompanyInvoiceItemScalarFieldEnum[] | CompanyInvoiceItemScalarFieldEnum
    having?: CompanyInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyInvoiceItemCountAggregateInputType | true
    _avg?: CompanyInvoiceItemAvgAggregateInputType
    _sum?: CompanyInvoiceItemSumAggregateInputType
    _min?: CompanyInvoiceItemMinAggregateInputType
    _max?: CompanyInvoiceItemMaxAggregateInputType
  }

  export type CompanyInvoiceItemGroupByOutputType = {
    id: string
    companyInvoiceId: string
    orderId: string
    orderNumber: string
    orderDate: Date
    employeeName: string
    amount: Decimal
    _count: CompanyInvoiceItemCountAggregateOutputType | null
    _avg: CompanyInvoiceItemAvgAggregateOutputType | null
    _sum: CompanyInvoiceItemSumAggregateOutputType | null
    _min: CompanyInvoiceItemMinAggregateOutputType | null
    _max: CompanyInvoiceItemMaxAggregateOutputType | null
  }

  type GetCompanyInvoiceItemGroupByPayload<T extends CompanyInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type CompanyInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyInvoiceId?: boolean
    orderId?: boolean
    orderNumber?: boolean
    orderDate?: boolean
    employeeName?: boolean
    amount?: boolean
    companyInvoice?: boolean | CompanyInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvoiceItem"]>

  export type CompanyInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyInvoiceId?: boolean
    orderId?: boolean
    orderNumber?: boolean
    orderDate?: boolean
    employeeName?: boolean
    amount?: boolean
    companyInvoice?: boolean | CompanyInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyInvoiceItem"]>

  export type CompanyInvoiceItemSelectScalar = {
    id?: boolean
    companyInvoiceId?: boolean
    orderId?: boolean
    orderNumber?: boolean
    orderDate?: boolean
    employeeName?: boolean
    amount?: boolean
  }

  export type CompanyInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyInvoice?: boolean | CompanyInvoiceDefaultArgs<ExtArgs>
  }
  export type CompanyInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyInvoice?: boolean | CompanyInvoiceDefaultArgs<ExtArgs>
  }

  export type $CompanyInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyInvoiceItem"
    objects: {
      companyInvoice: Prisma.$CompanyInvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyInvoiceId: string
      orderId: string
      orderNumber: string
      orderDate: Date
      employeeName: string
      amount: Prisma.Decimal
    }, ExtArgs["result"]["companyInvoiceItem"]>
    composites: {}
  }

  type CompanyInvoiceItemGetPayload<S extends boolean | null | undefined | CompanyInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$CompanyInvoiceItemPayload, S>

  type CompanyInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyInvoiceItemCountAggregateInputType | true
    }

  export interface CompanyInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyInvoiceItem'], meta: { name: 'CompanyInvoiceItem' } }
    /**
     * Find zero or one CompanyInvoiceItem that matches the filter.
     * @param {CompanyInvoiceItemFindUniqueArgs} args - Arguments to find a CompanyInvoiceItem
     * @example
     * // Get one CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyInvoiceItemFindUniqueArgs>(args: SelectSubset<T, CompanyInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyInvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a CompanyInvoiceItem
     * @example
     * // Get one CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemFindFirstArgs} args - Arguments to find a CompanyInvoiceItem
     * @example
     * // Get one CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyInvoiceItemFindFirstArgs>(args?: SelectSubset<T, CompanyInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a CompanyInvoiceItem
     * @example
     * // Get one CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyInvoiceItems
     * const companyInvoiceItems = await prisma.companyInvoiceItem.findMany()
     * 
     * // Get first 10 CompanyInvoiceItems
     * const companyInvoiceItems = await prisma.companyInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyInvoiceItemWithIdOnly = await prisma.companyInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyInvoiceItemFindManyArgs>(args?: SelectSubset<T, CompanyInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyInvoiceItem.
     * @param {CompanyInvoiceItemCreateArgs} args - Arguments to create a CompanyInvoiceItem.
     * @example
     * // Create one CompanyInvoiceItem
     * const CompanyInvoiceItem = await prisma.companyInvoiceItem.create({
     *   data: {
     *     // ... data to create a CompanyInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends CompanyInvoiceItemCreateArgs>(args: SelectSubset<T, CompanyInvoiceItemCreateArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyInvoiceItems.
     * @param {CompanyInvoiceItemCreateManyArgs} args - Arguments to create many CompanyInvoiceItems.
     * @example
     * // Create many CompanyInvoiceItems
     * const companyInvoiceItem = await prisma.companyInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyInvoiceItemCreateManyArgs>(args?: SelectSubset<T, CompanyInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyInvoiceItems and returns the data saved in the database.
     * @param {CompanyInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many CompanyInvoiceItems.
     * @example
     * // Create many CompanyInvoiceItems
     * const companyInvoiceItem = await prisma.companyInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyInvoiceItems and only return the `id`
     * const companyInvoiceItemWithIdOnly = await prisma.companyInvoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyInvoiceItem.
     * @param {CompanyInvoiceItemDeleteArgs} args - Arguments to delete one CompanyInvoiceItem.
     * @example
     * // Delete one CompanyInvoiceItem
     * const CompanyInvoiceItem = await prisma.companyInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one CompanyInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends CompanyInvoiceItemDeleteArgs>(args: SelectSubset<T, CompanyInvoiceItemDeleteArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyInvoiceItem.
     * @param {CompanyInvoiceItemUpdateArgs} args - Arguments to update one CompanyInvoiceItem.
     * @example
     * // Update one CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyInvoiceItemUpdateArgs>(args: SelectSubset<T, CompanyInvoiceItemUpdateArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyInvoiceItems.
     * @param {CompanyInvoiceItemDeleteManyArgs} args - Arguments to filter CompanyInvoiceItems to delete.
     * @example
     * // Delete a few CompanyInvoiceItems
     * const { count } = await prisma.companyInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, CompanyInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyInvoiceItems
     * const companyInvoiceItem = await prisma.companyInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyInvoiceItemUpdateManyArgs>(args: SelectSubset<T, CompanyInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyInvoiceItem.
     * @param {CompanyInvoiceItemUpsertArgs} args - Arguments to update or create a CompanyInvoiceItem.
     * @example
     * // Update or create a CompanyInvoiceItem
     * const companyInvoiceItem = await prisma.companyInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a CompanyInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends CompanyInvoiceItemUpsertArgs>(args: SelectSubset<T, CompanyInvoiceItemUpsertArgs<ExtArgs>>): Prisma__CompanyInvoiceItemClient<$Result.GetResult<Prisma.$CompanyInvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemCountArgs} args - Arguments to filter CompanyInvoiceItems to count.
     * @example
     * // Count the number of CompanyInvoiceItems
     * const count = await prisma.companyInvoiceItem.count({
     *   where: {
     *     // ... the filter for the CompanyInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends CompanyInvoiceItemCountArgs>(
      args?: Subset<T, CompanyInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyInvoiceItemAggregateArgs>(args: Subset<T, CompanyInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetCompanyInvoiceItemAggregateType<T>>

    /**
     * Group by CompanyInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: CompanyInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyInvoiceItem model
   */
  readonly fields: CompanyInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyInvoice<T extends CompanyInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyInvoiceDefaultArgs<ExtArgs>>): Prisma__CompanyInvoiceClient<$Result.GetResult<Prisma.$CompanyInvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyInvoiceItem model
   */ 
  interface CompanyInvoiceItemFieldRefs {
    readonly id: FieldRef<"CompanyInvoiceItem", 'String'>
    readonly companyInvoiceId: FieldRef<"CompanyInvoiceItem", 'String'>
    readonly orderId: FieldRef<"CompanyInvoiceItem", 'String'>
    readonly orderNumber: FieldRef<"CompanyInvoiceItem", 'String'>
    readonly orderDate: FieldRef<"CompanyInvoiceItem", 'DateTime'>
    readonly employeeName: FieldRef<"CompanyInvoiceItem", 'String'>
    readonly amount: FieldRef<"CompanyInvoiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CompanyInvoiceItem findUnique
   */
  export type CompanyInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoiceItem to fetch.
     */
    where: CompanyInvoiceItemWhereUniqueInput
  }

  /**
   * CompanyInvoiceItem findUniqueOrThrow
   */
  export type CompanyInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoiceItem to fetch.
     */
    where: CompanyInvoiceItemWhereUniqueInput
  }

  /**
   * CompanyInvoiceItem findFirst
   */
  export type CompanyInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoiceItem to fetch.
     */
    where?: CompanyInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoiceItems to fetch.
     */
    orderBy?: CompanyInvoiceItemOrderByWithRelationInput | CompanyInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvoiceItems.
     */
    cursor?: CompanyInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvoiceItems.
     */
    distinct?: CompanyInvoiceItemScalarFieldEnum | CompanyInvoiceItemScalarFieldEnum[]
  }

  /**
   * CompanyInvoiceItem findFirstOrThrow
   */
  export type CompanyInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoiceItem to fetch.
     */
    where?: CompanyInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoiceItems to fetch.
     */
    orderBy?: CompanyInvoiceItemOrderByWithRelationInput | CompanyInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyInvoiceItems.
     */
    cursor?: CompanyInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyInvoiceItems.
     */
    distinct?: CompanyInvoiceItemScalarFieldEnum | CompanyInvoiceItemScalarFieldEnum[]
  }

  /**
   * CompanyInvoiceItem findMany
   */
  export type CompanyInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which CompanyInvoiceItems to fetch.
     */
    where?: CompanyInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyInvoiceItems to fetch.
     */
    orderBy?: CompanyInvoiceItemOrderByWithRelationInput | CompanyInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyInvoiceItems.
     */
    cursor?: CompanyInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyInvoiceItems.
     */
    skip?: number
    distinct?: CompanyInvoiceItemScalarFieldEnum | CompanyInvoiceItemScalarFieldEnum[]
  }

  /**
   * CompanyInvoiceItem create
   */
  export type CompanyInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyInvoiceItem.
     */
    data: XOR<CompanyInvoiceItemCreateInput, CompanyInvoiceItemUncheckedCreateInput>
  }

  /**
   * CompanyInvoiceItem createMany
   */
  export type CompanyInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyInvoiceItems.
     */
    data: CompanyInvoiceItemCreateManyInput | CompanyInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyInvoiceItem createManyAndReturn
   */
  export type CompanyInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyInvoiceItems.
     */
    data: CompanyInvoiceItemCreateManyInput | CompanyInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyInvoiceItem update
   */
  export type CompanyInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyInvoiceItem.
     */
    data: XOR<CompanyInvoiceItemUpdateInput, CompanyInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which CompanyInvoiceItem to update.
     */
    where: CompanyInvoiceItemWhereUniqueInput
  }

  /**
   * CompanyInvoiceItem updateMany
   */
  export type CompanyInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyInvoiceItems.
     */
    data: XOR<CompanyInvoiceItemUpdateManyMutationInput, CompanyInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which CompanyInvoiceItems to update
     */
    where?: CompanyInvoiceItemWhereInput
  }

  /**
   * CompanyInvoiceItem upsert
   */
  export type CompanyInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyInvoiceItem to update in case it exists.
     */
    where: CompanyInvoiceItemWhereUniqueInput
    /**
     * In case the CompanyInvoiceItem found by the `where` argument doesn't exist, create a new CompanyInvoiceItem with this data.
     */
    create: XOR<CompanyInvoiceItemCreateInput, CompanyInvoiceItemUncheckedCreateInput>
    /**
     * In case the CompanyInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyInvoiceItemUpdateInput, CompanyInvoiceItemUncheckedUpdateInput>
  }

  /**
   * CompanyInvoiceItem delete
   */
  export type CompanyInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which CompanyInvoiceItem to delete.
     */
    where: CompanyInvoiceItemWhereUniqueInput
  }

  /**
   * CompanyInvoiceItem deleteMany
   */
  export type CompanyInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyInvoiceItems to delete
     */
    where?: CompanyInvoiceItemWhereInput
  }

  /**
   * CompanyInvoiceItem without action
   */
  export type CompanyInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyInvoiceItem
     */
    select?: CompanyInvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model CompanyEmployee
   */

  export type AggregateCompanyEmployee = {
    _count: CompanyEmployeeCountAggregateOutputType | null
    _min: CompanyEmployeeMinAggregateOutputType | null
    _max: CompanyEmployeeMaxAggregateOutputType | null
  }

  export type CompanyEmployeeMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    employeeNumber: string | null
    department: string | null
    isActive: boolean | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type CompanyEmployeeMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    userId: string | null
    employeeNumber: string | null
    department: string | null
    isActive: boolean | null
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date | null
  }

  export type CompanyEmployeeCountAggregateOutputType = {
    id: number
    companyId: number
    userId: number
    employeeNumber: number
    department: number
    isActive: number
    validFrom: number
    validUntil: number
    createdAt: number
    _all: number
  }


  export type CompanyEmployeeMinAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    employeeNumber?: true
    department?: true
    isActive?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type CompanyEmployeeMaxAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    employeeNumber?: true
    department?: true
    isActive?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
  }

  export type CompanyEmployeeCountAggregateInputType = {
    id?: true
    companyId?: true
    userId?: true
    employeeNumber?: true
    department?: true
    isActive?: true
    validFrom?: true
    validUntil?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEmployee to aggregate.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyEmployees
    **/
    _count?: true | CompanyEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyEmployeeMaxAggregateInputType
  }

  export type GetCompanyEmployeeAggregateType<T extends CompanyEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyEmployee[P]>
      : GetScalarType<T[P], AggregateCompanyEmployee[P]>
  }




  export type CompanyEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyEmployeeWhereInput
    orderBy?: CompanyEmployeeOrderByWithAggregationInput | CompanyEmployeeOrderByWithAggregationInput[]
    by: CompanyEmployeeScalarFieldEnum[] | CompanyEmployeeScalarFieldEnum
    having?: CompanyEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyEmployeeCountAggregateInputType | true
    _min?: CompanyEmployeeMinAggregateInputType
    _max?: CompanyEmployeeMaxAggregateInputType
  }

  export type CompanyEmployeeGroupByOutputType = {
    id: string
    companyId: string
    userId: string
    employeeNumber: string | null
    department: string | null
    isActive: boolean
    validFrom: Date | null
    validUntil: Date | null
    createdAt: Date
    _count: CompanyEmployeeCountAggregateOutputType | null
    _min: CompanyEmployeeMinAggregateOutputType | null
    _max: CompanyEmployeeMaxAggregateOutputType | null
  }

  type GetCompanyEmployeeGroupByPayload<T extends CompanyEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type CompanyEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    employeeNumber?: boolean
    department?: boolean
    isActive?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEmployee"]>

  export type CompanyEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    userId?: boolean
    employeeNumber?: boolean
    department?: boolean
    isActive?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyEmployee"]>

  export type CompanyEmployeeSelectScalar = {
    id?: boolean
    companyId?: boolean
    userId?: boolean
    employeeNumber?: boolean
    department?: boolean
    isActive?: boolean
    validFrom?: boolean
    validUntil?: boolean
    createdAt?: boolean
  }

  export type CompanyEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CompanyEmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CompanyEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyEmployee"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      userId: string
      employeeNumber: string | null
      department: string | null
      isActive: boolean
      validFrom: Date | null
      validUntil: Date | null
      createdAt: Date
    }, ExtArgs["result"]["companyEmployee"]>
    composites: {}
  }

  type CompanyEmployeeGetPayload<S extends boolean | null | undefined | CompanyEmployeeDefaultArgs> = $Result.GetResult<Prisma.$CompanyEmployeePayload, S>

  type CompanyEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyEmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyEmployeeCountAggregateInputType | true
    }

  export interface CompanyEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyEmployee'], meta: { name: 'CompanyEmployee' } }
    /**
     * Find zero or one CompanyEmployee that matches the filter.
     * @param {CompanyEmployeeFindUniqueArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyEmployeeFindUniqueArgs>(args: SelectSubset<T, CompanyEmployeeFindUniqueArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CompanyEmployee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CompanyEmployeeFindUniqueOrThrowArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CompanyEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindFirstArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyEmployeeFindFirstArgs>(args?: SelectSubset<T, CompanyEmployeeFindFirstArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CompanyEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindFirstOrThrowArgs} args - Arguments to find a CompanyEmployee
     * @example
     * // Get one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CompanyEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyEmployees
     * const companyEmployees = await prisma.companyEmployee.findMany()
     * 
     * // Get first 10 CompanyEmployees
     * const companyEmployees = await prisma.companyEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyEmployeeWithIdOnly = await prisma.companyEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyEmployeeFindManyArgs>(args?: SelectSubset<T, CompanyEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CompanyEmployee.
     * @param {CompanyEmployeeCreateArgs} args - Arguments to create a CompanyEmployee.
     * @example
     * // Create one CompanyEmployee
     * const CompanyEmployee = await prisma.companyEmployee.create({
     *   data: {
     *     // ... data to create a CompanyEmployee
     *   }
     * })
     * 
     */
    create<T extends CompanyEmployeeCreateArgs>(args: SelectSubset<T, CompanyEmployeeCreateArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CompanyEmployees.
     * @param {CompanyEmployeeCreateManyArgs} args - Arguments to create many CompanyEmployees.
     * @example
     * // Create many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyEmployeeCreateManyArgs>(args?: SelectSubset<T, CompanyEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyEmployees and returns the data saved in the database.
     * @param {CompanyEmployeeCreateManyAndReturnArgs} args - Arguments to create many CompanyEmployees.
     * @example
     * // Create many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyEmployees and only return the `id`
     * const companyEmployeeWithIdOnly = await prisma.companyEmployee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CompanyEmployee.
     * @param {CompanyEmployeeDeleteArgs} args - Arguments to delete one CompanyEmployee.
     * @example
     * // Delete one CompanyEmployee
     * const CompanyEmployee = await prisma.companyEmployee.delete({
     *   where: {
     *     // ... filter to delete one CompanyEmployee
     *   }
     * })
     * 
     */
    delete<T extends CompanyEmployeeDeleteArgs>(args: SelectSubset<T, CompanyEmployeeDeleteArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CompanyEmployee.
     * @param {CompanyEmployeeUpdateArgs} args - Arguments to update one CompanyEmployee.
     * @example
     * // Update one CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyEmployeeUpdateArgs>(args: SelectSubset<T, CompanyEmployeeUpdateArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CompanyEmployees.
     * @param {CompanyEmployeeDeleteManyArgs} args - Arguments to filter CompanyEmployees to delete.
     * @example
     * // Delete a few CompanyEmployees
     * const { count } = await prisma.companyEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyEmployeeDeleteManyArgs>(args?: SelectSubset<T, CompanyEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyEmployees
     * const companyEmployee = await prisma.companyEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyEmployeeUpdateManyArgs>(args: SelectSubset<T, CompanyEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyEmployee.
     * @param {CompanyEmployeeUpsertArgs} args - Arguments to update or create a CompanyEmployee.
     * @example
     * // Update or create a CompanyEmployee
     * const companyEmployee = await prisma.companyEmployee.upsert({
     *   create: {
     *     // ... data to create a CompanyEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyEmployee we want to update
     *   }
     * })
     */
    upsert<T extends CompanyEmployeeUpsertArgs>(args: SelectSubset<T, CompanyEmployeeUpsertArgs<ExtArgs>>): Prisma__CompanyEmployeeClient<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CompanyEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeCountArgs} args - Arguments to filter CompanyEmployees to count.
     * @example
     * // Count the number of CompanyEmployees
     * const count = await prisma.companyEmployee.count({
     *   where: {
     *     // ... the filter for the CompanyEmployees we want to count
     *   }
     * })
    **/
    count<T extends CompanyEmployeeCountArgs>(
      args?: Subset<T, CompanyEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyEmployeeAggregateArgs>(args: Subset<T, CompanyEmployeeAggregateArgs>): Prisma.PrismaPromise<GetCompanyEmployeeAggregateType<T>>

    /**
     * Group by CompanyEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: CompanyEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyEmployee model
   */
  readonly fields: CompanyEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyEmployee model
   */ 
  interface CompanyEmployeeFieldRefs {
    readonly id: FieldRef<"CompanyEmployee", 'String'>
    readonly companyId: FieldRef<"CompanyEmployee", 'String'>
    readonly userId: FieldRef<"CompanyEmployee", 'String'>
    readonly employeeNumber: FieldRef<"CompanyEmployee", 'String'>
    readonly department: FieldRef<"CompanyEmployee", 'String'>
    readonly isActive: FieldRef<"CompanyEmployee", 'Boolean'>
    readonly validFrom: FieldRef<"CompanyEmployee", 'DateTime'>
    readonly validUntil: FieldRef<"CompanyEmployee", 'DateTime'>
    readonly createdAt: FieldRef<"CompanyEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyEmployee findUnique
   */
  export type CompanyEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee findUniqueOrThrow
   */
  export type CompanyEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee findFirst
   */
  export type CompanyEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEmployees.
     */
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee findFirstOrThrow
   */
  export type CompanyEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployee to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyEmployees.
     */
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee findMany
   */
  export type CompanyEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which CompanyEmployees to fetch.
     */
    where?: CompanyEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyEmployees to fetch.
     */
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyEmployees.
     */
    cursor?: CompanyEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyEmployees.
     */
    skip?: number
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * CompanyEmployee create
   */
  export type CompanyEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyEmployee.
     */
    data: XOR<CompanyEmployeeCreateInput, CompanyEmployeeUncheckedCreateInput>
  }

  /**
   * CompanyEmployee createMany
   */
  export type CompanyEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyEmployees.
     */
    data: CompanyEmployeeCreateManyInput | CompanyEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyEmployee createManyAndReturn
   */
  export type CompanyEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CompanyEmployees.
     */
    data: CompanyEmployeeCreateManyInput | CompanyEmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyEmployee update
   */
  export type CompanyEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyEmployee.
     */
    data: XOR<CompanyEmployeeUpdateInput, CompanyEmployeeUncheckedUpdateInput>
    /**
     * Choose, which CompanyEmployee to update.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee updateMany
   */
  export type CompanyEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyEmployees.
     */
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which CompanyEmployees to update
     */
    where?: CompanyEmployeeWhereInput
  }

  /**
   * CompanyEmployee upsert
   */
  export type CompanyEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyEmployee to update in case it exists.
     */
    where: CompanyEmployeeWhereUniqueInput
    /**
     * In case the CompanyEmployee found by the `where` argument doesn't exist, create a new CompanyEmployee with this data.
     */
    create: XOR<CompanyEmployeeCreateInput, CompanyEmployeeUncheckedCreateInput>
    /**
     * In case the CompanyEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyEmployeeUpdateInput, CompanyEmployeeUncheckedUpdateInput>
  }

  /**
   * CompanyEmployee delete
   */
  export type CompanyEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    /**
     * Filter which CompanyEmployee to delete.
     */
    where: CompanyEmployeeWhereUniqueInput
  }

  /**
   * CompanyEmployee deleteMany
   */
  export type CompanyEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyEmployees to delete
     */
    where?: CompanyEmployeeWhereInput
  }

  /**
   * CompanyEmployee without action
   */
  export type CompanyEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    workingDays: number | null
  }

  export type LocationSumAggregateOutputType = {
    workingDays: number[]
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    address: number
    phone: number
    email: number
    openingHours: number
    workingDays: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    workingDays?: true
  }

  export type LocationSumAggregateInputType = {
    workingDays?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    openingHours?: true
    workingDays?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    openingHours: JsonValue | null
    workingDays: number[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    workingDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    menus?: boolean | Location$menusArgs<ExtArgs>
    orders?: boolean | Location$ordersArgs<ExtArgs>
    users?: boolean | Location$usersArgs<ExtArgs>
    coupons?: boolean | Location$couponsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    workingDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    openingHours?: boolean
    workingDays?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    menus?: boolean | Location$menusArgs<ExtArgs>
    orders?: boolean | Location$ordersArgs<ExtArgs>
    users?: boolean | Location$usersArgs<ExtArgs>
    coupons?: boolean | Location$couponsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      menus: Prisma.$MenuPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      users: Prisma.$UserLocationPayload<ExtArgs>[]
      coupons: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      openingHours: Prisma.JsonValue | null
      workingDays: number[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    menus<T extends Location$menusArgs<ExtArgs> = {}>(args?: Subset<T, Location$menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Location$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Location$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Location$usersArgs<ExtArgs> = {}>(args?: Subset<T, Location$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findMany"> | Null>
    coupons<T extends Location$couponsArgs<ExtArgs> = {}>(args?: Subset<T, Location$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */ 
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly organizationId: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly phone: FieldRef<"Location", 'String'>
    readonly email: FieldRef<"Location", 'String'>
    readonly openingHours: FieldRef<"Location", 'Json'>
    readonly workingDays: FieldRef<"Location", 'Int[]'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
  }

  /**
   * Location.menus
   */
  export type Location$menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    cursor?: MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Location.orders
   */
  export type Location$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Location.users
   */
  export type Location$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    where?: UserLocationWhereInput
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    cursor?: UserLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * Location.coupons
   */
  export type Location$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    image: string | null
    organizationId: string | null
    marketingEmailConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    image: string | null
    organizationId: string | null
    marketingEmailConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    role: number
    image: number
    organizationId: number
    marketingEmailConsent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    image?: true
    organizationId?: true
    marketingEmailConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    image?: true
    organizationId?: true
    marketingEmailConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    image?: true
    organizationId?: true
    marketingEmailConsent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole
    image: string | null
    organizationId: string | null
    marketingEmailConsent: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    image?: boolean
    organizationId?: boolean
    marketingEmailConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    locations?: boolean | User$locationsArgs<ExtArgs>
    companyEmployees?: boolean | User$companyEmployeesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    couponRedemptions?: boolean | User$couponRedemptionsArgs<ExtArgs>
    incentiveGrants?: boolean | User$incentiveGrantsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    walletTransactions?: boolean | User$walletTransactionsArgs<ExtArgs>
    performedWalletActions?: boolean | User$performedWalletActionsArgs<ExtArgs>
    pushNotificationLogs?: boolean | User$pushNotificationLogsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    paymentConfigChanges?: boolean | User$paymentConfigChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    image?: boolean
    organizationId?: boolean
    marketingEmailConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    image?: boolean
    organizationId?: boolean
    marketingEmailConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    locations?: boolean | User$locationsArgs<ExtArgs>
    companyEmployees?: boolean | User$companyEmployeesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    couponRedemptions?: boolean | User$couponRedemptionsArgs<ExtArgs>
    incentiveGrants?: boolean | User$incentiveGrantsArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    walletTransactions?: boolean | User$walletTransactionsArgs<ExtArgs>
    performedWalletActions?: boolean | User$performedWalletActionsArgs<ExtArgs>
    pushNotificationLogs?: boolean | User$pushNotificationLogsArgs<ExtArgs>
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>
    paymentConfigChanges?: boolean | User$paymentConfigChangesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      locations: Prisma.$UserLocationPayload<ExtArgs>[]
      companyEmployees: Prisma.$CompanyEmployeePayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      couponRedemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
      incentiveGrants: Prisma.$IncentiveGrantPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      walletTransactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
      performedWalletActions: Prisma.$WalletTransactionPayload<ExtArgs>[]
      pushNotificationLogs: Prisma.$PushNotificationLogPayload<ExtArgs>[]
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[]
      paymentConfigChanges: Prisma.$PaymentProviderConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      passwordHash: string | null
      role: $Enums.UserRole
      image: string | null
      organizationId: string | null
      marketingEmailConsent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    locations<T extends User$locationsArgs<ExtArgs> = {}>(args?: Subset<T, User$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findMany"> | Null>
    companyEmployees<T extends User$companyEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, User$companyEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyEmployeePayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    couponRedemptions<T extends User$couponRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$couponRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    incentiveGrants<T extends User$incentiveGrantsArgs<ExtArgs> = {}>(args?: Subset<T, User$incentiveGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findMany"> | Null>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    walletTransactions<T extends User$walletTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$walletTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    performedWalletActions<T extends User$performedWalletActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$performedWalletActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    pushNotificationLogs<T extends User$pushNotificationLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushNotificationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    paymentConfigChanges<T extends User$paymentConfigChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentConfigChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly image: FieldRef<"User", 'String'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly marketingEmailConsent: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.locations
   */
  export type User$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    where?: UserLocationWhereInput
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    cursor?: UserLocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * User.companyEmployees
   */
  export type User$companyEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyEmployee
     */
    select?: CompanyEmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyEmployeeInclude<ExtArgs> | null
    where?: CompanyEmployeeWhereInput
    orderBy?: CompanyEmployeeOrderByWithRelationInput | CompanyEmployeeOrderByWithRelationInput[]
    cursor?: CompanyEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyEmployeeScalarFieldEnum | CompanyEmployeeScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.couponRedemptions
   */
  export type User$couponRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * User.incentiveGrants
   */
  export type User$incentiveGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    where?: IncentiveGrantWhereInput
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    cursor?: IncentiveGrantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.walletTransactions
   */
  export type User$walletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * User.performedWalletActions
   */
  export type User$performedWalletActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * User.pushNotificationLogs
   */
  export type User$pushNotificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    where?: PushNotificationLogWhereInput
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    cursor?: PushNotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushNotificationLogScalarFieldEnum | PushNotificationLogScalarFieldEnum[]
  }

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User.paymentConfigChanges
   */
  export type User$paymentConfigChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    where?: PaymentProviderConfigWhereInput
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    cursor?: PaymentProviderConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletSumAggregateOutputType = {
    balance: Decimal | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: Decimal | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    balance: Decimal | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    balance: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    balance?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    balance: Decimal
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    balance?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    balance?: boolean
    updatedAt?: boolean
  }

  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      balance: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */ 
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Decimal'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.WalletTransactionType | null
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    description: string | null
    orderId: string | null
    performedById: string | null
    incentiveGrantId: string | null
    paymentProvider: string | null
    externalPaymentId: string | null
    createdAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.WalletTransactionType | null
    amount: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    description: string | null
    orderId: string | null
    performedById: string | null
    incentiveGrantId: string | null
    paymentProvider: string | null
    externalPaymentId: string | null
    createdAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    amount: number
    balanceBefore: number
    balanceAfter: number
    description: number
    orderId: number
    performedById: number
    incentiveGrantId: number
    paymentProvider: number
    externalPaymentId: number
    createdAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    orderId?: true
    performedById?: true
    incentiveGrantId?: true
    paymentProvider?: true
    externalPaymentId?: true
    createdAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    orderId?: true
    performedById?: true
    incentiveGrantId?: true
    paymentProvider?: true
    externalPaymentId?: true
    createdAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    orderId?: true
    performedById?: true
    incentiveGrantId?: true
    paymentProvider?: true
    externalPaymentId?: true
    createdAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal
    balanceBefore: Decimal
    balanceAfter: Decimal
    description: string | null
    orderId: string | null
    performedById: string | null
    incentiveGrantId: string | null
    paymentProvider: string | null
    externalPaymentId: string | null
    createdAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    orderId?: boolean
    performedById?: boolean
    incentiveGrantId?: boolean
    paymentProvider?: boolean
    externalPaymentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
    performedBy?: boolean | WalletTransaction$performedByArgs<ExtArgs>
    incentiveGrant?: boolean | WalletTransaction$incentiveGrantArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    orderId?: boolean
    performedById?: boolean
    incentiveGrantId?: boolean
    paymentProvider?: boolean
    externalPaymentId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
    performedBy?: boolean | WalletTransaction$performedByArgs<ExtArgs>
    incentiveGrant?: boolean | WalletTransaction$incentiveGrantArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    amount?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    orderId?: boolean
    performedById?: boolean
    incentiveGrantId?: boolean
    paymentProvider?: boolean
    externalPaymentId?: boolean
    createdAt?: boolean
  }

  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
    performedBy?: boolean | WalletTransaction$performedByArgs<ExtArgs>
    incentiveGrant?: boolean | WalletTransaction$incentiveGrantArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | WalletTransaction$orderArgs<ExtArgs>
    performedBy?: boolean | WalletTransaction$performedByArgs<ExtArgs>
    incentiveGrant?: boolean | WalletTransaction$incentiveGrantArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
      performedBy: Prisma.$UserPayload<ExtArgs> | null
      incentiveGrant: Prisma.$IncentiveGrantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.WalletTransactionType
      amount: Prisma.Decimal
      balanceBefore: Prisma.Decimal
      balanceAfter: Prisma.Decimal
      description: string | null
      orderId: string | null
      performedById: string | null
      incentiveGrantId: string | null
      paymentProvider: string | null
      externalPaymentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends WalletTransaction$orderArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    performedBy<T extends WalletTransaction$performedByArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$performedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    incentiveGrant<T extends WalletTransaction$incentiveGrantArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$incentiveGrantArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */ 
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly userId: FieldRef<"WalletTransaction", 'String'>
    readonly type: FieldRef<"WalletTransaction", 'WalletTransactionType'>
    readonly amount: FieldRef<"WalletTransaction", 'Decimal'>
    readonly balanceBefore: FieldRef<"WalletTransaction", 'Decimal'>
    readonly balanceAfter: FieldRef<"WalletTransaction", 'Decimal'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly orderId: FieldRef<"WalletTransaction", 'String'>
    readonly performedById: FieldRef<"WalletTransaction", 'String'>
    readonly incentiveGrantId: FieldRef<"WalletTransaction", 'String'>
    readonly paymentProvider: FieldRef<"WalletTransaction", 'String'>
    readonly externalPaymentId: FieldRef<"WalletTransaction", 'String'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction.order
   */
  export type WalletTransaction$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * WalletTransaction.performedBy
   */
  export type WalletTransaction$performedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WalletTransaction.incentiveGrant
   */
  export type WalletTransaction$incentiveGrantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    where?: IncentiveGrantWhereInput
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model UserLocation
   */

  export type AggregateUserLocation = {
    _count: UserLocationCountAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  export type UserLocationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    createdAt: Date | null
  }

  export type UserLocationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    createdAt: Date | null
  }

  export type UserLocationCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    createdAt: number
    _all: number
  }


  export type UserLocationMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    createdAt?: true
  }

  export type UserLocationMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    createdAt?: true
  }

  export type UserLocationCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    createdAt?: true
    _all?: true
  }

  export type UserLocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLocation to aggregate.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLocations
    **/
    _count?: true | UserLocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLocationMaxAggregateInputType
  }

  export type GetUserLocationAggregateType<T extends UserLocationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLocation[P]>
      : GetScalarType<T[P], AggregateUserLocation[P]>
  }




  export type UserLocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLocationWhereInput
    orderBy?: UserLocationOrderByWithAggregationInput | UserLocationOrderByWithAggregationInput[]
    by: UserLocationScalarFieldEnum[] | UserLocationScalarFieldEnum
    having?: UserLocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLocationCountAggregateInputType | true
    _min?: UserLocationMinAggregateInputType
    _max?: UserLocationMaxAggregateInputType
  }

  export type UserLocationGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    createdAt: Date
    _count: UserLocationCountAggregateOutputType | null
    _min: UserLocationMinAggregateOutputType | null
    _max: UserLocationMaxAggregateOutputType | null
  }

  type GetUserLocationGroupByPayload<T extends UserLocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
            : GetScalarType<T[P], UserLocationGroupByOutputType[P]>
        }
      >
    >


  export type UserLocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLocation"]>

  export type UserLocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userLocation"]>

  export type UserLocationSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    createdAt?: boolean
  }

  export type UserLocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type UserLocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $UserLocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLocation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      createdAt: Date
    }, ExtArgs["result"]["userLocation"]>
    composites: {}
  }

  type UserLocationGetPayload<S extends boolean | null | undefined | UserLocationDefaultArgs> = $Result.GetResult<Prisma.$UserLocationPayload, S>

  type UserLocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserLocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserLocationCountAggregateInputType | true
    }

  export interface UserLocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLocation'], meta: { name: 'UserLocation' } }
    /**
     * Find zero or one UserLocation that matches the filter.
     * @param {UserLocationFindUniqueArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLocationFindUniqueArgs>(args: SelectSubset<T, UserLocationFindUniqueArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserLocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserLocationFindUniqueOrThrowArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLocationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserLocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindFirstArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLocationFindFirstArgs>(args?: SelectSubset<T, UserLocationFindFirstArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserLocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindFirstOrThrowArgs} args - Arguments to find a UserLocation
     * @example
     * // Get one UserLocation
     * const userLocation = await prisma.userLocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLocationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserLocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLocations
     * const userLocations = await prisma.userLocation.findMany()
     * 
     * // Get first 10 UserLocations
     * const userLocations = await prisma.userLocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLocationWithIdOnly = await prisma.userLocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLocationFindManyArgs>(args?: SelectSubset<T, UserLocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserLocation.
     * @param {UserLocationCreateArgs} args - Arguments to create a UserLocation.
     * @example
     * // Create one UserLocation
     * const UserLocation = await prisma.userLocation.create({
     *   data: {
     *     // ... data to create a UserLocation
     *   }
     * })
     * 
     */
    create<T extends UserLocationCreateArgs>(args: SelectSubset<T, UserLocationCreateArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserLocations.
     * @param {UserLocationCreateManyArgs} args - Arguments to create many UserLocations.
     * @example
     * // Create many UserLocations
     * const userLocation = await prisma.userLocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLocationCreateManyArgs>(args?: SelectSubset<T, UserLocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLocations and returns the data saved in the database.
     * @param {UserLocationCreateManyAndReturnArgs} args - Arguments to create many UserLocations.
     * @example
     * // Create many UserLocations
     * const userLocation = await prisma.userLocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLocations and only return the `id`
     * const userLocationWithIdOnly = await prisma.userLocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLocationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserLocation.
     * @param {UserLocationDeleteArgs} args - Arguments to delete one UserLocation.
     * @example
     * // Delete one UserLocation
     * const UserLocation = await prisma.userLocation.delete({
     *   where: {
     *     // ... filter to delete one UserLocation
     *   }
     * })
     * 
     */
    delete<T extends UserLocationDeleteArgs>(args: SelectSubset<T, UserLocationDeleteArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserLocation.
     * @param {UserLocationUpdateArgs} args - Arguments to update one UserLocation.
     * @example
     * // Update one UserLocation
     * const userLocation = await prisma.userLocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLocationUpdateArgs>(args: SelectSubset<T, UserLocationUpdateArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserLocations.
     * @param {UserLocationDeleteManyArgs} args - Arguments to filter UserLocations to delete.
     * @example
     * // Delete a few UserLocations
     * const { count } = await prisma.userLocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLocationDeleteManyArgs>(args?: SelectSubset<T, UserLocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLocations
     * const userLocation = await prisma.userLocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLocationUpdateManyArgs>(args: SelectSubset<T, UserLocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLocation.
     * @param {UserLocationUpsertArgs} args - Arguments to update or create a UserLocation.
     * @example
     * // Update or create a UserLocation
     * const userLocation = await prisma.userLocation.upsert({
     *   create: {
     *     // ... data to create a UserLocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLocation we want to update
     *   }
     * })
     */
    upsert<T extends UserLocationUpsertArgs>(args: SelectSubset<T, UserLocationUpsertArgs<ExtArgs>>): Prisma__UserLocationClient<$Result.GetResult<Prisma.$UserLocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserLocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationCountArgs} args - Arguments to filter UserLocations to count.
     * @example
     * // Count the number of UserLocations
     * const count = await prisma.userLocation.count({
     *   where: {
     *     // ... the filter for the UserLocations we want to count
     *   }
     * })
    **/
    count<T extends UserLocationCountArgs>(
      args?: Subset<T, UserLocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLocationAggregateArgs>(args: Subset<T, UserLocationAggregateArgs>): Prisma.PrismaPromise<GetUserLocationAggregateType<T>>

    /**
     * Group by UserLocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLocationGroupByArgs['orderBy'] }
        : { orderBy?: UserLocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLocation model
   */
  readonly fields: UserLocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLocation model
   */ 
  interface UserLocationFieldRefs {
    readonly id: FieldRef<"UserLocation", 'String'>
    readonly userId: FieldRef<"UserLocation", 'String'>
    readonly locationId: FieldRef<"UserLocation", 'String'>
    readonly createdAt: FieldRef<"UserLocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserLocation findUnique
   */
  export type UserLocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation findUniqueOrThrow
   */
  export type UserLocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation findFirst
   */
  export type UserLocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLocations.
     */
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation findFirstOrThrow
   */
  export type UserLocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocation to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLocations.
     */
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation findMany
   */
  export type UserLocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter, which UserLocations to fetch.
     */
    where?: UserLocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLocations to fetch.
     */
    orderBy?: UserLocationOrderByWithRelationInput | UserLocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLocations.
     */
    cursor?: UserLocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLocations.
     */
    skip?: number
    distinct?: UserLocationScalarFieldEnum | UserLocationScalarFieldEnum[]
  }

  /**
   * UserLocation create
   */
  export type UserLocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLocation.
     */
    data: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
  }

  /**
   * UserLocation createMany
   */
  export type UserLocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLocations.
     */
    data: UserLocationCreateManyInput | UserLocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLocation createManyAndReturn
   */
  export type UserLocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserLocations.
     */
    data: UserLocationCreateManyInput | UserLocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLocation update
   */
  export type UserLocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLocation.
     */
    data: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
    /**
     * Choose, which UserLocation to update.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation updateMany
   */
  export type UserLocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLocations.
     */
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyInput>
    /**
     * Filter which UserLocations to update
     */
    where?: UserLocationWhereInput
  }

  /**
   * UserLocation upsert
   */
  export type UserLocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLocation to update in case it exists.
     */
    where: UserLocationWhereUniqueInput
    /**
     * In case the UserLocation found by the `where` argument doesn't exist, create a new UserLocation with this data.
     */
    create: XOR<UserLocationCreateInput, UserLocationUncheckedCreateInput>
    /**
     * In case the UserLocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLocationUpdateInput, UserLocationUncheckedUpdateInput>
  }

  /**
   * UserLocation delete
   */
  export type UserLocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
    /**
     * Filter which UserLocation to delete.
     */
    where: UserLocationWhereUniqueInput
  }

  /**
   * UserLocation deleteMany
   */
  export type UserLocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLocations to delete
     */
    where?: UserLocationWhereInput
  }

  /**
   * UserLocation without action
   */
  export type UserLocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLocation
     */
    select?: UserLocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLocationInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuAvgAggregateOutputType = {
    weekNumber: number | null
    year: number | null
  }

  export type MenuSumAggregateOutputType = {
    weekNumber: number | null
    year: number | null
  }

  export type MenuMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    weekNumber: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    weekNumber: number | null
    year: number | null
    startDate: Date | null
    endDate: Date | null
    isPublished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    locationId: number
    weekNumber: number
    year: number
    startDate: number
    endDate: number
    isPublished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuAvgAggregateInputType = {
    weekNumber?: true
    year?: true
  }

  export type MenuSumAggregateInputType = {
    weekNumber?: true
    year?: true
  }

  export type MenuMinAggregateInputType = {
    id?: true
    locationId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    locationId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    locationId?: true
    weekNumber?: true
    year?: true
    startDate?: true
    endDate?: true
    isPublished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _avg?: MenuAvgAggregateInputType
    _sum?: MenuSumAggregateInputType
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: string
    locationId: string
    weekNumber: number
    year: number
    startDate: Date
    endDate: Date
    isPublished: boolean
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _avg: MenuAvgAggregateOutputType | null
    _sum: MenuSumAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    menuItems?: boolean | Menu$menuItemsArgs<ExtArgs>
    promotionBanners?: boolean | Menu$promotionBannersArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    locationId?: boolean
    weekNumber?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isPublished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    menuItems?: boolean | Menu$menuItemsArgs<ExtArgs>
    promotionBanners?: boolean | Menu$promotionBannersArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
      promotionBanners: Prisma.$MenuPromotionBannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      weekNumber: number
      year: number
      startDate: Date
      endDate: Date
      isPublished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    menuItems<T extends Menu$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, Menu$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany"> | Null>
    promotionBanners<T extends Menu$promotionBannersArgs<ExtArgs> = {}>(args?: Subset<T, Menu$promotionBannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */ 
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'String'>
    readonly locationId: FieldRef<"Menu", 'String'>
    readonly weekNumber: FieldRef<"Menu", 'Int'>
    readonly year: FieldRef<"Menu", 'Int'>
    readonly startDate: FieldRef<"Menu", 'DateTime'>
    readonly endDate: FieldRef<"Menu", 'DateTime'>
    readonly isPublished: FieldRef<"Menu", 'Boolean'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
  }

  /**
   * Menu.menuItems
   */
  export type Menu$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Menu.promotionBanners
   */
  export type Menu$promotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    where?: MenuPromotionBannerWhereInput
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    cursor?: MenuPromotionBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuPromotionBannerScalarFieldEnum | MenuPromotionBannerScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model PromotionBanner
   */

  export type AggregatePromotionBanner = {
    _count: PromotionBannerCountAggregateOutputType | null
    _min: PromotionBannerMinAggregateOutputType | null
    _max: PromotionBannerMaxAggregateOutputType | null
  }

  export type PromotionBannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    imageUrl: string | null
    couponId: string | null
    isActive: boolean | null
    marketingTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionBannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    subtitle: string | null
    imageUrl: string | null
    couponId: string | null
    isActive: boolean | null
    marketingTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionBannerCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    imageUrl: number
    couponId: number
    isActive: number
    marketingTemplateId: number
    templateSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionBannerMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    imageUrl?: true
    couponId?: true
    isActive?: true
    marketingTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionBannerMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    imageUrl?: true
    couponId?: true
    isActive?: true
    marketingTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionBannerCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    imageUrl?: true
    couponId?: true
    isActive?: true
    marketingTemplateId?: true
    templateSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionBanner to aggregate.
     */
    where?: PromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionBanners to fetch.
     */
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionBanners
    **/
    _count?: true | PromotionBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionBannerMaxAggregateInputType
  }

  export type GetPromotionBannerAggregateType<T extends PromotionBannerAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionBanner[P]>
      : GetScalarType<T[P], AggregatePromotionBanner[P]>
  }




  export type PromotionBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionBannerWhereInput
    orderBy?: PromotionBannerOrderByWithAggregationInput | PromotionBannerOrderByWithAggregationInput[]
    by: PromotionBannerScalarFieldEnum[] | PromotionBannerScalarFieldEnum
    having?: PromotionBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionBannerCountAggregateInputType | true
    _min?: PromotionBannerMinAggregateInputType
    _max?: PromotionBannerMaxAggregateInputType
  }

  export type PromotionBannerGroupByOutputType = {
    id: string
    title: string
    subtitle: string | null
    imageUrl: string | null
    couponId: string | null
    isActive: boolean
    marketingTemplateId: string | null
    templateSnapshot: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PromotionBannerCountAggregateOutputType | null
    _min: PromotionBannerMinAggregateOutputType | null
    _max: PromotionBannerMaxAggregateOutputType | null
  }

  type GetPromotionBannerGroupByPayload<T extends PromotionBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionBannerGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionBannerGroupByOutputType[P]>
        }
      >
    >


  export type PromotionBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    imageUrl?: boolean
    couponId?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coupon?: boolean | PromotionBanner$couponArgs<ExtArgs>
    marketingTemplate?: boolean | PromotionBanner$marketingTemplateArgs<ExtArgs>
    menuAssignments?: boolean | PromotionBanner$menuAssignmentsArgs<ExtArgs>
    _count?: boolean | PromotionBannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionBanner"]>

  export type PromotionBannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    imageUrl?: boolean
    couponId?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    coupon?: boolean | PromotionBanner$couponArgs<ExtArgs>
    marketingTemplate?: boolean | PromotionBanner$marketingTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["promotionBanner"]>

  export type PromotionBannerSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    imageUrl?: boolean
    couponId?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionBannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | PromotionBanner$couponArgs<ExtArgs>
    marketingTemplate?: boolean | PromotionBanner$marketingTemplateArgs<ExtArgs>
    menuAssignments?: boolean | PromotionBanner$menuAssignmentsArgs<ExtArgs>
    _count?: boolean | PromotionBannerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionBannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | PromotionBanner$couponArgs<ExtArgs>
    marketingTemplate?: boolean | PromotionBanner$marketingTemplateArgs<ExtArgs>
  }

  export type $PromotionBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionBanner"
    objects: {
      coupon: Prisma.$CouponPayload<ExtArgs> | null
      marketingTemplate: Prisma.$MarketingTemplatePayload<ExtArgs> | null
      menuAssignments: Prisma.$MenuPromotionBannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      subtitle: string | null
      imageUrl: string | null
      couponId: string | null
      isActive: boolean
      marketingTemplateId: string | null
      templateSnapshot: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotionBanner"]>
    composites: {}
  }

  type PromotionBannerGetPayload<S extends boolean | null | undefined | PromotionBannerDefaultArgs> = $Result.GetResult<Prisma.$PromotionBannerPayload, S>

  type PromotionBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionBannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionBannerCountAggregateInputType | true
    }

  export interface PromotionBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionBanner'], meta: { name: 'PromotionBanner' } }
    /**
     * Find zero or one PromotionBanner that matches the filter.
     * @param {PromotionBannerFindUniqueArgs} args - Arguments to find a PromotionBanner
     * @example
     * // Get one PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionBannerFindUniqueArgs>(args: SelectSubset<T, PromotionBannerFindUniqueArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromotionBanner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionBannerFindUniqueOrThrowArgs} args - Arguments to find a PromotionBanner
     * @example
     * // Get one PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromotionBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerFindFirstArgs} args - Arguments to find a PromotionBanner
     * @example
     * // Get one PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionBannerFindFirstArgs>(args?: SelectSubset<T, PromotionBannerFindFirstArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromotionBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerFindFirstOrThrowArgs} args - Arguments to find a PromotionBanner
     * @example
     * // Get one PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromotionBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionBanners
     * const promotionBanners = await prisma.promotionBanner.findMany()
     * 
     * // Get first 10 PromotionBanners
     * const promotionBanners = await prisma.promotionBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionBannerWithIdOnly = await prisma.promotionBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionBannerFindManyArgs>(args?: SelectSubset<T, PromotionBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromotionBanner.
     * @param {PromotionBannerCreateArgs} args - Arguments to create a PromotionBanner.
     * @example
     * // Create one PromotionBanner
     * const PromotionBanner = await prisma.promotionBanner.create({
     *   data: {
     *     // ... data to create a PromotionBanner
     *   }
     * })
     * 
     */
    create<T extends PromotionBannerCreateArgs>(args: SelectSubset<T, PromotionBannerCreateArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromotionBanners.
     * @param {PromotionBannerCreateManyArgs} args - Arguments to create many PromotionBanners.
     * @example
     * // Create many PromotionBanners
     * const promotionBanner = await prisma.promotionBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionBannerCreateManyArgs>(args?: SelectSubset<T, PromotionBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionBanners and returns the data saved in the database.
     * @param {PromotionBannerCreateManyAndReturnArgs} args - Arguments to create many PromotionBanners.
     * @example
     * // Create many PromotionBanners
     * const promotionBanner = await prisma.promotionBanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionBanners and only return the `id`
     * const promotionBannerWithIdOnly = await prisma.promotionBanner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionBannerCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionBannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromotionBanner.
     * @param {PromotionBannerDeleteArgs} args - Arguments to delete one PromotionBanner.
     * @example
     * // Delete one PromotionBanner
     * const PromotionBanner = await prisma.promotionBanner.delete({
     *   where: {
     *     // ... filter to delete one PromotionBanner
     *   }
     * })
     * 
     */
    delete<T extends PromotionBannerDeleteArgs>(args: SelectSubset<T, PromotionBannerDeleteArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromotionBanner.
     * @param {PromotionBannerUpdateArgs} args - Arguments to update one PromotionBanner.
     * @example
     * // Update one PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionBannerUpdateArgs>(args: SelectSubset<T, PromotionBannerUpdateArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromotionBanners.
     * @param {PromotionBannerDeleteManyArgs} args - Arguments to filter PromotionBanners to delete.
     * @example
     * // Delete a few PromotionBanners
     * const { count } = await prisma.promotionBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionBannerDeleteManyArgs>(args?: SelectSubset<T, PromotionBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionBanners
     * const promotionBanner = await prisma.promotionBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionBannerUpdateManyArgs>(args: SelectSubset<T, PromotionBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromotionBanner.
     * @param {PromotionBannerUpsertArgs} args - Arguments to update or create a PromotionBanner.
     * @example
     * // Update or create a PromotionBanner
     * const promotionBanner = await prisma.promotionBanner.upsert({
     *   create: {
     *     // ... data to create a PromotionBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionBanner we want to update
     *   }
     * })
     */
    upsert<T extends PromotionBannerUpsertArgs>(args: SelectSubset<T, PromotionBannerUpsertArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromotionBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerCountArgs} args - Arguments to filter PromotionBanners to count.
     * @example
     * // Count the number of PromotionBanners
     * const count = await prisma.promotionBanner.count({
     *   where: {
     *     // ... the filter for the PromotionBanners we want to count
     *   }
     * })
    **/
    count<T extends PromotionBannerCountArgs>(
      args?: Subset<T, PromotionBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionBannerAggregateArgs>(args: Subset<T, PromotionBannerAggregateArgs>): Prisma.PrismaPromise<GetPromotionBannerAggregateType<T>>

    /**
     * Group by PromotionBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionBannerGroupByArgs['orderBy'] }
        : { orderBy?: PromotionBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionBanner model
   */
  readonly fields: PromotionBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon<T extends PromotionBanner$couponArgs<ExtArgs> = {}>(args?: Subset<T, PromotionBanner$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    marketingTemplate<T extends PromotionBanner$marketingTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PromotionBanner$marketingTemplateArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    menuAssignments<T extends PromotionBanner$menuAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, PromotionBanner$menuAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionBanner model
   */ 
  interface PromotionBannerFieldRefs {
    readonly id: FieldRef<"PromotionBanner", 'String'>
    readonly title: FieldRef<"PromotionBanner", 'String'>
    readonly subtitle: FieldRef<"PromotionBanner", 'String'>
    readonly imageUrl: FieldRef<"PromotionBanner", 'String'>
    readonly couponId: FieldRef<"PromotionBanner", 'String'>
    readonly isActive: FieldRef<"PromotionBanner", 'Boolean'>
    readonly marketingTemplateId: FieldRef<"PromotionBanner", 'String'>
    readonly templateSnapshot: FieldRef<"PromotionBanner", 'Json'>
    readonly createdAt: FieldRef<"PromotionBanner", 'DateTime'>
    readonly updatedAt: FieldRef<"PromotionBanner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionBanner findUnique
   */
  export type PromotionBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which PromotionBanner to fetch.
     */
    where: PromotionBannerWhereUniqueInput
  }

  /**
   * PromotionBanner findUniqueOrThrow
   */
  export type PromotionBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which PromotionBanner to fetch.
     */
    where: PromotionBannerWhereUniqueInput
  }

  /**
   * PromotionBanner findFirst
   */
  export type PromotionBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which PromotionBanner to fetch.
     */
    where?: PromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionBanners to fetch.
     */
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionBanners.
     */
    cursor?: PromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionBanners.
     */
    distinct?: PromotionBannerScalarFieldEnum | PromotionBannerScalarFieldEnum[]
  }

  /**
   * PromotionBanner findFirstOrThrow
   */
  export type PromotionBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which PromotionBanner to fetch.
     */
    where?: PromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionBanners to fetch.
     */
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionBanners.
     */
    cursor?: PromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionBanners.
     */
    distinct?: PromotionBannerScalarFieldEnum | PromotionBannerScalarFieldEnum[]
  }

  /**
   * PromotionBanner findMany
   */
  export type PromotionBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which PromotionBanners to fetch.
     */
    where?: PromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionBanners to fetch.
     */
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionBanners.
     */
    cursor?: PromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionBanners.
     */
    skip?: number
    distinct?: PromotionBannerScalarFieldEnum | PromotionBannerScalarFieldEnum[]
  }

  /**
   * PromotionBanner create
   */
  export type PromotionBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionBanner.
     */
    data: XOR<PromotionBannerCreateInput, PromotionBannerUncheckedCreateInput>
  }

  /**
   * PromotionBanner createMany
   */
  export type PromotionBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionBanners.
     */
    data: PromotionBannerCreateManyInput | PromotionBannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionBanner createManyAndReturn
   */
  export type PromotionBannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromotionBanners.
     */
    data: PromotionBannerCreateManyInput | PromotionBannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionBanner update
   */
  export type PromotionBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionBanner.
     */
    data: XOR<PromotionBannerUpdateInput, PromotionBannerUncheckedUpdateInput>
    /**
     * Choose, which PromotionBanner to update.
     */
    where: PromotionBannerWhereUniqueInput
  }

  /**
   * PromotionBanner updateMany
   */
  export type PromotionBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionBanners.
     */
    data: XOR<PromotionBannerUpdateManyMutationInput, PromotionBannerUncheckedUpdateManyInput>
    /**
     * Filter which PromotionBanners to update
     */
    where?: PromotionBannerWhereInput
  }

  /**
   * PromotionBanner upsert
   */
  export type PromotionBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionBanner to update in case it exists.
     */
    where: PromotionBannerWhereUniqueInput
    /**
     * In case the PromotionBanner found by the `where` argument doesn't exist, create a new PromotionBanner with this data.
     */
    create: XOR<PromotionBannerCreateInput, PromotionBannerUncheckedCreateInput>
    /**
     * In case the PromotionBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionBannerUpdateInput, PromotionBannerUncheckedUpdateInput>
  }

  /**
   * PromotionBanner delete
   */
  export type PromotionBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    /**
     * Filter which PromotionBanner to delete.
     */
    where: PromotionBannerWhereUniqueInput
  }

  /**
   * PromotionBanner deleteMany
   */
  export type PromotionBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionBanners to delete
     */
    where?: PromotionBannerWhereInput
  }

  /**
   * PromotionBanner.coupon
   */
  export type PromotionBanner$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * PromotionBanner.marketingTemplate
   */
  export type PromotionBanner$marketingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    where?: MarketingTemplateWhereInput
  }

  /**
   * PromotionBanner.menuAssignments
   */
  export type PromotionBanner$menuAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    where?: MenuPromotionBannerWhereInput
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    cursor?: MenuPromotionBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuPromotionBannerScalarFieldEnum | MenuPromotionBannerScalarFieldEnum[]
  }

  /**
   * PromotionBanner without action
   */
  export type PromotionBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
  }


  /**
   * Model MenuPromotionBanner
   */

  export type AggregateMenuPromotionBanner = {
    _count: MenuPromotionBannerCountAggregateOutputType | null
    _avg: MenuPromotionBannerAvgAggregateOutputType | null
    _sum: MenuPromotionBannerSumAggregateOutputType | null
    _min: MenuPromotionBannerMinAggregateOutputType | null
    _max: MenuPromotionBannerMaxAggregateOutputType | null
  }

  export type MenuPromotionBannerAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type MenuPromotionBannerSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type MenuPromotionBannerMinAggregateOutputType = {
    id: string | null
    menuId: string | null
    promotionBannerId: string | null
    sortOrder: number | null
  }

  export type MenuPromotionBannerMaxAggregateOutputType = {
    id: string | null
    menuId: string | null
    promotionBannerId: string | null
    sortOrder: number | null
  }

  export type MenuPromotionBannerCountAggregateOutputType = {
    id: number
    menuId: number
    promotionBannerId: number
    sortOrder: number
    _all: number
  }


  export type MenuPromotionBannerAvgAggregateInputType = {
    sortOrder?: true
  }

  export type MenuPromotionBannerSumAggregateInputType = {
    sortOrder?: true
  }

  export type MenuPromotionBannerMinAggregateInputType = {
    id?: true
    menuId?: true
    promotionBannerId?: true
    sortOrder?: true
  }

  export type MenuPromotionBannerMaxAggregateInputType = {
    id?: true
    menuId?: true
    promotionBannerId?: true
    sortOrder?: true
  }

  export type MenuPromotionBannerCountAggregateInputType = {
    id?: true
    menuId?: true
    promotionBannerId?: true
    sortOrder?: true
    _all?: true
  }

  export type MenuPromotionBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuPromotionBanner to aggregate.
     */
    where?: MenuPromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuPromotionBanners to fetch.
     */
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuPromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuPromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuPromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuPromotionBanners
    **/
    _count?: true | MenuPromotionBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuPromotionBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuPromotionBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuPromotionBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuPromotionBannerMaxAggregateInputType
  }

  export type GetMenuPromotionBannerAggregateType<T extends MenuPromotionBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuPromotionBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuPromotionBanner[P]>
      : GetScalarType<T[P], AggregateMenuPromotionBanner[P]>
  }




  export type MenuPromotionBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuPromotionBannerWhereInput
    orderBy?: MenuPromotionBannerOrderByWithAggregationInput | MenuPromotionBannerOrderByWithAggregationInput[]
    by: MenuPromotionBannerScalarFieldEnum[] | MenuPromotionBannerScalarFieldEnum
    having?: MenuPromotionBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuPromotionBannerCountAggregateInputType | true
    _avg?: MenuPromotionBannerAvgAggregateInputType
    _sum?: MenuPromotionBannerSumAggregateInputType
    _min?: MenuPromotionBannerMinAggregateInputType
    _max?: MenuPromotionBannerMaxAggregateInputType
  }

  export type MenuPromotionBannerGroupByOutputType = {
    id: string
    menuId: string
    promotionBannerId: string
    sortOrder: number
    _count: MenuPromotionBannerCountAggregateOutputType | null
    _avg: MenuPromotionBannerAvgAggregateOutputType | null
    _sum: MenuPromotionBannerSumAggregateOutputType | null
    _min: MenuPromotionBannerMinAggregateOutputType | null
    _max: MenuPromotionBannerMaxAggregateOutputType | null
  }

  type GetMenuPromotionBannerGroupByPayload<T extends MenuPromotionBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuPromotionBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuPromotionBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuPromotionBannerGroupByOutputType[P]>
            : GetScalarType<T[P], MenuPromotionBannerGroupByOutputType[P]>
        }
      >
    >


  export type MenuPromotionBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    promotionBannerId?: boolean
    sortOrder?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    promotionBanner?: boolean | PromotionBannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuPromotionBanner"]>

  export type MenuPromotionBannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    promotionBannerId?: boolean
    sortOrder?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    promotionBanner?: boolean | PromotionBannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuPromotionBanner"]>

  export type MenuPromotionBannerSelectScalar = {
    id?: boolean
    menuId?: boolean
    promotionBannerId?: boolean
    sortOrder?: boolean
  }

  export type MenuPromotionBannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    promotionBanner?: boolean | PromotionBannerDefaultArgs<ExtArgs>
  }
  export type MenuPromotionBannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    promotionBanner?: boolean | PromotionBannerDefaultArgs<ExtArgs>
  }

  export type $MenuPromotionBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuPromotionBanner"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
      promotionBanner: Prisma.$PromotionBannerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menuId: string
      promotionBannerId: string
      sortOrder: number
    }, ExtArgs["result"]["menuPromotionBanner"]>
    composites: {}
  }

  type MenuPromotionBannerGetPayload<S extends boolean | null | undefined | MenuPromotionBannerDefaultArgs> = $Result.GetResult<Prisma.$MenuPromotionBannerPayload, S>

  type MenuPromotionBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuPromotionBannerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuPromotionBannerCountAggregateInputType | true
    }

  export interface MenuPromotionBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuPromotionBanner'], meta: { name: 'MenuPromotionBanner' } }
    /**
     * Find zero or one MenuPromotionBanner that matches the filter.
     * @param {MenuPromotionBannerFindUniqueArgs} args - Arguments to find a MenuPromotionBanner
     * @example
     * // Get one MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuPromotionBannerFindUniqueArgs>(args: SelectSubset<T, MenuPromotionBannerFindUniqueArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MenuPromotionBanner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuPromotionBannerFindUniqueOrThrowArgs} args - Arguments to find a MenuPromotionBanner
     * @example
     * // Get one MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuPromotionBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuPromotionBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MenuPromotionBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerFindFirstArgs} args - Arguments to find a MenuPromotionBanner
     * @example
     * // Get one MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuPromotionBannerFindFirstArgs>(args?: SelectSubset<T, MenuPromotionBannerFindFirstArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MenuPromotionBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerFindFirstOrThrowArgs} args - Arguments to find a MenuPromotionBanner
     * @example
     * // Get one MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuPromotionBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuPromotionBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MenuPromotionBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuPromotionBanners
     * const menuPromotionBanners = await prisma.menuPromotionBanner.findMany()
     * 
     * // Get first 10 MenuPromotionBanners
     * const menuPromotionBanners = await prisma.menuPromotionBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuPromotionBannerWithIdOnly = await prisma.menuPromotionBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuPromotionBannerFindManyArgs>(args?: SelectSubset<T, MenuPromotionBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MenuPromotionBanner.
     * @param {MenuPromotionBannerCreateArgs} args - Arguments to create a MenuPromotionBanner.
     * @example
     * // Create one MenuPromotionBanner
     * const MenuPromotionBanner = await prisma.menuPromotionBanner.create({
     *   data: {
     *     // ... data to create a MenuPromotionBanner
     *   }
     * })
     * 
     */
    create<T extends MenuPromotionBannerCreateArgs>(args: SelectSubset<T, MenuPromotionBannerCreateArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MenuPromotionBanners.
     * @param {MenuPromotionBannerCreateManyArgs} args - Arguments to create many MenuPromotionBanners.
     * @example
     * // Create many MenuPromotionBanners
     * const menuPromotionBanner = await prisma.menuPromotionBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuPromotionBannerCreateManyArgs>(args?: SelectSubset<T, MenuPromotionBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuPromotionBanners and returns the data saved in the database.
     * @param {MenuPromotionBannerCreateManyAndReturnArgs} args - Arguments to create many MenuPromotionBanners.
     * @example
     * // Create many MenuPromotionBanners
     * const menuPromotionBanner = await prisma.menuPromotionBanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuPromotionBanners and only return the `id`
     * const menuPromotionBannerWithIdOnly = await prisma.menuPromotionBanner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuPromotionBannerCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuPromotionBannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MenuPromotionBanner.
     * @param {MenuPromotionBannerDeleteArgs} args - Arguments to delete one MenuPromotionBanner.
     * @example
     * // Delete one MenuPromotionBanner
     * const MenuPromotionBanner = await prisma.menuPromotionBanner.delete({
     *   where: {
     *     // ... filter to delete one MenuPromotionBanner
     *   }
     * })
     * 
     */
    delete<T extends MenuPromotionBannerDeleteArgs>(args: SelectSubset<T, MenuPromotionBannerDeleteArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MenuPromotionBanner.
     * @param {MenuPromotionBannerUpdateArgs} args - Arguments to update one MenuPromotionBanner.
     * @example
     * // Update one MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuPromotionBannerUpdateArgs>(args: SelectSubset<T, MenuPromotionBannerUpdateArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MenuPromotionBanners.
     * @param {MenuPromotionBannerDeleteManyArgs} args - Arguments to filter MenuPromotionBanners to delete.
     * @example
     * // Delete a few MenuPromotionBanners
     * const { count } = await prisma.menuPromotionBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuPromotionBannerDeleteManyArgs>(args?: SelectSubset<T, MenuPromotionBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuPromotionBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuPromotionBanners
     * const menuPromotionBanner = await prisma.menuPromotionBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuPromotionBannerUpdateManyArgs>(args: SelectSubset<T, MenuPromotionBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuPromotionBanner.
     * @param {MenuPromotionBannerUpsertArgs} args - Arguments to update or create a MenuPromotionBanner.
     * @example
     * // Update or create a MenuPromotionBanner
     * const menuPromotionBanner = await prisma.menuPromotionBanner.upsert({
     *   create: {
     *     // ... data to create a MenuPromotionBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuPromotionBanner we want to update
     *   }
     * })
     */
    upsert<T extends MenuPromotionBannerUpsertArgs>(args: SelectSubset<T, MenuPromotionBannerUpsertArgs<ExtArgs>>): Prisma__MenuPromotionBannerClient<$Result.GetResult<Prisma.$MenuPromotionBannerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MenuPromotionBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerCountArgs} args - Arguments to filter MenuPromotionBanners to count.
     * @example
     * // Count the number of MenuPromotionBanners
     * const count = await prisma.menuPromotionBanner.count({
     *   where: {
     *     // ... the filter for the MenuPromotionBanners we want to count
     *   }
     * })
    **/
    count<T extends MenuPromotionBannerCountArgs>(
      args?: Subset<T, MenuPromotionBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuPromotionBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuPromotionBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuPromotionBannerAggregateArgs>(args: Subset<T, MenuPromotionBannerAggregateArgs>): Prisma.PrismaPromise<GetMenuPromotionBannerAggregateType<T>>

    /**
     * Group by MenuPromotionBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuPromotionBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuPromotionBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuPromotionBannerGroupByArgs['orderBy'] }
        : { orderBy?: MenuPromotionBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuPromotionBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuPromotionBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuPromotionBanner model
   */
  readonly fields: MenuPromotionBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuPromotionBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuPromotionBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    promotionBanner<T extends PromotionBannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionBannerDefaultArgs<ExtArgs>>): Prisma__PromotionBannerClient<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuPromotionBanner model
   */ 
  interface MenuPromotionBannerFieldRefs {
    readonly id: FieldRef<"MenuPromotionBanner", 'String'>
    readonly menuId: FieldRef<"MenuPromotionBanner", 'String'>
    readonly promotionBannerId: FieldRef<"MenuPromotionBanner", 'String'>
    readonly sortOrder: FieldRef<"MenuPromotionBanner", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MenuPromotionBanner findUnique
   */
  export type MenuPromotionBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which MenuPromotionBanner to fetch.
     */
    where: MenuPromotionBannerWhereUniqueInput
  }

  /**
   * MenuPromotionBanner findUniqueOrThrow
   */
  export type MenuPromotionBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which MenuPromotionBanner to fetch.
     */
    where: MenuPromotionBannerWhereUniqueInput
  }

  /**
   * MenuPromotionBanner findFirst
   */
  export type MenuPromotionBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which MenuPromotionBanner to fetch.
     */
    where?: MenuPromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuPromotionBanners to fetch.
     */
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuPromotionBanners.
     */
    cursor?: MenuPromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuPromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuPromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuPromotionBanners.
     */
    distinct?: MenuPromotionBannerScalarFieldEnum | MenuPromotionBannerScalarFieldEnum[]
  }

  /**
   * MenuPromotionBanner findFirstOrThrow
   */
  export type MenuPromotionBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which MenuPromotionBanner to fetch.
     */
    where?: MenuPromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuPromotionBanners to fetch.
     */
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuPromotionBanners.
     */
    cursor?: MenuPromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuPromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuPromotionBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuPromotionBanners.
     */
    distinct?: MenuPromotionBannerScalarFieldEnum | MenuPromotionBannerScalarFieldEnum[]
  }

  /**
   * MenuPromotionBanner findMany
   */
  export type MenuPromotionBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter, which MenuPromotionBanners to fetch.
     */
    where?: MenuPromotionBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuPromotionBanners to fetch.
     */
    orderBy?: MenuPromotionBannerOrderByWithRelationInput | MenuPromotionBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuPromotionBanners.
     */
    cursor?: MenuPromotionBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuPromotionBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuPromotionBanners.
     */
    skip?: number
    distinct?: MenuPromotionBannerScalarFieldEnum | MenuPromotionBannerScalarFieldEnum[]
  }

  /**
   * MenuPromotionBanner create
   */
  export type MenuPromotionBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuPromotionBanner.
     */
    data: XOR<MenuPromotionBannerCreateInput, MenuPromotionBannerUncheckedCreateInput>
  }

  /**
   * MenuPromotionBanner createMany
   */
  export type MenuPromotionBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuPromotionBanners.
     */
    data: MenuPromotionBannerCreateManyInput | MenuPromotionBannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuPromotionBanner createManyAndReturn
   */
  export type MenuPromotionBannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MenuPromotionBanners.
     */
    data: MenuPromotionBannerCreateManyInput | MenuPromotionBannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuPromotionBanner update
   */
  export type MenuPromotionBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuPromotionBanner.
     */
    data: XOR<MenuPromotionBannerUpdateInput, MenuPromotionBannerUncheckedUpdateInput>
    /**
     * Choose, which MenuPromotionBanner to update.
     */
    where: MenuPromotionBannerWhereUniqueInput
  }

  /**
   * MenuPromotionBanner updateMany
   */
  export type MenuPromotionBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuPromotionBanners.
     */
    data: XOR<MenuPromotionBannerUpdateManyMutationInput, MenuPromotionBannerUncheckedUpdateManyInput>
    /**
     * Filter which MenuPromotionBanners to update
     */
    where?: MenuPromotionBannerWhereInput
  }

  /**
   * MenuPromotionBanner upsert
   */
  export type MenuPromotionBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuPromotionBanner to update in case it exists.
     */
    where: MenuPromotionBannerWhereUniqueInput
    /**
     * In case the MenuPromotionBanner found by the `where` argument doesn't exist, create a new MenuPromotionBanner with this data.
     */
    create: XOR<MenuPromotionBannerCreateInput, MenuPromotionBannerUncheckedCreateInput>
    /**
     * In case the MenuPromotionBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuPromotionBannerUpdateInput, MenuPromotionBannerUncheckedUpdateInput>
  }

  /**
   * MenuPromotionBanner delete
   */
  export type MenuPromotionBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
    /**
     * Filter which MenuPromotionBanner to delete.
     */
    where: MenuPromotionBannerWhereUniqueInput
  }

  /**
   * MenuPromotionBanner deleteMany
   */
  export type MenuPromotionBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuPromotionBanners to delete
     */
    where?: MenuPromotionBannerWhereInput
  }

  /**
   * MenuPromotionBanner without action
   */
  export type MenuPromotionBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuPromotionBanner
     */
    select?: MenuPromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuPromotionBannerInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    price: Decimal | null
    maxOrders: number | null
    currentOrders: number | null
    promotionPrice: Decimal | null
  }

  export type MenuItemSumAggregateOutputType = {
    price: Decimal | null
    maxOrders: number | null
    currentOrders: number | null
    promotionPrice: Decimal | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: string | null
    menuId: string | null
    dishId: string | null
    date: Date | null
    available: boolean | null
    price: Decimal | null
    maxOrders: number | null
    currentOrders: number | null
    isPromotion: boolean | null
    promotionPrice: Decimal | null
    promotionLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: string | null
    menuId: string | null
    dishId: string | null
    date: Date | null
    available: boolean | null
    price: Decimal | null
    maxOrders: number | null
    currentOrders: number | null
    isPromotion: boolean | null
    promotionPrice: Decimal | null
    promotionLabel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    menuId: number
    dishId: number
    date: number
    available: number
    price: number
    maxOrders: number
    currentOrders: number
    isPromotion: number
    promotionPrice: number
    promotionLabel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    price?: true
    maxOrders?: true
    currentOrders?: true
    promotionPrice?: true
  }

  export type MenuItemSumAggregateInputType = {
    price?: true
    maxOrders?: true
    currentOrders?: true
    promotionPrice?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    menuId?: true
    dishId?: true
    date?: true
    available?: true
    price?: true
    maxOrders?: true
    currentOrders?: true
    isPromotion?: true
    promotionPrice?: true
    promotionLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    dishId?: true
    date?: true
    available?: true
    price?: true
    maxOrders?: true
    currentOrders?: true
    isPromotion?: true
    promotionPrice?: true
    promotionLabel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    menuId?: true
    dishId?: true
    date?: true
    available?: true
    price?: true
    maxOrders?: true
    currentOrders?: true
    isPromotion?: true
    promotionPrice?: true
    promotionLabel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: string
    menuId: string
    dishId: string
    date: Date
    available: boolean
    price: Decimal
    maxOrders: number | null
    currentOrders: number
    isPromotion: boolean
    promotionPrice: Decimal | null
    promotionLabel: string | null
    createdAt: Date
    updatedAt: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    dishId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    maxOrders?: boolean
    currentOrders?: boolean
    isPromotion?: boolean
    promotionPrice?: boolean
    promotionLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    dish?: boolean | DishDefaultArgs<ExtArgs>
    orderItems?: boolean | MenuItem$orderItemsArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    dishId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    maxOrders?: boolean
    currentOrders?: boolean
    isPromotion?: boolean
    promotionPrice?: boolean
    promotionLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    dish?: boolean | DishDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    menuId?: boolean
    dishId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    maxOrders?: boolean
    currentOrders?: boolean
    isPromotion?: boolean
    promotionPrice?: boolean
    promotionLabel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    dish?: boolean | DishDefaultArgs<ExtArgs>
    orderItems?: boolean | MenuItem$orderItemsArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    dish?: boolean | DishDefaultArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
      dish: Prisma.$DishPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menuId: string
      dishId: string
      date: Date
      available: boolean
      price: Prisma.Decimal
      maxOrders: number | null
      currentOrders: number
      isPromotion: boolean
      promotionPrice: Prisma.Decimal | null
      promotionLabel: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dish<T extends DishDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DishDefaultArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orderItems<T extends MenuItem$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */ 
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'String'>
    readonly menuId: FieldRef<"MenuItem", 'String'>
    readonly dishId: FieldRef<"MenuItem", 'String'>
    readonly date: FieldRef<"MenuItem", 'DateTime'>
    readonly available: FieldRef<"MenuItem", 'Boolean'>
    readonly price: FieldRef<"MenuItem", 'Decimal'>
    readonly maxOrders: FieldRef<"MenuItem", 'Int'>
    readonly currentOrders: FieldRef<"MenuItem", 'Int'>
    readonly isPromotion: FieldRef<"MenuItem", 'Boolean'>
    readonly promotionPrice: FieldRef<"MenuItem", 'Decimal'>
    readonly promotionLabel: FieldRef<"MenuItem", 'String'>
    readonly createdAt: FieldRef<"MenuItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem.orderItems
   */
  export type MenuItem$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model Dish
   */

  export type AggregateDish = {
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  export type DishAvgAggregateOutputType = {
    calories: number | null
    protein: Decimal | null
    carbs: Decimal | null
    fat: Decimal | null
  }

  export type DishSumAggregateOutputType = {
    calories: number | null
    protein: Decimal | null
    carbs: Decimal | null
    fat: Decimal | null
  }

  export type DishMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    calories: number | null
    protein: Decimal | null
    carbs: Decimal | null
    fat: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DishMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    category: string | null
    calories: number | null
    protein: Decimal | null
    carbs: Decimal | null
    fat: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DishCountAggregateOutputType = {
    id: number
    name: number
    description: number
    imageUrl: number
    category: number
    calories: number
    protein: number
    carbs: number
    fat: number
    allergens: number
    dietTags: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DishAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fat?: true
  }

  export type DishSumAggregateInputType = {
    calories?: true
    protein?: true
    carbs?: true
    fat?: true
  }

  export type DishMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    calories?: true
    protein?: true
    carbs?: true
    fat?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DishMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    calories?: true
    protein?: true
    carbs?: true
    fat?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DishCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    imageUrl?: true
    category?: true
    calories?: true
    protein?: true
    carbs?: true
    fat?: true
    allergens?: true
    dietTags?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dish to aggregate.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dishes
    **/
    _count?: true | DishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishMaxAggregateInputType
  }

  export type GetDishAggregateType<T extends DishAggregateArgs> = {
        [P in keyof T & keyof AggregateDish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDish[P]>
      : GetScalarType<T[P], AggregateDish[P]>
  }




  export type DishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
    orderBy?: DishOrderByWithAggregationInput | DishOrderByWithAggregationInput[]
    by: DishScalarFieldEnum[] | DishScalarFieldEnum
    having?: DishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishCountAggregateInputType | true
    _avg?: DishAvgAggregateInputType
    _sum?: DishSumAggregateInputType
    _min?: DishMinAggregateInputType
    _max?: DishMaxAggregateInputType
  }

  export type DishGroupByOutputType = {
    id: string
    name: string
    description: string | null
    imageUrl: string | null
    category: string | null
    calories: number | null
    protein: Decimal | null
    carbs: Decimal | null
    fat: Decimal | null
    allergens: string[]
    dietTags: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  type GetDishGroupByPayload<T extends DishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishGroupByOutputType[P]>
            : GetScalarType<T[P], DishGroupByOutputType[P]>
        }
      >
    >


  export type DishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fat?: boolean
    allergens?: boolean
    dietTags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menuItems?: boolean | Dish$menuItemsArgs<ExtArgs>
    coupons?: boolean | Dish$couponsArgs<ExtArgs>
    _count?: boolean | DishCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fat?: boolean
    allergens?: boolean
    dietTags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dish"]>

  export type DishSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    category?: boolean
    calories?: boolean
    protein?: boolean
    carbs?: boolean
    fat?: boolean
    allergens?: boolean
    dietTags?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menuItems?: boolean | Dish$menuItemsArgs<ExtArgs>
    coupons?: boolean | Dish$couponsArgs<ExtArgs>
    _count?: boolean | DishCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dish"
    objects: {
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
      coupons: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      imageUrl: string | null
      category: string | null
      calories: number | null
      protein: Prisma.Decimal | null
      carbs: Prisma.Decimal | null
      fat: Prisma.Decimal | null
      allergens: string[]
      dietTags: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dish"]>
    composites: {}
  }

  type DishGetPayload<S extends boolean | null | undefined | DishDefaultArgs> = $Result.GetResult<Prisma.$DishPayload, S>

  type DishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DishFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DishCountAggregateInputType | true
    }

  export interface DishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dish'], meta: { name: 'Dish' } }
    /**
     * Find zero or one Dish that matches the filter.
     * @param {DishFindUniqueArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DishFindUniqueArgs>(args: SelectSubset<T, DishFindUniqueArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dish that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DishFindUniqueOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DishFindUniqueOrThrowArgs>(args: SelectSubset<T, DishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DishFindFirstArgs>(args?: SelectSubset<T, DishFindFirstArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DishFindFirstOrThrowArgs>(args?: SelectSubset<T, DishFindFirstOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dishes
     * const dishes = await prisma.dish.findMany()
     * 
     * // Get first 10 Dishes
     * const dishes = await prisma.dish.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dishWithIdOnly = await prisma.dish.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DishFindManyArgs>(args?: SelectSubset<T, DishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dish.
     * @param {DishCreateArgs} args - Arguments to create a Dish.
     * @example
     * // Create one Dish
     * const Dish = await prisma.dish.create({
     *   data: {
     *     // ... data to create a Dish
     *   }
     * })
     * 
     */
    create<T extends DishCreateArgs>(args: SelectSubset<T, DishCreateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dishes.
     * @param {DishCreateManyArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DishCreateManyArgs>(args?: SelectSubset<T, DishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dishes and returns the data saved in the database.
     * @param {DishCreateManyAndReturnArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dishes and only return the `id`
     * const dishWithIdOnly = await prisma.dish.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DishCreateManyAndReturnArgs>(args?: SelectSubset<T, DishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Dish.
     * @param {DishDeleteArgs} args - Arguments to delete one Dish.
     * @example
     * // Delete one Dish
     * const Dish = await prisma.dish.delete({
     *   where: {
     *     // ... filter to delete one Dish
     *   }
     * })
     * 
     */
    delete<T extends DishDeleteArgs>(args: SelectSubset<T, DishDeleteArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dish.
     * @param {DishUpdateArgs} args - Arguments to update one Dish.
     * @example
     * // Update one Dish
     * const dish = await prisma.dish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DishUpdateArgs>(args: SelectSubset<T, DishUpdateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dishes.
     * @param {DishDeleteManyArgs} args - Arguments to filter Dishes to delete.
     * @example
     * // Delete a few Dishes
     * const { count } = await prisma.dish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DishDeleteManyArgs>(args?: SelectSubset<T, DishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DishUpdateManyArgs>(args: SelectSubset<T, DishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dish.
     * @param {DishUpsertArgs} args - Arguments to update or create a Dish.
     * @example
     * // Update or create a Dish
     * const dish = await prisma.dish.upsert({
     *   create: {
     *     // ... data to create a Dish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dish we want to update
     *   }
     * })
     */
    upsert<T extends DishUpsertArgs>(args: SelectSubset<T, DishUpsertArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCountArgs} args - Arguments to filter Dishes to count.
     * @example
     * // Count the number of Dishes
     * const count = await prisma.dish.count({
     *   where: {
     *     // ... the filter for the Dishes we want to count
     *   }
     * })
    **/
    count<T extends DishCountArgs>(
      args?: Subset<T, DishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishAggregateArgs>(args: Subset<T, DishAggregateArgs>): Prisma.PrismaPromise<GetDishAggregateType<T>>

    /**
     * Group by Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishGroupByArgs['orderBy'] }
        : { orderBy?: DishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dish model
   */
  readonly fields: DishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menuItems<T extends Dish$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, Dish$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany"> | Null>
    coupons<T extends Dish$couponsArgs<ExtArgs> = {}>(args?: Subset<T, Dish$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dish model
   */ 
  interface DishFieldRefs {
    readonly id: FieldRef<"Dish", 'String'>
    readonly name: FieldRef<"Dish", 'String'>
    readonly description: FieldRef<"Dish", 'String'>
    readonly imageUrl: FieldRef<"Dish", 'String'>
    readonly category: FieldRef<"Dish", 'String'>
    readonly calories: FieldRef<"Dish", 'Int'>
    readonly protein: FieldRef<"Dish", 'Decimal'>
    readonly carbs: FieldRef<"Dish", 'Decimal'>
    readonly fat: FieldRef<"Dish", 'Decimal'>
    readonly allergens: FieldRef<"Dish", 'String[]'>
    readonly dietTags: FieldRef<"Dish", 'String[]'>
    readonly isActive: FieldRef<"Dish", 'Boolean'>
    readonly createdAt: FieldRef<"Dish", 'DateTime'>
    readonly updatedAt: FieldRef<"Dish", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dish findUnique
   */
  export type DishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish findUniqueOrThrow
   */
  export type DishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish findFirst
   */
  export type DishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish findFirstOrThrow
   */
  export type DishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish findMany
   */
  export type DishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dishes to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish create
   */
  export type DishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to create a Dish.
     */
    data: XOR<DishCreateInput, DishUncheckedCreateInput>
  }

  /**
   * Dish createMany
   */
  export type DishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dish createManyAndReturn
   */
  export type DishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dish update
   */
  export type DishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to update a Dish.
     */
    data: XOR<DishUpdateInput, DishUncheckedUpdateInput>
    /**
     * Choose, which Dish to update.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish updateMany
   */
  export type DishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dishes.
     */
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyInput>
    /**
     * Filter which Dishes to update
     */
    where?: DishWhereInput
  }

  /**
   * Dish upsert
   */
  export type DishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The filter to search for the Dish to update in case it exists.
     */
    where: DishWhereUniqueInput
    /**
     * In case the Dish found by the `where` argument doesn't exist, create a new Dish with this data.
     */
    create: XOR<DishCreateInput, DishUncheckedCreateInput>
    /**
     * In case the Dish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DishUpdateInput, DishUncheckedUpdateInput>
  }

  /**
   * Dish delete
   */
  export type DishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter which Dish to delete.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish deleteMany
   */
  export type DishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dishes to delete
     */
    where?: DishWhereInput
  }

  /**
   * Dish.menuItems
   */
  export type Dish$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Dish.coupons
   */
  export type Dish$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Dish without action
   */
  export type DishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    employerSubsidyAmount: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    employerSubsidyAmount: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: Decimal | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: string | null
    paymentIntentId: string | null
    pickupCode: string | null
    pickupDate: Date | null
    pickupTimeSlot: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pickedUpAt: Date | null
    couponCode: string | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    employerSubsidyAmount: Decimal | null
    employerCompanyId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: Decimal | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: string | null
    paymentIntentId: string | null
    pickupCode: string | null
    pickupDate: Date | null
    pickupTimeSlot: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pickedUpAt: Date | null
    couponCode: string | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    employerSubsidyAmount: Decimal | null
    employerCompanyId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    status: number
    totalAmount: number
    paymentStatus: number
    paymentMethod: number
    paymentIntentId: number
    pickupCode: number
    pickupDate: number
    pickupTimeSlot: number
    notes: number
    createdAt: number
    updatedAt: number
    pickedUpAt: number
    couponCode: number
    discountAmount: number
    finalAmount: number
    employerSubsidyAmount: number
    employerCompanyId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    employerSubsidyAmount?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    finalAmount?: true
    employerSubsidyAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentIntentId?: true
    pickupCode?: true
    pickupDate?: true
    pickupTimeSlot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    pickedUpAt?: true
    couponCode?: true
    discountAmount?: true
    finalAmount?: true
    employerSubsidyAmount?: true
    employerCompanyId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentIntentId?: true
    pickupCode?: true
    pickupDate?: true
    pickupTimeSlot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    pickedUpAt?: true
    couponCode?: true
    discountAmount?: true
    finalAmount?: true
    employerSubsidyAmount?: true
    employerCompanyId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    paymentMethod?: true
    paymentIntentId?: true
    pickupCode?: true
    pickupDate?: true
    pickupTimeSlot?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    pickedUpAt?: true
    couponCode?: true
    discountAmount?: true
    finalAmount?: true
    employerSubsidyAmount?: true
    employerCompanyId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    status: $Enums.OrderStatus
    totalAmount: Decimal
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: string | null
    paymentIntentId: string | null
    pickupCode: string
    pickupDate: Date
    pickupTimeSlot: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    pickedUpAt: Date | null
    couponCode: string | null
    discountAmount: Decimal | null
    finalAmount: Decimal | null
    employerSubsidyAmount: Decimal | null
    employerCompanyId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    pickupCode?: boolean
    pickupDate?: boolean
    pickupTimeSlot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickedUpAt?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    employerSubsidyAmount?: boolean
    employerCompanyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    couponRedemptions?: boolean | Order$couponRedemptionsArgs<ExtArgs>
    employerCompany?: boolean | Order$employerCompanyArgs<ExtArgs>
    walletTransactions?: boolean | Order$walletTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    pickupCode?: boolean
    pickupDate?: boolean
    pickupTimeSlot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickedUpAt?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    employerSubsidyAmount?: boolean
    employerCompanyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    employerCompany?: boolean | Order$employerCompanyArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    paymentIntentId?: boolean
    pickupCode?: boolean
    pickupDate?: boolean
    pickupTimeSlot?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pickedUpAt?: boolean
    couponCode?: boolean
    discountAmount?: boolean
    finalAmount?: boolean
    employerSubsidyAmount?: boolean
    employerCompanyId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    couponRedemptions?: boolean | Order$couponRedemptionsArgs<ExtArgs>
    employerCompany?: boolean | Order$employerCompanyArgs<ExtArgs>
    walletTransactions?: boolean | Order$walletTransactionsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    employerCompany?: boolean | Order$employerCompanyArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      couponRedemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
      employerCompany: Prisma.$CompanyPayload<ExtArgs> | null
      walletTransactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      status: $Enums.OrderStatus
      totalAmount: Prisma.Decimal
      paymentStatus: $Enums.PaymentStatus
      paymentMethod: string | null
      paymentIntentId: string | null
      pickupCode: string
      pickupDate: Date
      pickupTimeSlot: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      pickedUpAt: Date | null
      couponCode: string | null
      discountAmount: Prisma.Decimal | null
      finalAmount: Prisma.Decimal | null
      employerSubsidyAmount: Prisma.Decimal | null
      employerCompanyId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    couponRedemptions<T extends Order$couponRedemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$couponRedemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    employerCompany<T extends Order$employerCompanyArgs<ExtArgs> = {}>(args?: Subset<T, Order$employerCompanyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    walletTransactions<T extends Order$walletTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Order$walletTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly locationId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly paymentStatus: FieldRef<"Order", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly paymentIntentId: FieldRef<"Order", 'String'>
    readonly pickupCode: FieldRef<"Order", 'String'>
    readonly pickupDate: FieldRef<"Order", 'DateTime'>
    readonly pickupTimeSlot: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly pickedUpAt: FieldRef<"Order", 'DateTime'>
    readonly couponCode: FieldRef<"Order", 'String'>
    readonly discountAmount: FieldRef<"Order", 'Decimal'>
    readonly finalAmount: FieldRef<"Order", 'Decimal'>
    readonly employerSubsidyAmount: FieldRef<"Order", 'Decimal'>
    readonly employerCompanyId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.couponRedemptions
   */
  export type Order$couponRedemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * Order.employerCompany
   */
  export type Order$employerCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Order.walletTransactions
   */
  export type Order$walletTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    discountValue: Decimal | null
    maxUses: number | null
    maxUsesPerUser: number | null
    currentUses: number | null
    minOrderAmount: Decimal | null
  }

  export type CouponSumAggregateOutputType = {
    discountValue: Decimal | null
    maxUses: number | null
    maxUsesPerUser: number | null
    currentUses: number | null
    minOrderAmount: Decimal | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: $Enums.CouponType | null
    discountValue: Decimal | null
    freeItemDishId: string | null
    locationId: string | null
    startDate: Date | null
    endDate: Date | null
    maxUses: number | null
    maxUsesPerUser: number | null
    currentUses: number | null
    minOrderAmount: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: $Enums.CouponType | null
    discountValue: Decimal | null
    freeItemDishId: string | null
    locationId: string | null
    startDate: Date | null
    endDate: Date | null
    maxUses: number | null
    maxUsesPerUser: number | null
    currentUses: number | null
    minOrderAmount: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    discountValue: number
    freeItemDishId: number
    locationId: number
    startDate: number
    endDate: number
    maxUses: number
    maxUsesPerUser: number
    currentUses: number
    minOrderAmount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    discountValue?: true
    maxUses?: true
    maxUsesPerUser?: true
    currentUses?: true
    minOrderAmount?: true
  }

  export type CouponSumAggregateInputType = {
    discountValue?: true
    maxUses?: true
    maxUsesPerUser?: true
    currentUses?: true
    minOrderAmount?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    freeItemDishId?: true
    locationId?: true
    startDate?: true
    endDate?: true
    maxUses?: true
    maxUsesPerUser?: true
    currentUses?: true
    minOrderAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    freeItemDishId?: true
    locationId?: true
    startDate?: true
    endDate?: true
    maxUses?: true
    maxUsesPerUser?: true
    currentUses?: true
    minOrderAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountValue?: true
    freeItemDishId?: true
    locationId?: true
    startDate?: true
    endDate?: true
    maxUses?: true
    maxUsesPerUser?: true
    currentUses?: true
    minOrderAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: $Enums.CouponType
    discountValue: Decimal | null
    freeItemDishId: string | null
    locationId: string | null
    startDate: Date | null
    endDate: Date | null
    maxUses: number | null
    maxUsesPerUser: number
    currentUses: number
    minOrderAmount: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    freeItemDishId?: boolean
    locationId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxUses?: boolean
    maxUsesPerUser?: boolean
    currentUses?: boolean
    minOrderAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Coupon$locationArgs<ExtArgs>
    freeItemDish?: boolean | Coupon$freeItemDishArgs<ExtArgs>
    redemptions?: boolean | Coupon$redemptionsArgs<ExtArgs>
    incentiveGrants?: boolean | Coupon$incentiveGrantsArgs<ExtArgs>
    segmentIncentives?: boolean | Coupon$segmentIncentivesArgs<ExtArgs>
    promotionBanners?: boolean | Coupon$promotionBannersArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    freeItemDishId?: boolean
    locationId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxUses?: boolean
    maxUsesPerUser?: boolean
    currentUses?: boolean
    minOrderAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Coupon$locationArgs<ExtArgs>
    freeItemDish?: boolean | Coupon$freeItemDishArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountValue?: boolean
    freeItemDishId?: boolean
    locationId?: boolean
    startDate?: boolean
    endDate?: boolean
    maxUses?: boolean
    maxUsesPerUser?: boolean
    currentUses?: boolean
    minOrderAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Coupon$locationArgs<ExtArgs>
    freeItemDish?: boolean | Coupon$freeItemDishArgs<ExtArgs>
    redemptions?: boolean | Coupon$redemptionsArgs<ExtArgs>
    incentiveGrants?: boolean | Coupon$incentiveGrantsArgs<ExtArgs>
    segmentIncentives?: boolean | Coupon$segmentIncentivesArgs<ExtArgs>
    promotionBanners?: boolean | Coupon$promotionBannersArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Coupon$locationArgs<ExtArgs>
    freeItemDish?: boolean | Coupon$freeItemDishArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
      freeItemDish: Prisma.$DishPayload<ExtArgs> | null
      redemptions: Prisma.$CouponRedemptionPayload<ExtArgs>[]
      incentiveGrants: Prisma.$IncentiveGrantPayload<ExtArgs>[]
      segmentIncentives: Prisma.$SegmentIncentivePayload<ExtArgs>[]
      promotionBanners: Prisma.$PromotionBannerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: $Enums.CouponType
      discountValue: Prisma.Decimal | null
      freeItemDishId: string | null
      locationId: string | null
      startDate: Date | null
      endDate: Date | null
      maxUses: number | null
      maxUsesPerUser: number
      currentUses: number
      minOrderAmount: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Coupon$locationArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    freeItemDish<T extends Coupon$freeItemDishArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$freeItemDishArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    redemptions<T extends Coupon$redemptionsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$redemptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany"> | Null>
    incentiveGrants<T extends Coupon$incentiveGrantsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$incentiveGrantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findMany"> | Null>
    segmentIncentives<T extends Coupon$segmentIncentivesArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$segmentIncentivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findMany"> | Null>
    promotionBanners<T extends Coupon$promotionBannersArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$promotionBannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */ 
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly name: FieldRef<"Coupon", 'String'>
    readonly description: FieldRef<"Coupon", 'String'>
    readonly type: FieldRef<"Coupon", 'CouponType'>
    readonly discountValue: FieldRef<"Coupon", 'Decimal'>
    readonly freeItemDishId: FieldRef<"Coupon", 'String'>
    readonly locationId: FieldRef<"Coupon", 'String'>
    readonly startDate: FieldRef<"Coupon", 'DateTime'>
    readonly endDate: FieldRef<"Coupon", 'DateTime'>
    readonly maxUses: FieldRef<"Coupon", 'Int'>
    readonly maxUsesPerUser: FieldRef<"Coupon", 'Int'>
    readonly currentUses: FieldRef<"Coupon", 'Int'>
    readonly minOrderAmount: FieldRef<"Coupon", 'Decimal'>
    readonly isActive: FieldRef<"Coupon", 'Boolean'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon.location
   */
  export type Coupon$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Coupon.freeItemDish
   */
  export type Coupon$freeItemDishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
  }

  /**
   * Coupon.redemptions
   */
  export type Coupon$redemptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    cursor?: CouponRedemptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * Coupon.incentiveGrants
   */
  export type Coupon$incentiveGrantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    where?: IncentiveGrantWhereInput
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    cursor?: IncentiveGrantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * Coupon.segmentIncentives
   */
  export type Coupon$segmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    where?: SegmentIncentiveWhereInput
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    cursor?: SegmentIncentiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * Coupon.promotionBanners
   */
  export type Coupon$promotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    where?: PromotionBannerWhereInput
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    cursor?: PromotionBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionBannerScalarFieldEnum | PromotionBannerScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model CouponRedemption
   */

  export type AggregateCouponRedemption = {
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  export type CouponRedemptionMinAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    orderId: string | null
    redeemedAt: Date | null
  }

  export type CouponRedemptionMaxAggregateOutputType = {
    id: string | null
    couponId: string | null
    userId: string | null
    orderId: string | null
    redeemedAt: Date | null
  }

  export type CouponRedemptionCountAggregateOutputType = {
    id: number
    couponId: number
    userId: number
    orderId: number
    redeemedAt: number
    _all: number
  }


  export type CouponRedemptionMinAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
  }

  export type CouponRedemptionMaxAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
  }

  export type CouponRedemptionCountAggregateInputType = {
    id?: true
    couponId?: true
    userId?: true
    orderId?: true
    redeemedAt?: true
    _all?: true
  }

  export type CouponRedemptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemption to aggregate.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CouponRedemptions
    **/
    _count?: true | CouponRedemptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponRedemptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type GetCouponRedemptionAggregateType<T extends CouponRedemptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCouponRedemption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouponRedemption[P]>
      : GetScalarType<T[P], AggregateCouponRedemption[P]>
  }




  export type CouponRedemptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponRedemptionWhereInput
    orderBy?: CouponRedemptionOrderByWithAggregationInput | CouponRedemptionOrderByWithAggregationInput[]
    by: CouponRedemptionScalarFieldEnum[] | CouponRedemptionScalarFieldEnum
    having?: CouponRedemptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponRedemptionCountAggregateInputType | true
    _min?: CouponRedemptionMinAggregateInputType
    _max?: CouponRedemptionMaxAggregateInputType
  }

  export type CouponRedemptionGroupByOutputType = {
    id: string
    couponId: string
    userId: string
    orderId: string
    redeemedAt: Date
    _count: CouponRedemptionCountAggregateOutputType | null
    _min: CouponRedemptionMinAggregateOutputType | null
    _max: CouponRedemptionMaxAggregateOutputType | null
  }

  type GetCouponRedemptionGroupByPayload<T extends CouponRedemptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponRedemptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponRedemptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
            : GetScalarType<T[P], CouponRedemptionGroupByOutputType[P]>
        }
      >
    >


  export type CouponRedemptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["couponRedemption"]>

  export type CouponRedemptionSelectScalar = {
    id?: boolean
    couponId?: boolean
    userId?: boolean
    orderId?: boolean
    redeemedAt?: boolean
  }

  export type CouponRedemptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type CouponRedemptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coupon?: boolean | CouponDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $CouponRedemptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CouponRedemption"
    objects: {
      coupon: Prisma.$CouponPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      couponId: string
      userId: string
      orderId: string
      redeemedAt: Date
    }, ExtArgs["result"]["couponRedemption"]>
    composites: {}
  }

  type CouponRedemptionGetPayload<S extends boolean | null | undefined | CouponRedemptionDefaultArgs> = $Result.GetResult<Prisma.$CouponRedemptionPayload, S>

  type CouponRedemptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponRedemptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponRedemptionCountAggregateInputType | true
    }

  export interface CouponRedemptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CouponRedemption'], meta: { name: 'CouponRedemption' } }
    /**
     * Find zero or one CouponRedemption that matches the filter.
     * @param {CouponRedemptionFindUniqueArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponRedemptionFindUniqueArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CouponRedemption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponRedemptionFindUniqueOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponRedemptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponRedemptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CouponRedemption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponRedemptionFindFirstArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CouponRedemption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindFirstOrThrowArgs} args - Arguments to find a CouponRedemption
     * @example
     * // Get one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponRedemptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponRedemptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CouponRedemptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany()
     * 
     * // Get first 10 CouponRedemptions
     * const couponRedemptions = await prisma.couponRedemption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponRedemptionFindManyArgs>(args?: SelectSubset<T, CouponRedemptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CouponRedemption.
     * @param {CouponRedemptionCreateArgs} args - Arguments to create a CouponRedemption.
     * @example
     * // Create one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.create({
     *   data: {
     *     // ... data to create a CouponRedemption
     *   }
     * })
     * 
     */
    create<T extends CouponRedemptionCreateArgs>(args: SelectSubset<T, CouponRedemptionCreateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CouponRedemptions.
     * @param {CouponRedemptionCreateManyArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponRedemptionCreateManyArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CouponRedemptions and returns the data saved in the database.
     * @param {CouponRedemptionCreateManyAndReturnArgs} args - Arguments to create many CouponRedemptions.
     * @example
     * // Create many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CouponRedemptions and only return the `id`
     * const couponRedemptionWithIdOnly = await prisma.couponRedemption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponRedemptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponRedemptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CouponRedemption.
     * @param {CouponRedemptionDeleteArgs} args - Arguments to delete one CouponRedemption.
     * @example
     * // Delete one CouponRedemption
     * const CouponRedemption = await prisma.couponRedemption.delete({
     *   where: {
     *     // ... filter to delete one CouponRedemption
     *   }
     * })
     * 
     */
    delete<T extends CouponRedemptionDeleteArgs>(args: SelectSubset<T, CouponRedemptionDeleteArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CouponRedemption.
     * @param {CouponRedemptionUpdateArgs} args - Arguments to update one CouponRedemption.
     * @example
     * // Update one CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponRedemptionUpdateArgs>(args: SelectSubset<T, CouponRedemptionUpdateArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CouponRedemptions.
     * @param {CouponRedemptionDeleteManyArgs} args - Arguments to filter CouponRedemptions to delete.
     * @example
     * // Delete a few CouponRedemptions
     * const { count } = await prisma.couponRedemption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponRedemptionDeleteManyArgs>(args?: SelectSubset<T, CouponRedemptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CouponRedemptions
     * const couponRedemption = await prisma.couponRedemption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponRedemptionUpdateManyArgs>(args: SelectSubset<T, CouponRedemptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CouponRedemption.
     * @param {CouponRedemptionUpsertArgs} args - Arguments to update or create a CouponRedemption.
     * @example
     * // Update or create a CouponRedemption
     * const couponRedemption = await prisma.couponRedemption.upsert({
     *   create: {
     *     // ... data to create a CouponRedemption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CouponRedemption we want to update
     *   }
     * })
     */
    upsert<T extends CouponRedemptionUpsertArgs>(args: SelectSubset<T, CouponRedemptionUpsertArgs<ExtArgs>>): Prisma__CouponRedemptionClient<$Result.GetResult<Prisma.$CouponRedemptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CouponRedemptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionCountArgs} args - Arguments to filter CouponRedemptions to count.
     * @example
     * // Count the number of CouponRedemptions
     * const count = await prisma.couponRedemption.count({
     *   where: {
     *     // ... the filter for the CouponRedemptions we want to count
     *   }
     * })
    **/
    count<T extends CouponRedemptionCountArgs>(
      args?: Subset<T, CouponRedemptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponRedemptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponRedemptionAggregateArgs>(args: Subset<T, CouponRedemptionAggregateArgs>): Prisma.PrismaPromise<GetCouponRedemptionAggregateType<T>>

    /**
     * Group by CouponRedemption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponRedemptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponRedemptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponRedemptionGroupByArgs['orderBy'] }
        : { orderBy?: CouponRedemptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponRedemptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponRedemptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CouponRedemption model
   */
  readonly fields: CouponRedemptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CouponRedemption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponRedemptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coupon<T extends CouponDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CouponDefaultArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CouponRedemption model
   */ 
  interface CouponRedemptionFieldRefs {
    readonly id: FieldRef<"CouponRedemption", 'String'>
    readonly couponId: FieldRef<"CouponRedemption", 'String'>
    readonly userId: FieldRef<"CouponRedemption", 'String'>
    readonly orderId: FieldRef<"CouponRedemption", 'String'>
    readonly redeemedAt: FieldRef<"CouponRedemption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CouponRedemption findUnique
   */
  export type CouponRedemptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findUniqueOrThrow
   */
  export type CouponRedemptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption findFirst
   */
  export type CouponRedemptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findFirstOrThrow
   */
  export type CouponRedemptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemption to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CouponRedemptions.
     */
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption findMany
   */
  export type CouponRedemptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter, which CouponRedemptions to fetch.
     */
    where?: CouponRedemptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CouponRedemptions to fetch.
     */
    orderBy?: CouponRedemptionOrderByWithRelationInput | CouponRedemptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CouponRedemptions.
     */
    cursor?: CouponRedemptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CouponRedemptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CouponRedemptions.
     */
    skip?: number
    distinct?: CouponRedemptionScalarFieldEnum | CouponRedemptionScalarFieldEnum[]
  }

  /**
   * CouponRedemption create
   */
  export type CouponRedemptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CouponRedemption.
     */
    data: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
  }

  /**
   * CouponRedemption createMany
   */
  export type CouponRedemptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CouponRedemption createManyAndReturn
   */
  export type CouponRedemptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CouponRedemptions.
     */
    data: CouponRedemptionCreateManyInput | CouponRedemptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CouponRedemption update
   */
  export type CouponRedemptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CouponRedemption.
     */
    data: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
    /**
     * Choose, which CouponRedemption to update.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption updateMany
   */
  export type CouponRedemptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CouponRedemptions.
     */
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyInput>
    /**
     * Filter which CouponRedemptions to update
     */
    where?: CouponRedemptionWhereInput
  }

  /**
   * CouponRedemption upsert
   */
  export type CouponRedemptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CouponRedemption to update in case it exists.
     */
    where: CouponRedemptionWhereUniqueInput
    /**
     * In case the CouponRedemption found by the `where` argument doesn't exist, create a new CouponRedemption with this data.
     */
    create: XOR<CouponRedemptionCreateInput, CouponRedemptionUncheckedCreateInput>
    /**
     * In case the CouponRedemption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponRedemptionUpdateInput, CouponRedemptionUncheckedUpdateInput>
  }

  /**
   * CouponRedemption delete
   */
  export type CouponRedemptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
    /**
     * Filter which CouponRedemption to delete.
     */
    where: CouponRedemptionWhereUniqueInput
  }

  /**
   * CouponRedemption deleteMany
   */
  export type CouponRedemptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CouponRedemptions to delete
     */
    where?: CouponRedemptionWhereInput
  }

  /**
   * CouponRedemption without action
   */
  export type CouponRedemptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponRedemption
     */
    select?: CouponRedemptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponRedemptionInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    menuItemId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    menuItemId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    menuItemId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    menuItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    menuItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    menuItemId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    menuItemId: string
    quantity: number
    price: Decimal
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    menuItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    menuItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    menuItemId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    menuItem?: boolean | MenuItemDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      menuItem: Prisma.$MenuItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      menuItemId: string
      quantity: number
      price: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    menuItem<T extends MenuItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuItemDefaultArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly menuItemId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Metadata
   */

  export type AggregateMetadata = {
    _count: MetadataCountAggregateOutputType | null
    _avg: MetadataAvgAggregateOutputType | null
    _sum: MetadataSumAggregateOutputType | null
    _min: MetadataMinAggregateOutputType | null
    _max: MetadataMaxAggregateOutputType | null
  }

  export type MetadataAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type MetadataSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type MetadataMinAggregateOutputType = {
    id: string | null
    type: $Enums.MetadataType | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetadataMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MetadataType | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetadataCountAggregateOutputType = {
    id: number
    type: number
    name: number
    description: number
    icon: number
    color: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetadataAvgAggregateInputType = {
    sortOrder?: true
  }

  export type MetadataSumAggregateInputType = {
    sortOrder?: true
  }

  export type MetadataMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetadataMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetadataCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metadata to aggregate.
     */
    where?: MetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metadata to fetch.
     */
    orderBy?: MetadataOrderByWithRelationInput | MetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metadata
    **/
    _count?: true | MetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetadataMaxAggregateInputType
  }

  export type GetMetadataAggregateType<T extends MetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetadata[P]>
      : GetScalarType<T[P], AggregateMetadata[P]>
  }




  export type MetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetadataWhereInput
    orderBy?: MetadataOrderByWithAggregationInput | MetadataOrderByWithAggregationInput[]
    by: MetadataScalarFieldEnum[] | MetadataScalarFieldEnum
    having?: MetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetadataCountAggregateInputType | true
    _avg?: MetadataAvgAggregateInputType
    _sum?: MetadataSumAggregateInputType
    _min?: MetadataMinAggregateInputType
    _max?: MetadataMaxAggregateInputType
  }

  export type MetadataGroupByOutputType = {
    id: string
    type: $Enums.MetadataType
    name: string
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: MetadataCountAggregateOutputType | null
    _avg: MetadataAvgAggregateOutputType | null
    _sum: MetadataSumAggregateOutputType | null
    _min: MetadataMinAggregateOutputType | null
    _max: MetadataMaxAggregateOutputType | null
  }

  type GetMetadataGroupByPayload<T extends MetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetadataGroupByOutputType[P]>
            : GetScalarType<T[P], MetadataGroupByOutputType[P]>
        }
      >
    >


  export type MetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metadata"]>

  export type MetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["metadata"]>

  export type MetadataSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metadata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MetadataType
      name: string
      description: string | null
      icon: string | null
      color: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["metadata"]>
    composites: {}
  }

  type MetadataGetPayload<S extends boolean | null | undefined | MetadataDefaultArgs> = $Result.GetResult<Prisma.$MetadataPayload, S>

  type MetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MetadataCountAggregateInputType | true
    }

  export interface MetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metadata'], meta: { name: 'Metadata' } }
    /**
     * Find zero or one Metadata that matches the filter.
     * @param {MetadataFindUniqueArgs} args - Arguments to find a Metadata
     * @example
     * // Get one Metadata
     * const metadata = await prisma.metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetadataFindUniqueArgs>(args: SelectSubset<T, MetadataFindUniqueArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Metadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MetadataFindUniqueOrThrowArgs} args - Arguments to find a Metadata
     * @example
     * // Get one Metadata
     * const metadata = await prisma.metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, MetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataFindFirstArgs} args - Arguments to find a Metadata
     * @example
     * // Get one Metadata
     * const metadata = await prisma.metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetadataFindFirstArgs>(args?: SelectSubset<T, MetadataFindFirstArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Metadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataFindFirstOrThrowArgs} args - Arguments to find a Metadata
     * @example
     * // Get one Metadata
     * const metadata = await prisma.metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, MetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metadata
     * const metadata = await prisma.metadata.findMany()
     * 
     * // Get first 10 Metadata
     * const metadata = await prisma.metadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metadataWithIdOnly = await prisma.metadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetadataFindManyArgs>(args?: SelectSubset<T, MetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Metadata.
     * @param {MetadataCreateArgs} args - Arguments to create a Metadata.
     * @example
     * // Create one Metadata
     * const Metadata = await prisma.metadata.create({
     *   data: {
     *     // ... data to create a Metadata
     *   }
     * })
     * 
     */
    create<T extends MetadataCreateArgs>(args: SelectSubset<T, MetadataCreateArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Metadata.
     * @param {MetadataCreateManyArgs} args - Arguments to create many Metadata.
     * @example
     * // Create many Metadata
     * const metadata = await prisma.metadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetadataCreateManyArgs>(args?: SelectSubset<T, MetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Metadata and returns the data saved in the database.
     * @param {MetadataCreateManyAndReturnArgs} args - Arguments to create many Metadata.
     * @example
     * // Create many Metadata
     * const metadata = await prisma.metadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Metadata and only return the `id`
     * const metadataWithIdOnly = await prisma.metadata.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, MetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Metadata.
     * @param {MetadataDeleteArgs} args - Arguments to delete one Metadata.
     * @example
     * // Delete one Metadata
     * const Metadata = await prisma.metadata.delete({
     *   where: {
     *     // ... filter to delete one Metadata
     *   }
     * })
     * 
     */
    delete<T extends MetadataDeleteArgs>(args: SelectSubset<T, MetadataDeleteArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Metadata.
     * @param {MetadataUpdateArgs} args - Arguments to update one Metadata.
     * @example
     * // Update one Metadata
     * const metadata = await prisma.metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetadataUpdateArgs>(args: SelectSubset<T, MetadataUpdateArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Metadata.
     * @param {MetadataDeleteManyArgs} args - Arguments to filter Metadata to delete.
     * @example
     * // Delete a few Metadata
     * const { count } = await prisma.metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetadataDeleteManyArgs>(args?: SelectSubset<T, MetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metadata
     * const metadata = await prisma.metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetadataUpdateManyArgs>(args: SelectSubset<T, MetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metadata.
     * @param {MetadataUpsertArgs} args - Arguments to update or create a Metadata.
     * @example
     * // Update or create a Metadata
     * const metadata = await prisma.metadata.upsert({
     *   create: {
     *     // ... data to create a Metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metadata we want to update
     *   }
     * })
     */
    upsert<T extends MetadataUpsertArgs>(args: SelectSubset<T, MetadataUpsertArgs<ExtArgs>>): Prisma__MetadataClient<$Result.GetResult<Prisma.$MetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataCountArgs} args - Arguments to filter Metadata to count.
     * @example
     * // Count the number of Metadata
     * const count = await prisma.metadata.count({
     *   where: {
     *     // ... the filter for the Metadata we want to count
     *   }
     * })
    **/
    count<T extends MetadataCountArgs>(
      args?: Subset<T, MetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetadataAggregateArgs>(args: Subset<T, MetadataAggregateArgs>): Prisma.PrismaPromise<GetMetadataAggregateType<T>>

    /**
     * Group by Metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetadataGroupByArgs['orderBy'] }
        : { orderBy?: MetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metadata model
   */
  readonly fields: MetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metadata model
   */ 
  interface MetadataFieldRefs {
    readonly id: FieldRef<"Metadata", 'String'>
    readonly type: FieldRef<"Metadata", 'MetadataType'>
    readonly name: FieldRef<"Metadata", 'String'>
    readonly description: FieldRef<"Metadata", 'String'>
    readonly icon: FieldRef<"Metadata", 'String'>
    readonly color: FieldRef<"Metadata", 'String'>
    readonly isActive: FieldRef<"Metadata", 'Boolean'>
    readonly sortOrder: FieldRef<"Metadata", 'Int'>
    readonly createdAt: FieldRef<"Metadata", 'DateTime'>
    readonly updatedAt: FieldRef<"Metadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Metadata findUnique
   */
  export type MetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter, which Metadata to fetch.
     */
    where: MetadataWhereUniqueInput
  }

  /**
   * Metadata findUniqueOrThrow
   */
  export type MetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter, which Metadata to fetch.
     */
    where: MetadataWhereUniqueInput
  }

  /**
   * Metadata findFirst
   */
  export type MetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter, which Metadata to fetch.
     */
    where?: MetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metadata to fetch.
     */
    orderBy?: MetadataOrderByWithRelationInput | MetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metadata.
     */
    cursor?: MetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metadata.
     */
    distinct?: MetadataScalarFieldEnum | MetadataScalarFieldEnum[]
  }

  /**
   * Metadata findFirstOrThrow
   */
  export type MetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter, which Metadata to fetch.
     */
    where?: MetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metadata to fetch.
     */
    orderBy?: MetadataOrderByWithRelationInput | MetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metadata.
     */
    cursor?: MetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metadata.
     */
    distinct?: MetadataScalarFieldEnum | MetadataScalarFieldEnum[]
  }

  /**
   * Metadata findMany
   */
  export type MetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter, which Metadata to fetch.
     */
    where?: MetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metadata to fetch.
     */
    orderBy?: MetadataOrderByWithRelationInput | MetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metadata.
     */
    cursor?: MetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metadata.
     */
    skip?: number
    distinct?: MetadataScalarFieldEnum | MetadataScalarFieldEnum[]
  }

  /**
   * Metadata create
   */
  export type MetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * The data needed to create a Metadata.
     */
    data: XOR<MetadataCreateInput, MetadataUncheckedCreateInput>
  }

  /**
   * Metadata createMany
   */
  export type MetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metadata.
     */
    data: MetadataCreateManyInput | MetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metadata createManyAndReturn
   */
  export type MetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Metadata.
     */
    data: MetadataCreateManyInput | MetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metadata update
   */
  export type MetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * The data needed to update a Metadata.
     */
    data: XOR<MetadataUpdateInput, MetadataUncheckedUpdateInput>
    /**
     * Choose, which Metadata to update.
     */
    where: MetadataWhereUniqueInput
  }

  /**
   * Metadata updateMany
   */
  export type MetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metadata.
     */
    data: XOR<MetadataUpdateManyMutationInput, MetadataUncheckedUpdateManyInput>
    /**
     * Filter which Metadata to update
     */
    where?: MetadataWhereInput
  }

  /**
   * Metadata upsert
   */
  export type MetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * The filter to search for the Metadata to update in case it exists.
     */
    where: MetadataWhereUniqueInput
    /**
     * In case the Metadata found by the `where` argument doesn't exist, create a new Metadata with this data.
     */
    create: XOR<MetadataCreateInput, MetadataUncheckedCreateInput>
    /**
     * In case the Metadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetadataUpdateInput, MetadataUncheckedUpdateInput>
  }

  /**
   * Metadata delete
   */
  export type MetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
    /**
     * Filter which Metadata to delete.
     */
    where: MetadataWhereUniqueInput
  }

  /**
   * Metadata deleteMany
   */
  export type MetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metadata to delete
     */
    where?: MetadataWhereInput
  }

  /**
   * Metadata without action
   */
  export type MetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metadata
     */
    select?: MetadataSelect<ExtArgs> | null
  }


  /**
   * Model CustomerSegment
   */

  export type AggregateCustomerSegment = {
    _count: CustomerSegmentCountAggregateOutputType | null
    _min: CustomerSegmentMinAggregateOutputType | null
    _max: CustomerSegmentMaxAggregateOutputType | null
  }

  export type CustomerSegmentMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    rulesCombination: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSegmentMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    rulesCombination: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerSegmentCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    description: number
    rulesCombination: number
    rules: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerSegmentMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    rulesCombination?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSegmentMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    rulesCombination?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerSegmentCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    rulesCombination?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerSegmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSegment to aggregate.
     */
    where?: CustomerSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegments to fetch.
     */
    orderBy?: CustomerSegmentOrderByWithRelationInput | CustomerSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerSegments
    **/
    _count?: true | CustomerSegmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerSegmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerSegmentMaxAggregateInputType
  }

  export type GetCustomerSegmentAggregateType<T extends CustomerSegmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerSegment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerSegment[P]>
      : GetScalarType<T[P], AggregateCustomerSegment[P]>
  }




  export type CustomerSegmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerSegmentWhereInput
    orderBy?: CustomerSegmentOrderByWithAggregationInput | CustomerSegmentOrderByWithAggregationInput[]
    by: CustomerSegmentScalarFieldEnum[] | CustomerSegmentScalarFieldEnum
    having?: CustomerSegmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerSegmentCountAggregateInputType | true
    _min?: CustomerSegmentMinAggregateInputType
    _max?: CustomerSegmentMaxAggregateInputType
  }

  export type CustomerSegmentGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    description: string | null
    rulesCombination: string
    rules: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CustomerSegmentCountAggregateOutputType | null
    _min: CustomerSegmentMinAggregateOutputType | null
    _max: CustomerSegmentMaxAggregateOutputType | null
  }

  type GetCustomerSegmentGroupByPayload<T extends CustomerSegmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerSegmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerSegmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerSegmentGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerSegmentGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSegmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    rulesCombination?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    inAppMessages?: boolean | CustomerSegment$inAppMessagesArgs<ExtArgs>
    workflows?: boolean | CustomerSegment$workflowsArgs<ExtArgs>
    segmentIncentives?: boolean | CustomerSegment$segmentIncentivesArgs<ExtArgs>
    pushNotifications?: boolean | CustomerSegment$pushNotificationsArgs<ExtArgs>
    _count?: boolean | CustomerSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerSegment"]>

  export type CustomerSegmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    rulesCombination?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerSegment"]>

  export type CustomerSegmentSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    rulesCombination?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerSegmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    inAppMessages?: boolean | CustomerSegment$inAppMessagesArgs<ExtArgs>
    workflows?: boolean | CustomerSegment$workflowsArgs<ExtArgs>
    segmentIncentives?: boolean | CustomerSegment$segmentIncentivesArgs<ExtArgs>
    pushNotifications?: boolean | CustomerSegment$pushNotificationsArgs<ExtArgs>
    _count?: boolean | CustomerSegmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerSegmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $CustomerSegmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerSegment"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      inAppMessages: Prisma.$InAppMessagePayload<ExtArgs>[]
      workflows: Prisma.$MarketingWorkflowPayload<ExtArgs>[]
      segmentIncentives: Prisma.$SegmentIncentivePayload<ExtArgs>[]
      pushNotifications: Prisma.$PushNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      description: string | null
      rulesCombination: string
      rules: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerSegment"]>
    composites: {}
  }

  type CustomerSegmentGetPayload<S extends boolean | null | undefined | CustomerSegmentDefaultArgs> = $Result.GetResult<Prisma.$CustomerSegmentPayload, S>

  type CustomerSegmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerSegmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerSegmentCountAggregateInputType | true
    }

  export interface CustomerSegmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerSegment'], meta: { name: 'CustomerSegment' } }
    /**
     * Find zero or one CustomerSegment that matches the filter.
     * @param {CustomerSegmentFindUniqueArgs} args - Arguments to find a CustomerSegment
     * @example
     * // Get one CustomerSegment
     * const customerSegment = await prisma.customerSegment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerSegmentFindUniqueArgs>(args: SelectSubset<T, CustomerSegmentFindUniqueArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerSegment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerSegmentFindUniqueOrThrowArgs} args - Arguments to find a CustomerSegment
     * @example
     * // Get one CustomerSegment
     * const customerSegment = await prisma.customerSegment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerSegmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerSegmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerSegment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentFindFirstArgs} args - Arguments to find a CustomerSegment
     * @example
     * // Get one CustomerSegment
     * const customerSegment = await prisma.customerSegment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerSegmentFindFirstArgs>(args?: SelectSubset<T, CustomerSegmentFindFirstArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerSegment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentFindFirstOrThrowArgs} args - Arguments to find a CustomerSegment
     * @example
     * // Get one CustomerSegment
     * const customerSegment = await prisma.customerSegment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerSegmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerSegmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerSegments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerSegments
     * const customerSegments = await prisma.customerSegment.findMany()
     * 
     * // Get first 10 CustomerSegments
     * const customerSegments = await prisma.customerSegment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerSegmentWithIdOnly = await prisma.customerSegment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerSegmentFindManyArgs>(args?: SelectSubset<T, CustomerSegmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerSegment.
     * @param {CustomerSegmentCreateArgs} args - Arguments to create a CustomerSegment.
     * @example
     * // Create one CustomerSegment
     * const CustomerSegment = await prisma.customerSegment.create({
     *   data: {
     *     // ... data to create a CustomerSegment
     *   }
     * })
     * 
     */
    create<T extends CustomerSegmentCreateArgs>(args: SelectSubset<T, CustomerSegmentCreateArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerSegments.
     * @param {CustomerSegmentCreateManyArgs} args - Arguments to create many CustomerSegments.
     * @example
     * // Create many CustomerSegments
     * const customerSegment = await prisma.customerSegment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerSegmentCreateManyArgs>(args?: SelectSubset<T, CustomerSegmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerSegments and returns the data saved in the database.
     * @param {CustomerSegmentCreateManyAndReturnArgs} args - Arguments to create many CustomerSegments.
     * @example
     * // Create many CustomerSegments
     * const customerSegment = await prisma.customerSegment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerSegments and only return the `id`
     * const customerSegmentWithIdOnly = await prisma.customerSegment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerSegmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerSegmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerSegment.
     * @param {CustomerSegmentDeleteArgs} args - Arguments to delete one CustomerSegment.
     * @example
     * // Delete one CustomerSegment
     * const CustomerSegment = await prisma.customerSegment.delete({
     *   where: {
     *     // ... filter to delete one CustomerSegment
     *   }
     * })
     * 
     */
    delete<T extends CustomerSegmentDeleteArgs>(args: SelectSubset<T, CustomerSegmentDeleteArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerSegment.
     * @param {CustomerSegmentUpdateArgs} args - Arguments to update one CustomerSegment.
     * @example
     * // Update one CustomerSegment
     * const customerSegment = await prisma.customerSegment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerSegmentUpdateArgs>(args: SelectSubset<T, CustomerSegmentUpdateArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerSegments.
     * @param {CustomerSegmentDeleteManyArgs} args - Arguments to filter CustomerSegments to delete.
     * @example
     * // Delete a few CustomerSegments
     * const { count } = await prisma.customerSegment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerSegmentDeleteManyArgs>(args?: SelectSubset<T, CustomerSegmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerSegments
     * const customerSegment = await prisma.customerSegment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerSegmentUpdateManyArgs>(args: SelectSubset<T, CustomerSegmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerSegment.
     * @param {CustomerSegmentUpsertArgs} args - Arguments to update or create a CustomerSegment.
     * @example
     * // Update or create a CustomerSegment
     * const customerSegment = await prisma.customerSegment.upsert({
     *   create: {
     *     // ... data to create a CustomerSegment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerSegment we want to update
     *   }
     * })
     */
    upsert<T extends CustomerSegmentUpsertArgs>(args: SelectSubset<T, CustomerSegmentUpsertArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerSegments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentCountArgs} args - Arguments to filter CustomerSegments to count.
     * @example
     * // Count the number of CustomerSegments
     * const count = await prisma.customerSegment.count({
     *   where: {
     *     // ... the filter for the CustomerSegments we want to count
     *   }
     * })
    **/
    count<T extends CustomerSegmentCountArgs>(
      args?: Subset<T, CustomerSegmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerSegmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerSegmentAggregateArgs>(args: Subset<T, CustomerSegmentAggregateArgs>): Prisma.PrismaPromise<GetCustomerSegmentAggregateType<T>>

    /**
     * Group by CustomerSegment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerSegmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerSegmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerSegmentGroupByArgs['orderBy'] }
        : { orderBy?: CustomerSegmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerSegmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerSegmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerSegment model
   */
  readonly fields: CustomerSegmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerSegment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerSegmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inAppMessages<T extends CustomerSegment$inAppMessagesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegment$inAppMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findMany"> | Null>
    workflows<T extends CustomerSegment$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegment$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findMany"> | Null>
    segmentIncentives<T extends CustomerSegment$segmentIncentivesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegment$segmentIncentivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findMany"> | Null>
    pushNotifications<T extends CustomerSegment$pushNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegment$pushNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerSegment model
   */ 
  interface CustomerSegmentFieldRefs {
    readonly id: FieldRef<"CustomerSegment", 'String'>
    readonly organizationId: FieldRef<"CustomerSegment", 'String'>
    readonly name: FieldRef<"CustomerSegment", 'String'>
    readonly description: FieldRef<"CustomerSegment", 'String'>
    readonly rulesCombination: FieldRef<"CustomerSegment", 'String'>
    readonly rules: FieldRef<"CustomerSegment", 'Json'>
    readonly createdAt: FieldRef<"CustomerSegment", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerSegment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerSegment findUnique
   */
  export type CustomerSegmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegment to fetch.
     */
    where: CustomerSegmentWhereUniqueInput
  }

  /**
   * CustomerSegment findUniqueOrThrow
   */
  export type CustomerSegmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegment to fetch.
     */
    where: CustomerSegmentWhereUniqueInput
  }

  /**
   * CustomerSegment findFirst
   */
  export type CustomerSegmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegment to fetch.
     */
    where?: CustomerSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegments to fetch.
     */
    orderBy?: CustomerSegmentOrderByWithRelationInput | CustomerSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSegments.
     */
    cursor?: CustomerSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSegments.
     */
    distinct?: CustomerSegmentScalarFieldEnum | CustomerSegmentScalarFieldEnum[]
  }

  /**
   * CustomerSegment findFirstOrThrow
   */
  export type CustomerSegmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegment to fetch.
     */
    where?: CustomerSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegments to fetch.
     */
    orderBy?: CustomerSegmentOrderByWithRelationInput | CustomerSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerSegments.
     */
    cursor?: CustomerSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerSegments.
     */
    distinct?: CustomerSegmentScalarFieldEnum | CustomerSegmentScalarFieldEnum[]
  }

  /**
   * CustomerSegment findMany
   */
  export type CustomerSegmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter, which CustomerSegments to fetch.
     */
    where?: CustomerSegmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerSegments to fetch.
     */
    orderBy?: CustomerSegmentOrderByWithRelationInput | CustomerSegmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerSegments.
     */
    cursor?: CustomerSegmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerSegments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerSegments.
     */
    skip?: number
    distinct?: CustomerSegmentScalarFieldEnum | CustomerSegmentScalarFieldEnum[]
  }

  /**
   * CustomerSegment create
   */
  export type CustomerSegmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerSegment.
     */
    data: XOR<CustomerSegmentCreateInput, CustomerSegmentUncheckedCreateInput>
  }

  /**
   * CustomerSegment createMany
   */
  export type CustomerSegmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerSegments.
     */
    data: CustomerSegmentCreateManyInput | CustomerSegmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerSegment createManyAndReturn
   */
  export type CustomerSegmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerSegments.
     */
    data: CustomerSegmentCreateManyInput | CustomerSegmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerSegment update
   */
  export type CustomerSegmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerSegment.
     */
    data: XOR<CustomerSegmentUpdateInput, CustomerSegmentUncheckedUpdateInput>
    /**
     * Choose, which CustomerSegment to update.
     */
    where: CustomerSegmentWhereUniqueInput
  }

  /**
   * CustomerSegment updateMany
   */
  export type CustomerSegmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerSegments.
     */
    data: XOR<CustomerSegmentUpdateManyMutationInput, CustomerSegmentUncheckedUpdateManyInput>
    /**
     * Filter which CustomerSegments to update
     */
    where?: CustomerSegmentWhereInput
  }

  /**
   * CustomerSegment upsert
   */
  export type CustomerSegmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerSegment to update in case it exists.
     */
    where: CustomerSegmentWhereUniqueInput
    /**
     * In case the CustomerSegment found by the `where` argument doesn't exist, create a new CustomerSegment with this data.
     */
    create: XOR<CustomerSegmentCreateInput, CustomerSegmentUncheckedCreateInput>
    /**
     * In case the CustomerSegment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerSegmentUpdateInput, CustomerSegmentUncheckedUpdateInput>
  }

  /**
   * CustomerSegment delete
   */
  export type CustomerSegmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
    /**
     * Filter which CustomerSegment to delete.
     */
    where: CustomerSegmentWhereUniqueInput
  }

  /**
   * CustomerSegment deleteMany
   */
  export type CustomerSegmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerSegments to delete
     */
    where?: CustomerSegmentWhereInput
  }

  /**
   * CustomerSegment.inAppMessages
   */
  export type CustomerSegment$inAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    where?: InAppMessageWhereInput
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    cursor?: InAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * CustomerSegment.workflows
   */
  export type CustomerSegment$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    where?: MarketingWorkflowWhereInput
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    cursor?: MarketingWorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingWorkflowScalarFieldEnum | MarketingWorkflowScalarFieldEnum[]
  }

  /**
   * CustomerSegment.segmentIncentives
   */
  export type CustomerSegment$segmentIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    where?: SegmentIncentiveWhereInput
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    cursor?: SegmentIncentiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * CustomerSegment.pushNotifications
   */
  export type CustomerSegment$pushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    where?: PushNotificationWhereInput
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    cursor?: PushNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * CustomerSegment without action
   */
  export type CustomerSegmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerSegment
     */
    select?: CustomerSegmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerSegmentInclude<ExtArgs> | null
  }


  /**
   * Model InAppMessage
   */

  export type AggregateInAppMessage = {
    _count: InAppMessageCountAggregateOutputType | null
    _min: InAppMessageMinAggregateOutputType | null
    _max: InAppMessageMaxAggregateOutputType | null
  }

  export type InAppMessageMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    title: string | null
    body: string | null
    linkUrl: string | null
    displayPlace: string | null
    displayType: string | null
    slotId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    marketingTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InAppMessageMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    title: string | null
    body: string | null
    linkUrl: string | null
    displayPlace: string | null
    displayType: string | null
    slotId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    marketingTemplateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InAppMessageCountAggregateOutputType = {
    id: number
    organizationId: number
    segmentId: number
    title: number
    body: number
    linkUrl: number
    displayPlace: number
    displayType: number
    slotId: number
    startDate: number
    endDate: number
    isActive: number
    marketingTemplateId: number
    templateSnapshot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InAppMessageMinAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    title?: true
    body?: true
    linkUrl?: true
    displayPlace?: true
    displayType?: true
    slotId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    marketingTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InAppMessageMaxAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    title?: true
    body?: true
    linkUrl?: true
    displayPlace?: true
    displayType?: true
    slotId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    marketingTemplateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InAppMessageCountAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    title?: true
    body?: true
    linkUrl?: true
    displayPlace?: true
    displayType?: true
    slotId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    marketingTemplateId?: true
    templateSnapshot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InAppMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppMessage to aggregate.
     */
    where?: InAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessages to fetch.
     */
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InAppMessages
    **/
    _count?: true | InAppMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InAppMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InAppMessageMaxAggregateInputType
  }

  export type GetInAppMessageAggregateType<T extends InAppMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateInAppMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInAppMessage[P]>
      : GetScalarType<T[P], AggregateInAppMessage[P]>
  }




  export type InAppMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageWhereInput
    orderBy?: InAppMessageOrderByWithAggregationInput | InAppMessageOrderByWithAggregationInput[]
    by: InAppMessageScalarFieldEnum[] | InAppMessageScalarFieldEnum
    having?: InAppMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InAppMessageCountAggregateInputType | true
    _min?: InAppMessageMinAggregateInputType
    _max?: InAppMessageMaxAggregateInputType
  }

  export type InAppMessageGroupByOutputType = {
    id: string
    organizationId: string
    segmentId: string
    title: string | null
    body: string
    linkUrl: string | null
    displayPlace: string
    displayType: string
    slotId: string | null
    startDate: Date
    endDate: Date | null
    isActive: boolean
    marketingTemplateId: string | null
    templateSnapshot: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InAppMessageCountAggregateOutputType | null
    _min: InAppMessageMinAggregateOutputType | null
    _max: InAppMessageMaxAggregateOutputType | null
  }

  type GetInAppMessageGroupByPayload<T extends InAppMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InAppMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InAppMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InAppMessageGroupByOutputType[P]>
            : GetScalarType<T[P], InAppMessageGroupByOutputType[P]>
        }
      >
    >


  export type InAppMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    title?: boolean
    body?: boolean
    linkUrl?: boolean
    displayPlace?: boolean
    displayType?: boolean
    slotId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | InAppMessage$marketingTemplateArgs<ExtArgs>
    readBy?: boolean | InAppMessage$readByArgs<ExtArgs>
    _count?: boolean | InAppMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inAppMessage"]>

  export type InAppMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    title?: boolean
    body?: boolean
    linkUrl?: boolean
    displayPlace?: boolean
    displayType?: boolean
    slotId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | InAppMessage$marketingTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["inAppMessage"]>

  export type InAppMessageSelectScalar = {
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    title?: boolean
    body?: boolean
    linkUrl?: boolean
    displayPlace?: boolean
    displayType?: boolean
    slotId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InAppMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | InAppMessage$marketingTemplateArgs<ExtArgs>
    readBy?: boolean | InAppMessage$readByArgs<ExtArgs>
    _count?: boolean | InAppMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InAppMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | InAppMessage$marketingTemplateArgs<ExtArgs>
  }

  export type $InAppMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InAppMessage"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      segment: Prisma.$CustomerSegmentPayload<ExtArgs>
      marketingTemplate: Prisma.$MarketingTemplatePayload<ExtArgs> | null
      readBy: Prisma.$InAppMessageReadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      segmentId: string
      title: string | null
      body: string
      linkUrl: string | null
      displayPlace: string
      displayType: string
      slotId: string | null
      startDate: Date
      endDate: Date | null
      isActive: boolean
      marketingTemplateId: string | null
      templateSnapshot: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inAppMessage"]>
    composites: {}
  }

  type InAppMessageGetPayload<S extends boolean | null | undefined | InAppMessageDefaultArgs> = $Result.GetResult<Prisma.$InAppMessagePayload, S>

  type InAppMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InAppMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InAppMessageCountAggregateInputType | true
    }

  export interface InAppMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InAppMessage'], meta: { name: 'InAppMessage' } }
    /**
     * Find zero or one InAppMessage that matches the filter.
     * @param {InAppMessageFindUniqueArgs} args - Arguments to find a InAppMessage
     * @example
     * // Get one InAppMessage
     * const inAppMessage = await prisma.inAppMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InAppMessageFindUniqueArgs>(args: SelectSubset<T, InAppMessageFindUniqueArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InAppMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InAppMessageFindUniqueOrThrowArgs} args - Arguments to find a InAppMessage
     * @example
     * // Get one InAppMessage
     * const inAppMessage = await prisma.inAppMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InAppMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, InAppMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InAppMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageFindFirstArgs} args - Arguments to find a InAppMessage
     * @example
     * // Get one InAppMessage
     * const inAppMessage = await prisma.inAppMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InAppMessageFindFirstArgs>(args?: SelectSubset<T, InAppMessageFindFirstArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InAppMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageFindFirstOrThrowArgs} args - Arguments to find a InAppMessage
     * @example
     * // Get one InAppMessage
     * const inAppMessage = await prisma.inAppMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InAppMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, InAppMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InAppMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InAppMessages
     * const inAppMessages = await prisma.inAppMessage.findMany()
     * 
     * // Get first 10 InAppMessages
     * const inAppMessages = await prisma.inAppMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inAppMessageWithIdOnly = await prisma.inAppMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InAppMessageFindManyArgs>(args?: SelectSubset<T, InAppMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InAppMessage.
     * @param {InAppMessageCreateArgs} args - Arguments to create a InAppMessage.
     * @example
     * // Create one InAppMessage
     * const InAppMessage = await prisma.inAppMessage.create({
     *   data: {
     *     // ... data to create a InAppMessage
     *   }
     * })
     * 
     */
    create<T extends InAppMessageCreateArgs>(args: SelectSubset<T, InAppMessageCreateArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InAppMessages.
     * @param {InAppMessageCreateManyArgs} args - Arguments to create many InAppMessages.
     * @example
     * // Create many InAppMessages
     * const inAppMessage = await prisma.inAppMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InAppMessageCreateManyArgs>(args?: SelectSubset<T, InAppMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InAppMessages and returns the data saved in the database.
     * @param {InAppMessageCreateManyAndReturnArgs} args - Arguments to create many InAppMessages.
     * @example
     * // Create many InAppMessages
     * const inAppMessage = await prisma.inAppMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InAppMessages and only return the `id`
     * const inAppMessageWithIdOnly = await prisma.inAppMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InAppMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, InAppMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InAppMessage.
     * @param {InAppMessageDeleteArgs} args - Arguments to delete one InAppMessage.
     * @example
     * // Delete one InAppMessage
     * const InAppMessage = await prisma.inAppMessage.delete({
     *   where: {
     *     // ... filter to delete one InAppMessage
     *   }
     * })
     * 
     */
    delete<T extends InAppMessageDeleteArgs>(args: SelectSubset<T, InAppMessageDeleteArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InAppMessage.
     * @param {InAppMessageUpdateArgs} args - Arguments to update one InAppMessage.
     * @example
     * // Update one InAppMessage
     * const inAppMessage = await prisma.inAppMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InAppMessageUpdateArgs>(args: SelectSubset<T, InAppMessageUpdateArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InAppMessages.
     * @param {InAppMessageDeleteManyArgs} args - Arguments to filter InAppMessages to delete.
     * @example
     * // Delete a few InAppMessages
     * const { count } = await prisma.inAppMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InAppMessageDeleteManyArgs>(args?: SelectSubset<T, InAppMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InAppMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InAppMessages
     * const inAppMessage = await prisma.inAppMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InAppMessageUpdateManyArgs>(args: SelectSubset<T, InAppMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InAppMessage.
     * @param {InAppMessageUpsertArgs} args - Arguments to update or create a InAppMessage.
     * @example
     * // Update or create a InAppMessage
     * const inAppMessage = await prisma.inAppMessage.upsert({
     *   create: {
     *     // ... data to create a InAppMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InAppMessage we want to update
     *   }
     * })
     */
    upsert<T extends InAppMessageUpsertArgs>(args: SelectSubset<T, InAppMessageUpsertArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InAppMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageCountArgs} args - Arguments to filter InAppMessages to count.
     * @example
     * // Count the number of InAppMessages
     * const count = await prisma.inAppMessage.count({
     *   where: {
     *     // ... the filter for the InAppMessages we want to count
     *   }
     * })
    **/
    count<T extends InAppMessageCountArgs>(
      args?: Subset<T, InAppMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InAppMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InAppMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InAppMessageAggregateArgs>(args: Subset<T, InAppMessageAggregateArgs>): Prisma.PrismaPromise<GetInAppMessageAggregateType<T>>

    /**
     * Group by InAppMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InAppMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InAppMessageGroupByArgs['orderBy'] }
        : { orderBy?: InAppMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InAppMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInAppMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InAppMessage model
   */
  readonly fields: InAppMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InAppMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InAppMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    segment<T extends CustomerSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegmentDefaultArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    marketingTemplate<T extends InAppMessage$marketingTemplateArgs<ExtArgs> = {}>(args?: Subset<T, InAppMessage$marketingTemplateArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    readBy<T extends InAppMessage$readByArgs<ExtArgs> = {}>(args?: Subset<T, InAppMessage$readByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InAppMessage model
   */ 
  interface InAppMessageFieldRefs {
    readonly id: FieldRef<"InAppMessage", 'String'>
    readonly organizationId: FieldRef<"InAppMessage", 'String'>
    readonly segmentId: FieldRef<"InAppMessage", 'String'>
    readonly title: FieldRef<"InAppMessage", 'String'>
    readonly body: FieldRef<"InAppMessage", 'String'>
    readonly linkUrl: FieldRef<"InAppMessage", 'String'>
    readonly displayPlace: FieldRef<"InAppMessage", 'String'>
    readonly displayType: FieldRef<"InAppMessage", 'String'>
    readonly slotId: FieldRef<"InAppMessage", 'String'>
    readonly startDate: FieldRef<"InAppMessage", 'DateTime'>
    readonly endDate: FieldRef<"InAppMessage", 'DateTime'>
    readonly isActive: FieldRef<"InAppMessage", 'Boolean'>
    readonly marketingTemplateId: FieldRef<"InAppMessage", 'String'>
    readonly templateSnapshot: FieldRef<"InAppMessage", 'Json'>
    readonly createdAt: FieldRef<"InAppMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"InAppMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InAppMessage findUnique
   */
  export type InAppMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessage to fetch.
     */
    where: InAppMessageWhereUniqueInput
  }

  /**
   * InAppMessage findUniqueOrThrow
   */
  export type InAppMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessage to fetch.
     */
    where: InAppMessageWhereUniqueInput
  }

  /**
   * InAppMessage findFirst
   */
  export type InAppMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessage to fetch.
     */
    where?: InAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessages to fetch.
     */
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppMessages.
     */
    cursor?: InAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppMessages.
     */
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * InAppMessage findFirstOrThrow
   */
  export type InAppMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessage to fetch.
     */
    where?: InAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessages to fetch.
     */
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppMessages.
     */
    cursor?: InAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppMessages.
     */
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * InAppMessage findMany
   */
  export type InAppMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessages to fetch.
     */
    where?: InAppMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessages to fetch.
     */
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InAppMessages.
     */
    cursor?: InAppMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessages.
     */
    skip?: number
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * InAppMessage create
   */
  export type InAppMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a InAppMessage.
     */
    data: XOR<InAppMessageCreateInput, InAppMessageUncheckedCreateInput>
  }

  /**
   * InAppMessage createMany
   */
  export type InAppMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InAppMessages.
     */
    data: InAppMessageCreateManyInput | InAppMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InAppMessage createManyAndReturn
   */
  export type InAppMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InAppMessages.
     */
    data: InAppMessageCreateManyInput | InAppMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InAppMessage update
   */
  export type InAppMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a InAppMessage.
     */
    data: XOR<InAppMessageUpdateInput, InAppMessageUncheckedUpdateInput>
    /**
     * Choose, which InAppMessage to update.
     */
    where: InAppMessageWhereUniqueInput
  }

  /**
   * InAppMessage updateMany
   */
  export type InAppMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InAppMessages.
     */
    data: XOR<InAppMessageUpdateManyMutationInput, InAppMessageUncheckedUpdateManyInput>
    /**
     * Filter which InAppMessages to update
     */
    where?: InAppMessageWhereInput
  }

  /**
   * InAppMessage upsert
   */
  export type InAppMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the InAppMessage to update in case it exists.
     */
    where: InAppMessageWhereUniqueInput
    /**
     * In case the InAppMessage found by the `where` argument doesn't exist, create a new InAppMessage with this data.
     */
    create: XOR<InAppMessageCreateInput, InAppMessageUncheckedCreateInput>
    /**
     * In case the InAppMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InAppMessageUpdateInput, InAppMessageUncheckedUpdateInput>
  }

  /**
   * InAppMessage delete
   */
  export type InAppMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    /**
     * Filter which InAppMessage to delete.
     */
    where: InAppMessageWhereUniqueInput
  }

  /**
   * InAppMessage deleteMany
   */
  export type InAppMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppMessages to delete
     */
    where?: InAppMessageWhereInput
  }

  /**
   * InAppMessage.marketingTemplate
   */
  export type InAppMessage$marketingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    where?: MarketingTemplateWhereInput
  }

  /**
   * InAppMessage.readBy
   */
  export type InAppMessage$readByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    where?: InAppMessageReadWhereInput
    orderBy?: InAppMessageReadOrderByWithRelationInput | InAppMessageReadOrderByWithRelationInput[]
    cursor?: InAppMessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InAppMessageReadScalarFieldEnum | InAppMessageReadScalarFieldEnum[]
  }

  /**
   * InAppMessage without action
   */
  export type InAppMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
  }


  /**
   * Model InAppMessageRead
   */

  export type AggregateInAppMessageRead = {
    _count: InAppMessageReadCountAggregateOutputType | null
    _min: InAppMessageReadMinAggregateOutputType | null
    _max: InAppMessageReadMaxAggregateOutputType | null
  }

  export type InAppMessageReadMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type InAppMessageReadMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type InAppMessageReadCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type InAppMessageReadMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type InAppMessageReadMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type InAppMessageReadCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type InAppMessageReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppMessageRead to aggregate.
     */
    where?: InAppMessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessageReads to fetch.
     */
    orderBy?: InAppMessageReadOrderByWithRelationInput | InAppMessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InAppMessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InAppMessageReads
    **/
    _count?: true | InAppMessageReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InAppMessageReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InAppMessageReadMaxAggregateInputType
  }

  export type GetInAppMessageReadAggregateType<T extends InAppMessageReadAggregateArgs> = {
        [P in keyof T & keyof AggregateInAppMessageRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInAppMessageRead[P]>
      : GetScalarType<T[P], AggregateInAppMessageRead[P]>
  }




  export type InAppMessageReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InAppMessageReadWhereInput
    orderBy?: InAppMessageReadOrderByWithAggregationInput | InAppMessageReadOrderByWithAggregationInput[]
    by: InAppMessageReadScalarFieldEnum[] | InAppMessageReadScalarFieldEnum
    having?: InAppMessageReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InAppMessageReadCountAggregateInputType | true
    _min?: InAppMessageReadMinAggregateInputType
    _max?: InAppMessageReadMaxAggregateInputType
  }

  export type InAppMessageReadGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    readAt: Date
    _count: InAppMessageReadCountAggregateOutputType | null
    _min: InAppMessageReadMinAggregateOutputType | null
    _max: InAppMessageReadMaxAggregateOutputType | null
  }

  type GetInAppMessageReadGroupByPayload<T extends InAppMessageReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InAppMessageReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InAppMessageReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InAppMessageReadGroupByOutputType[P]>
            : GetScalarType<T[P], InAppMessageReadGroupByOutputType[P]>
        }
      >
    >


  export type InAppMessageReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | InAppMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inAppMessageRead"]>

  export type InAppMessageReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | InAppMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inAppMessageRead"]>

  export type InAppMessageReadSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type InAppMessageReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | InAppMessageDefaultArgs<ExtArgs>
  }
  export type InAppMessageReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | InAppMessageDefaultArgs<ExtArgs>
  }

  export type $InAppMessageReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InAppMessageRead"
    objects: {
      message: Prisma.$InAppMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["inAppMessageRead"]>
    composites: {}
  }

  type InAppMessageReadGetPayload<S extends boolean | null | undefined | InAppMessageReadDefaultArgs> = $Result.GetResult<Prisma.$InAppMessageReadPayload, S>

  type InAppMessageReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InAppMessageReadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InAppMessageReadCountAggregateInputType | true
    }

  export interface InAppMessageReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InAppMessageRead'], meta: { name: 'InAppMessageRead' } }
    /**
     * Find zero or one InAppMessageRead that matches the filter.
     * @param {InAppMessageReadFindUniqueArgs} args - Arguments to find a InAppMessageRead
     * @example
     * // Get one InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InAppMessageReadFindUniqueArgs>(args: SelectSubset<T, InAppMessageReadFindUniqueArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InAppMessageRead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InAppMessageReadFindUniqueOrThrowArgs} args - Arguments to find a InAppMessageRead
     * @example
     * // Get one InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InAppMessageReadFindUniqueOrThrowArgs>(args: SelectSubset<T, InAppMessageReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InAppMessageRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadFindFirstArgs} args - Arguments to find a InAppMessageRead
     * @example
     * // Get one InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InAppMessageReadFindFirstArgs>(args?: SelectSubset<T, InAppMessageReadFindFirstArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InAppMessageRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadFindFirstOrThrowArgs} args - Arguments to find a InAppMessageRead
     * @example
     * // Get one InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InAppMessageReadFindFirstOrThrowArgs>(args?: SelectSubset<T, InAppMessageReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InAppMessageReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InAppMessageReads
     * const inAppMessageReads = await prisma.inAppMessageRead.findMany()
     * 
     * // Get first 10 InAppMessageReads
     * const inAppMessageReads = await prisma.inAppMessageRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inAppMessageReadWithIdOnly = await prisma.inAppMessageRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InAppMessageReadFindManyArgs>(args?: SelectSubset<T, InAppMessageReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InAppMessageRead.
     * @param {InAppMessageReadCreateArgs} args - Arguments to create a InAppMessageRead.
     * @example
     * // Create one InAppMessageRead
     * const InAppMessageRead = await prisma.inAppMessageRead.create({
     *   data: {
     *     // ... data to create a InAppMessageRead
     *   }
     * })
     * 
     */
    create<T extends InAppMessageReadCreateArgs>(args: SelectSubset<T, InAppMessageReadCreateArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InAppMessageReads.
     * @param {InAppMessageReadCreateManyArgs} args - Arguments to create many InAppMessageReads.
     * @example
     * // Create many InAppMessageReads
     * const inAppMessageRead = await prisma.inAppMessageRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InAppMessageReadCreateManyArgs>(args?: SelectSubset<T, InAppMessageReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InAppMessageReads and returns the data saved in the database.
     * @param {InAppMessageReadCreateManyAndReturnArgs} args - Arguments to create many InAppMessageReads.
     * @example
     * // Create many InAppMessageReads
     * const inAppMessageRead = await prisma.inAppMessageRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InAppMessageReads and only return the `id`
     * const inAppMessageReadWithIdOnly = await prisma.inAppMessageRead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InAppMessageReadCreateManyAndReturnArgs>(args?: SelectSubset<T, InAppMessageReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InAppMessageRead.
     * @param {InAppMessageReadDeleteArgs} args - Arguments to delete one InAppMessageRead.
     * @example
     * // Delete one InAppMessageRead
     * const InAppMessageRead = await prisma.inAppMessageRead.delete({
     *   where: {
     *     // ... filter to delete one InAppMessageRead
     *   }
     * })
     * 
     */
    delete<T extends InAppMessageReadDeleteArgs>(args: SelectSubset<T, InAppMessageReadDeleteArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InAppMessageRead.
     * @param {InAppMessageReadUpdateArgs} args - Arguments to update one InAppMessageRead.
     * @example
     * // Update one InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InAppMessageReadUpdateArgs>(args: SelectSubset<T, InAppMessageReadUpdateArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InAppMessageReads.
     * @param {InAppMessageReadDeleteManyArgs} args - Arguments to filter InAppMessageReads to delete.
     * @example
     * // Delete a few InAppMessageReads
     * const { count } = await prisma.inAppMessageRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InAppMessageReadDeleteManyArgs>(args?: SelectSubset<T, InAppMessageReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InAppMessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InAppMessageReads
     * const inAppMessageRead = await prisma.inAppMessageRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InAppMessageReadUpdateManyArgs>(args: SelectSubset<T, InAppMessageReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InAppMessageRead.
     * @param {InAppMessageReadUpsertArgs} args - Arguments to update or create a InAppMessageRead.
     * @example
     * // Update or create a InAppMessageRead
     * const inAppMessageRead = await prisma.inAppMessageRead.upsert({
     *   create: {
     *     // ... data to create a InAppMessageRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InAppMessageRead we want to update
     *   }
     * })
     */
    upsert<T extends InAppMessageReadUpsertArgs>(args: SelectSubset<T, InAppMessageReadUpsertArgs<ExtArgs>>): Prisma__InAppMessageReadClient<$Result.GetResult<Prisma.$InAppMessageReadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InAppMessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadCountArgs} args - Arguments to filter InAppMessageReads to count.
     * @example
     * // Count the number of InAppMessageReads
     * const count = await prisma.inAppMessageRead.count({
     *   where: {
     *     // ... the filter for the InAppMessageReads we want to count
     *   }
     * })
    **/
    count<T extends InAppMessageReadCountArgs>(
      args?: Subset<T, InAppMessageReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InAppMessageReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InAppMessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InAppMessageReadAggregateArgs>(args: Subset<T, InAppMessageReadAggregateArgs>): Prisma.PrismaPromise<GetInAppMessageReadAggregateType<T>>

    /**
     * Group by InAppMessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InAppMessageReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InAppMessageReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InAppMessageReadGroupByArgs['orderBy'] }
        : { orderBy?: InAppMessageReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InAppMessageReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInAppMessageReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InAppMessageRead model
   */
  readonly fields: InAppMessageReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InAppMessageRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InAppMessageReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends InAppMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InAppMessageDefaultArgs<ExtArgs>>): Prisma__InAppMessageClient<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InAppMessageRead model
   */ 
  interface InAppMessageReadFieldRefs {
    readonly id: FieldRef<"InAppMessageRead", 'String'>
    readonly messageId: FieldRef<"InAppMessageRead", 'String'>
    readonly userId: FieldRef<"InAppMessageRead", 'String'>
    readonly readAt: FieldRef<"InAppMessageRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InAppMessageRead findUnique
   */
  export type InAppMessageReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessageRead to fetch.
     */
    where: InAppMessageReadWhereUniqueInput
  }

  /**
   * InAppMessageRead findUniqueOrThrow
   */
  export type InAppMessageReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessageRead to fetch.
     */
    where: InAppMessageReadWhereUniqueInput
  }

  /**
   * InAppMessageRead findFirst
   */
  export type InAppMessageReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessageRead to fetch.
     */
    where?: InAppMessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessageReads to fetch.
     */
    orderBy?: InAppMessageReadOrderByWithRelationInput | InAppMessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppMessageReads.
     */
    cursor?: InAppMessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppMessageReads.
     */
    distinct?: InAppMessageReadScalarFieldEnum | InAppMessageReadScalarFieldEnum[]
  }

  /**
   * InAppMessageRead findFirstOrThrow
   */
  export type InAppMessageReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessageRead to fetch.
     */
    where?: InAppMessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessageReads to fetch.
     */
    orderBy?: InAppMessageReadOrderByWithRelationInput | InAppMessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InAppMessageReads.
     */
    cursor?: InAppMessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InAppMessageReads.
     */
    distinct?: InAppMessageReadScalarFieldEnum | InAppMessageReadScalarFieldEnum[]
  }

  /**
   * InAppMessageRead findMany
   */
  export type InAppMessageReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter, which InAppMessageReads to fetch.
     */
    where?: InAppMessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InAppMessageReads to fetch.
     */
    orderBy?: InAppMessageReadOrderByWithRelationInput | InAppMessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InAppMessageReads.
     */
    cursor?: InAppMessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InAppMessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InAppMessageReads.
     */
    skip?: number
    distinct?: InAppMessageReadScalarFieldEnum | InAppMessageReadScalarFieldEnum[]
  }

  /**
   * InAppMessageRead create
   */
  export type InAppMessageReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * The data needed to create a InAppMessageRead.
     */
    data: XOR<InAppMessageReadCreateInput, InAppMessageReadUncheckedCreateInput>
  }

  /**
   * InAppMessageRead createMany
   */
  export type InAppMessageReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InAppMessageReads.
     */
    data: InAppMessageReadCreateManyInput | InAppMessageReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InAppMessageRead createManyAndReturn
   */
  export type InAppMessageReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InAppMessageReads.
     */
    data: InAppMessageReadCreateManyInput | InAppMessageReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InAppMessageRead update
   */
  export type InAppMessageReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * The data needed to update a InAppMessageRead.
     */
    data: XOR<InAppMessageReadUpdateInput, InAppMessageReadUncheckedUpdateInput>
    /**
     * Choose, which InAppMessageRead to update.
     */
    where: InAppMessageReadWhereUniqueInput
  }

  /**
   * InAppMessageRead updateMany
   */
  export type InAppMessageReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InAppMessageReads.
     */
    data: XOR<InAppMessageReadUpdateManyMutationInput, InAppMessageReadUncheckedUpdateManyInput>
    /**
     * Filter which InAppMessageReads to update
     */
    where?: InAppMessageReadWhereInput
  }

  /**
   * InAppMessageRead upsert
   */
  export type InAppMessageReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * The filter to search for the InAppMessageRead to update in case it exists.
     */
    where: InAppMessageReadWhereUniqueInput
    /**
     * In case the InAppMessageRead found by the `where` argument doesn't exist, create a new InAppMessageRead with this data.
     */
    create: XOR<InAppMessageReadCreateInput, InAppMessageReadUncheckedCreateInput>
    /**
     * In case the InAppMessageRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InAppMessageReadUpdateInput, InAppMessageReadUncheckedUpdateInput>
  }

  /**
   * InAppMessageRead delete
   */
  export type InAppMessageReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
    /**
     * Filter which InAppMessageRead to delete.
     */
    where: InAppMessageReadWhereUniqueInput
  }

  /**
   * InAppMessageRead deleteMany
   */
  export type InAppMessageReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InAppMessageReads to delete
     */
    where?: InAppMessageReadWhereInput
  }

  /**
   * InAppMessageRead without action
   */
  export type InAppMessageReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessageRead
     */
    select?: InAppMessageReadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageReadInclude<ExtArgs> | null
  }


  /**
   * Model MarketingWorkflow
   */

  export type AggregateMarketingWorkflow = {
    _count: MarketingWorkflowCountAggregateOutputType | null
    _min: MarketingWorkflowMinAggregateOutputType | null
    _max: MarketingWorkflowMaxAggregateOutputType | null
  }

  export type MarketingWorkflowMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    name: string | null
    triggerType: string | null
    actionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingWorkflowMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    name: string | null
    triggerType: string | null
    actionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingWorkflowCountAggregateOutputType = {
    id: number
    organizationId: number
    segmentId: number
    name: number
    triggerType: number
    triggerConfig: number
    actionType: number
    actionConfig: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingWorkflowMinAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    triggerType?: true
    actionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingWorkflowMaxAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    triggerType?: true
    actionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingWorkflowCountAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    triggerType?: true
    triggerConfig?: true
    actionType?: true
    actionConfig?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingWorkflow to aggregate.
     */
    where?: MarketingWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingWorkflows to fetch.
     */
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingWorkflows
    **/
    _count?: true | MarketingWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingWorkflowMaxAggregateInputType
  }

  export type GetMarketingWorkflowAggregateType<T extends MarketingWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingWorkflow[P]>
      : GetScalarType<T[P], AggregateMarketingWorkflow[P]>
  }




  export type MarketingWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingWorkflowWhereInput
    orderBy?: MarketingWorkflowOrderByWithAggregationInput | MarketingWorkflowOrderByWithAggregationInput[]
    by: MarketingWorkflowScalarFieldEnum[] | MarketingWorkflowScalarFieldEnum
    having?: MarketingWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingWorkflowCountAggregateInputType | true
    _min?: MarketingWorkflowMinAggregateInputType
    _max?: MarketingWorkflowMaxAggregateInputType
  }

  export type MarketingWorkflowGroupByOutputType = {
    id: string
    organizationId: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig: JsonValue
    actionType: string
    actionConfig: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MarketingWorkflowCountAggregateOutputType | null
    _min: MarketingWorkflowMinAggregateOutputType | null
    _max: MarketingWorkflowMaxAggregateOutputType | null
  }

  type GetMarketingWorkflowGroupByPayload<T extends MarketingWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type MarketingWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    actionType?: boolean
    actionConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    executionLogs?: boolean | MarketingWorkflow$executionLogsArgs<ExtArgs>
    _count?: boolean | MarketingWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingWorkflow"]>

  export type MarketingWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    actionType?: boolean
    actionConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingWorkflow"]>

  export type MarketingWorkflowSelectScalar = {
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    triggerType?: boolean
    triggerConfig?: boolean
    actionType?: boolean
    actionConfig?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingWorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    executionLogs?: boolean | MarketingWorkflow$executionLogsArgs<ExtArgs>
    _count?: boolean | MarketingWorkflowCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketingWorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
  }

  export type $MarketingWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingWorkflow"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      segment: Prisma.$CustomerSegmentPayload<ExtArgs>
      executionLogs: Prisma.$WorkflowExecutionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      segmentId: string
      name: string
      triggerType: string
      triggerConfig: Prisma.JsonValue
      actionType: string
      actionConfig: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingWorkflow"]>
    composites: {}
  }

  type MarketingWorkflowGetPayload<S extends boolean | null | undefined | MarketingWorkflowDefaultArgs> = $Result.GetResult<Prisma.$MarketingWorkflowPayload, S>

  type MarketingWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketingWorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketingWorkflowCountAggregateInputType | true
    }

  export interface MarketingWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingWorkflow'], meta: { name: 'MarketingWorkflow' } }
    /**
     * Find zero or one MarketingWorkflow that matches the filter.
     * @param {MarketingWorkflowFindUniqueArgs} args - Arguments to find a MarketingWorkflow
     * @example
     * // Get one MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingWorkflowFindUniqueArgs>(args: SelectSubset<T, MarketingWorkflowFindUniqueArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketingWorkflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketingWorkflowFindUniqueOrThrowArgs} args - Arguments to find a MarketingWorkflow
     * @example
     * // Get one MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketingWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowFindFirstArgs} args - Arguments to find a MarketingWorkflow
     * @example
     * // Get one MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingWorkflowFindFirstArgs>(args?: SelectSubset<T, MarketingWorkflowFindFirstArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketingWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowFindFirstOrThrowArgs} args - Arguments to find a MarketingWorkflow
     * @example
     * // Get one MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketingWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingWorkflows
     * const marketingWorkflows = await prisma.marketingWorkflow.findMany()
     * 
     * // Get first 10 MarketingWorkflows
     * const marketingWorkflows = await prisma.marketingWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingWorkflowWithIdOnly = await prisma.marketingWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingWorkflowFindManyArgs>(args?: SelectSubset<T, MarketingWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketingWorkflow.
     * @param {MarketingWorkflowCreateArgs} args - Arguments to create a MarketingWorkflow.
     * @example
     * // Create one MarketingWorkflow
     * const MarketingWorkflow = await prisma.marketingWorkflow.create({
     *   data: {
     *     // ... data to create a MarketingWorkflow
     *   }
     * })
     * 
     */
    create<T extends MarketingWorkflowCreateArgs>(args: SelectSubset<T, MarketingWorkflowCreateArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketingWorkflows.
     * @param {MarketingWorkflowCreateManyArgs} args - Arguments to create many MarketingWorkflows.
     * @example
     * // Create many MarketingWorkflows
     * const marketingWorkflow = await prisma.marketingWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingWorkflowCreateManyArgs>(args?: SelectSubset<T, MarketingWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingWorkflows and returns the data saved in the database.
     * @param {MarketingWorkflowCreateManyAndReturnArgs} args - Arguments to create many MarketingWorkflows.
     * @example
     * // Create many MarketingWorkflows
     * const marketingWorkflow = await prisma.marketingWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingWorkflows and only return the `id`
     * const marketingWorkflowWithIdOnly = await prisma.marketingWorkflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketingWorkflow.
     * @param {MarketingWorkflowDeleteArgs} args - Arguments to delete one MarketingWorkflow.
     * @example
     * // Delete one MarketingWorkflow
     * const MarketingWorkflow = await prisma.marketingWorkflow.delete({
     *   where: {
     *     // ... filter to delete one MarketingWorkflow
     *   }
     * })
     * 
     */
    delete<T extends MarketingWorkflowDeleteArgs>(args: SelectSubset<T, MarketingWorkflowDeleteArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketingWorkflow.
     * @param {MarketingWorkflowUpdateArgs} args - Arguments to update one MarketingWorkflow.
     * @example
     * // Update one MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingWorkflowUpdateArgs>(args: SelectSubset<T, MarketingWorkflowUpdateArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketingWorkflows.
     * @param {MarketingWorkflowDeleteManyArgs} args - Arguments to filter MarketingWorkflows to delete.
     * @example
     * // Delete a few MarketingWorkflows
     * const { count } = await prisma.marketingWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingWorkflowDeleteManyArgs>(args?: SelectSubset<T, MarketingWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingWorkflows
     * const marketingWorkflow = await prisma.marketingWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingWorkflowUpdateManyArgs>(args: SelectSubset<T, MarketingWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketingWorkflow.
     * @param {MarketingWorkflowUpsertArgs} args - Arguments to update or create a MarketingWorkflow.
     * @example
     * // Update or create a MarketingWorkflow
     * const marketingWorkflow = await prisma.marketingWorkflow.upsert({
     *   create: {
     *     // ... data to create a MarketingWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends MarketingWorkflowUpsertArgs>(args: SelectSubset<T, MarketingWorkflowUpsertArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketingWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowCountArgs} args - Arguments to filter MarketingWorkflows to count.
     * @example
     * // Count the number of MarketingWorkflows
     * const count = await prisma.marketingWorkflow.count({
     *   where: {
     *     // ... the filter for the MarketingWorkflows we want to count
     *   }
     * })
    **/
    count<T extends MarketingWorkflowCountArgs>(
      args?: Subset<T, MarketingWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingWorkflowAggregateArgs>(args: Subset<T, MarketingWorkflowAggregateArgs>): Prisma.PrismaPromise<GetMarketingWorkflowAggregateType<T>>

    /**
     * Group by MarketingWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: MarketingWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingWorkflow model
   */
  readonly fields: MarketingWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    segment<T extends CustomerSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegmentDefaultArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    executionLogs<T extends MarketingWorkflow$executionLogsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingWorkflow$executionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingWorkflow model
   */ 
  interface MarketingWorkflowFieldRefs {
    readonly id: FieldRef<"MarketingWorkflow", 'String'>
    readonly organizationId: FieldRef<"MarketingWorkflow", 'String'>
    readonly segmentId: FieldRef<"MarketingWorkflow", 'String'>
    readonly name: FieldRef<"MarketingWorkflow", 'String'>
    readonly triggerType: FieldRef<"MarketingWorkflow", 'String'>
    readonly triggerConfig: FieldRef<"MarketingWorkflow", 'Json'>
    readonly actionType: FieldRef<"MarketingWorkflow", 'String'>
    readonly actionConfig: FieldRef<"MarketingWorkflow", 'Json'>
    readonly isActive: FieldRef<"MarketingWorkflow", 'Boolean'>
    readonly createdAt: FieldRef<"MarketingWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingWorkflow findUnique
   */
  export type MarketingWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which MarketingWorkflow to fetch.
     */
    where: MarketingWorkflowWhereUniqueInput
  }

  /**
   * MarketingWorkflow findUniqueOrThrow
   */
  export type MarketingWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which MarketingWorkflow to fetch.
     */
    where: MarketingWorkflowWhereUniqueInput
  }

  /**
   * MarketingWorkflow findFirst
   */
  export type MarketingWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which MarketingWorkflow to fetch.
     */
    where?: MarketingWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingWorkflows to fetch.
     */
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingWorkflows.
     */
    cursor?: MarketingWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingWorkflows.
     */
    distinct?: MarketingWorkflowScalarFieldEnum | MarketingWorkflowScalarFieldEnum[]
  }

  /**
   * MarketingWorkflow findFirstOrThrow
   */
  export type MarketingWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which MarketingWorkflow to fetch.
     */
    where?: MarketingWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingWorkflows to fetch.
     */
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingWorkflows.
     */
    cursor?: MarketingWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingWorkflows.
     */
    distinct?: MarketingWorkflowScalarFieldEnum | MarketingWorkflowScalarFieldEnum[]
  }

  /**
   * MarketingWorkflow findMany
   */
  export type MarketingWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which MarketingWorkflows to fetch.
     */
    where?: MarketingWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingWorkflows to fetch.
     */
    orderBy?: MarketingWorkflowOrderByWithRelationInput | MarketingWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingWorkflows.
     */
    cursor?: MarketingWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingWorkflows.
     */
    skip?: number
    distinct?: MarketingWorkflowScalarFieldEnum | MarketingWorkflowScalarFieldEnum[]
  }

  /**
   * MarketingWorkflow create
   */
  export type MarketingWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingWorkflow.
     */
    data: XOR<MarketingWorkflowCreateInput, MarketingWorkflowUncheckedCreateInput>
  }

  /**
   * MarketingWorkflow createMany
   */
  export type MarketingWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingWorkflows.
     */
    data: MarketingWorkflowCreateManyInput | MarketingWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingWorkflow createManyAndReturn
   */
  export type MarketingWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketingWorkflows.
     */
    data: MarketingWorkflowCreateManyInput | MarketingWorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketingWorkflow update
   */
  export type MarketingWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingWorkflow.
     */
    data: XOR<MarketingWorkflowUpdateInput, MarketingWorkflowUncheckedUpdateInput>
    /**
     * Choose, which MarketingWorkflow to update.
     */
    where: MarketingWorkflowWhereUniqueInput
  }

  /**
   * MarketingWorkflow updateMany
   */
  export type MarketingWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingWorkflows.
     */
    data: XOR<MarketingWorkflowUpdateManyMutationInput, MarketingWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which MarketingWorkflows to update
     */
    where?: MarketingWorkflowWhereInput
  }

  /**
   * MarketingWorkflow upsert
   */
  export type MarketingWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingWorkflow to update in case it exists.
     */
    where: MarketingWorkflowWhereUniqueInput
    /**
     * In case the MarketingWorkflow found by the `where` argument doesn't exist, create a new MarketingWorkflow with this data.
     */
    create: XOR<MarketingWorkflowCreateInput, MarketingWorkflowUncheckedCreateInput>
    /**
     * In case the MarketingWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingWorkflowUpdateInput, MarketingWorkflowUncheckedUpdateInput>
  }

  /**
   * MarketingWorkflow delete
   */
  export type MarketingWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
    /**
     * Filter which MarketingWorkflow to delete.
     */
    where: MarketingWorkflowWhereUniqueInput
  }

  /**
   * MarketingWorkflow deleteMany
   */
  export type MarketingWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingWorkflows to delete
     */
    where?: MarketingWorkflowWhereInput
  }

  /**
   * MarketingWorkflow.executionLogs
   */
  export type MarketingWorkflow$executionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    where?: WorkflowExecutionLogWhereInput
    orderBy?: WorkflowExecutionLogOrderByWithRelationInput | WorkflowExecutionLogOrderByWithRelationInput[]
    cursor?: WorkflowExecutionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowExecutionLogScalarFieldEnum | WorkflowExecutionLogScalarFieldEnum[]
  }

  /**
   * MarketingWorkflow without action
   */
  export type MarketingWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingWorkflow
     */
    select?: MarketingWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingWorkflowInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowExecutionLog
   */

  export type AggregateWorkflowExecutionLog = {
    _count: WorkflowExecutionLogCountAggregateOutputType | null
    _min: WorkflowExecutionLogMinAggregateOutputType | null
    _max: WorkflowExecutionLogMaxAggregateOutputType | null
  }

  export type WorkflowExecutionLogMinAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executedAt: Date | null
    status: string | null
    message: string | null
  }

  export type WorkflowExecutionLogMaxAggregateOutputType = {
    id: string | null
    workflowId: string | null
    executedAt: Date | null
    status: string | null
    message: string | null
  }

  export type WorkflowExecutionLogCountAggregateOutputType = {
    id: number
    workflowId: number
    executedAt: number
    status: number
    message: number
    details: number
    _all: number
  }


  export type WorkflowExecutionLogMinAggregateInputType = {
    id?: true
    workflowId?: true
    executedAt?: true
    status?: true
    message?: true
  }

  export type WorkflowExecutionLogMaxAggregateInputType = {
    id?: true
    workflowId?: true
    executedAt?: true
    status?: true
    message?: true
  }

  export type WorkflowExecutionLogCountAggregateInputType = {
    id?: true
    workflowId?: true
    executedAt?: true
    status?: true
    message?: true
    details?: true
    _all?: true
  }

  export type WorkflowExecutionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecutionLog to aggregate.
     */
    where?: WorkflowExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutionLogs to fetch.
     */
    orderBy?: WorkflowExecutionLogOrderByWithRelationInput | WorkflowExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowExecutionLogs
    **/
    _count?: true | WorkflowExecutionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowExecutionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowExecutionLogMaxAggregateInputType
  }

  export type GetWorkflowExecutionLogAggregateType<T extends WorkflowExecutionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowExecutionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowExecutionLog[P]>
      : GetScalarType<T[P], AggregateWorkflowExecutionLog[P]>
  }




  export type WorkflowExecutionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowExecutionLogWhereInput
    orderBy?: WorkflowExecutionLogOrderByWithAggregationInput | WorkflowExecutionLogOrderByWithAggregationInput[]
    by: WorkflowExecutionLogScalarFieldEnum[] | WorkflowExecutionLogScalarFieldEnum
    having?: WorkflowExecutionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowExecutionLogCountAggregateInputType | true
    _min?: WorkflowExecutionLogMinAggregateInputType
    _max?: WorkflowExecutionLogMaxAggregateInputType
  }

  export type WorkflowExecutionLogGroupByOutputType = {
    id: string
    workflowId: string
    executedAt: Date
    status: string
    message: string | null
    details: JsonValue | null
    _count: WorkflowExecutionLogCountAggregateOutputType | null
    _min: WorkflowExecutionLogMinAggregateOutputType | null
    _max: WorkflowExecutionLogMaxAggregateOutputType | null
  }

  type GetWorkflowExecutionLogGroupByPayload<T extends WorkflowExecutionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowExecutionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowExecutionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowExecutionLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowExecutionLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowExecutionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executedAt?: boolean
    status?: boolean
    message?: boolean
    details?: boolean
    workflow?: boolean | MarketingWorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecutionLog"]>

  export type WorkflowExecutionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workflowId?: boolean
    executedAt?: boolean
    status?: boolean
    message?: boolean
    details?: boolean
    workflow?: boolean | MarketingWorkflowDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflowExecutionLog"]>

  export type WorkflowExecutionLogSelectScalar = {
    id?: boolean
    workflowId?: boolean
    executedAt?: boolean
    status?: boolean
    message?: boolean
    details?: boolean
  }

  export type WorkflowExecutionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | MarketingWorkflowDefaultArgs<ExtArgs>
  }
  export type WorkflowExecutionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | MarketingWorkflowDefaultArgs<ExtArgs>
  }

  export type $WorkflowExecutionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowExecutionLog"
    objects: {
      workflow: Prisma.$MarketingWorkflowPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workflowId: string
      executedAt: Date
      status: string
      message: string | null
      details: Prisma.JsonValue | null
    }, ExtArgs["result"]["workflowExecutionLog"]>
    composites: {}
  }

  type WorkflowExecutionLogGetPayload<S extends boolean | null | undefined | WorkflowExecutionLogDefaultArgs> = $Result.GetResult<Prisma.$WorkflowExecutionLogPayload, S>

  type WorkflowExecutionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkflowExecutionLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkflowExecutionLogCountAggregateInputType | true
    }

  export interface WorkflowExecutionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowExecutionLog'], meta: { name: 'WorkflowExecutionLog' } }
    /**
     * Find zero or one WorkflowExecutionLog that matches the filter.
     * @param {WorkflowExecutionLogFindUniqueArgs} args - Arguments to find a WorkflowExecutionLog
     * @example
     * // Get one WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowExecutionLogFindUniqueArgs>(args: SelectSubset<T, WorkflowExecutionLogFindUniqueArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkflowExecutionLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkflowExecutionLogFindUniqueOrThrowArgs} args - Arguments to find a WorkflowExecutionLog
     * @example
     * // Get one WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowExecutionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowExecutionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkflowExecutionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogFindFirstArgs} args - Arguments to find a WorkflowExecutionLog
     * @example
     * // Get one WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowExecutionLogFindFirstArgs>(args?: SelectSubset<T, WorkflowExecutionLogFindFirstArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkflowExecutionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogFindFirstOrThrowArgs} args - Arguments to find a WorkflowExecutionLog
     * @example
     * // Get one WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowExecutionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowExecutionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkflowExecutionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowExecutionLogs
     * const workflowExecutionLogs = await prisma.workflowExecutionLog.findMany()
     * 
     * // Get first 10 WorkflowExecutionLogs
     * const workflowExecutionLogs = await prisma.workflowExecutionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowExecutionLogWithIdOnly = await prisma.workflowExecutionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowExecutionLogFindManyArgs>(args?: SelectSubset<T, WorkflowExecutionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkflowExecutionLog.
     * @param {WorkflowExecutionLogCreateArgs} args - Arguments to create a WorkflowExecutionLog.
     * @example
     * // Create one WorkflowExecutionLog
     * const WorkflowExecutionLog = await prisma.workflowExecutionLog.create({
     *   data: {
     *     // ... data to create a WorkflowExecutionLog
     *   }
     * })
     * 
     */
    create<T extends WorkflowExecutionLogCreateArgs>(args: SelectSubset<T, WorkflowExecutionLogCreateArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkflowExecutionLogs.
     * @param {WorkflowExecutionLogCreateManyArgs} args - Arguments to create many WorkflowExecutionLogs.
     * @example
     * // Create many WorkflowExecutionLogs
     * const workflowExecutionLog = await prisma.workflowExecutionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowExecutionLogCreateManyArgs>(args?: SelectSubset<T, WorkflowExecutionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowExecutionLogs and returns the data saved in the database.
     * @param {WorkflowExecutionLogCreateManyAndReturnArgs} args - Arguments to create many WorkflowExecutionLogs.
     * @example
     * // Create many WorkflowExecutionLogs
     * const workflowExecutionLog = await prisma.workflowExecutionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowExecutionLogs and only return the `id`
     * const workflowExecutionLogWithIdOnly = await prisma.workflowExecutionLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowExecutionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowExecutionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WorkflowExecutionLog.
     * @param {WorkflowExecutionLogDeleteArgs} args - Arguments to delete one WorkflowExecutionLog.
     * @example
     * // Delete one WorkflowExecutionLog
     * const WorkflowExecutionLog = await prisma.workflowExecutionLog.delete({
     *   where: {
     *     // ... filter to delete one WorkflowExecutionLog
     *   }
     * })
     * 
     */
    delete<T extends WorkflowExecutionLogDeleteArgs>(args: SelectSubset<T, WorkflowExecutionLogDeleteArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkflowExecutionLog.
     * @param {WorkflowExecutionLogUpdateArgs} args - Arguments to update one WorkflowExecutionLog.
     * @example
     * // Update one WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowExecutionLogUpdateArgs>(args: SelectSubset<T, WorkflowExecutionLogUpdateArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkflowExecutionLogs.
     * @param {WorkflowExecutionLogDeleteManyArgs} args - Arguments to filter WorkflowExecutionLogs to delete.
     * @example
     * // Delete a few WorkflowExecutionLogs
     * const { count } = await prisma.workflowExecutionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowExecutionLogDeleteManyArgs>(args?: SelectSubset<T, WorkflowExecutionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowExecutionLogs
     * const workflowExecutionLog = await prisma.workflowExecutionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowExecutionLogUpdateManyArgs>(args: SelectSubset<T, WorkflowExecutionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkflowExecutionLog.
     * @param {WorkflowExecutionLogUpsertArgs} args - Arguments to update or create a WorkflowExecutionLog.
     * @example
     * // Update or create a WorkflowExecutionLog
     * const workflowExecutionLog = await prisma.workflowExecutionLog.upsert({
     *   create: {
     *     // ... data to create a WorkflowExecutionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowExecutionLog we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowExecutionLogUpsertArgs>(args: SelectSubset<T, WorkflowExecutionLogUpsertArgs<ExtArgs>>): Prisma__WorkflowExecutionLogClient<$Result.GetResult<Prisma.$WorkflowExecutionLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkflowExecutionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogCountArgs} args - Arguments to filter WorkflowExecutionLogs to count.
     * @example
     * // Count the number of WorkflowExecutionLogs
     * const count = await prisma.workflowExecutionLog.count({
     *   where: {
     *     // ... the filter for the WorkflowExecutionLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkflowExecutionLogCountArgs>(
      args?: Subset<T, WorkflowExecutionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowExecutionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowExecutionLogAggregateArgs>(args: Subset<T, WorkflowExecutionLogAggregateArgs>): Prisma.PrismaPromise<GetWorkflowExecutionLogAggregateType<T>>

    /**
     * Group by WorkflowExecutionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowExecutionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowExecutionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowExecutionLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowExecutionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowExecutionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowExecutionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowExecutionLog model
   */
  readonly fields: WorkflowExecutionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowExecutionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowExecutionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workflow<T extends MarketingWorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingWorkflowDefaultArgs<ExtArgs>>): Prisma__MarketingWorkflowClient<$Result.GetResult<Prisma.$MarketingWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowExecutionLog model
   */ 
  interface WorkflowExecutionLogFieldRefs {
    readonly id: FieldRef<"WorkflowExecutionLog", 'String'>
    readonly workflowId: FieldRef<"WorkflowExecutionLog", 'String'>
    readonly executedAt: FieldRef<"WorkflowExecutionLog", 'DateTime'>
    readonly status: FieldRef<"WorkflowExecutionLog", 'String'>
    readonly message: FieldRef<"WorkflowExecutionLog", 'String'>
    readonly details: FieldRef<"WorkflowExecutionLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowExecutionLog findUnique
   */
  export type WorkflowExecutionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutionLog to fetch.
     */
    where: WorkflowExecutionLogWhereUniqueInput
  }

  /**
   * WorkflowExecutionLog findUniqueOrThrow
   */
  export type WorkflowExecutionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutionLog to fetch.
     */
    where: WorkflowExecutionLogWhereUniqueInput
  }

  /**
   * WorkflowExecutionLog findFirst
   */
  export type WorkflowExecutionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutionLog to fetch.
     */
    where?: WorkflowExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutionLogs to fetch.
     */
    orderBy?: WorkflowExecutionLogOrderByWithRelationInput | WorkflowExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutionLogs.
     */
    cursor?: WorkflowExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutionLogs.
     */
    distinct?: WorkflowExecutionLogScalarFieldEnum | WorkflowExecutionLogScalarFieldEnum[]
  }

  /**
   * WorkflowExecutionLog findFirstOrThrow
   */
  export type WorkflowExecutionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutionLog to fetch.
     */
    where?: WorkflowExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutionLogs to fetch.
     */
    orderBy?: WorkflowExecutionLogOrderByWithRelationInput | WorkflowExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowExecutionLogs.
     */
    cursor?: WorkflowExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowExecutionLogs.
     */
    distinct?: WorkflowExecutionLogScalarFieldEnum | WorkflowExecutionLogScalarFieldEnum[]
  }

  /**
   * WorkflowExecutionLog findMany
   */
  export type WorkflowExecutionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowExecutionLogs to fetch.
     */
    where?: WorkflowExecutionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowExecutionLogs to fetch.
     */
    orderBy?: WorkflowExecutionLogOrderByWithRelationInput | WorkflowExecutionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowExecutionLogs.
     */
    cursor?: WorkflowExecutionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowExecutionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowExecutionLogs.
     */
    skip?: number
    distinct?: WorkflowExecutionLogScalarFieldEnum | WorkflowExecutionLogScalarFieldEnum[]
  }

  /**
   * WorkflowExecutionLog create
   */
  export type WorkflowExecutionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowExecutionLog.
     */
    data: XOR<WorkflowExecutionLogCreateInput, WorkflowExecutionLogUncheckedCreateInput>
  }

  /**
   * WorkflowExecutionLog createMany
   */
  export type WorkflowExecutionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowExecutionLogs.
     */
    data: WorkflowExecutionLogCreateManyInput | WorkflowExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkflowExecutionLog createManyAndReturn
   */
  export type WorkflowExecutionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WorkflowExecutionLogs.
     */
    data: WorkflowExecutionLogCreateManyInput | WorkflowExecutionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowExecutionLog update
   */
  export type WorkflowExecutionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowExecutionLog.
     */
    data: XOR<WorkflowExecutionLogUpdateInput, WorkflowExecutionLogUncheckedUpdateInput>
    /**
     * Choose, which WorkflowExecutionLog to update.
     */
    where: WorkflowExecutionLogWhereUniqueInput
  }

  /**
   * WorkflowExecutionLog updateMany
   */
  export type WorkflowExecutionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowExecutionLogs.
     */
    data: XOR<WorkflowExecutionLogUpdateManyMutationInput, WorkflowExecutionLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowExecutionLogs to update
     */
    where?: WorkflowExecutionLogWhereInput
  }

  /**
   * WorkflowExecutionLog upsert
   */
  export type WorkflowExecutionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowExecutionLog to update in case it exists.
     */
    where: WorkflowExecutionLogWhereUniqueInput
    /**
     * In case the WorkflowExecutionLog found by the `where` argument doesn't exist, create a new WorkflowExecutionLog with this data.
     */
    create: XOR<WorkflowExecutionLogCreateInput, WorkflowExecutionLogUncheckedCreateInput>
    /**
     * In case the WorkflowExecutionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowExecutionLogUpdateInput, WorkflowExecutionLogUncheckedUpdateInput>
  }

  /**
   * WorkflowExecutionLog delete
   */
  export type WorkflowExecutionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
    /**
     * Filter which WorkflowExecutionLog to delete.
     */
    where: WorkflowExecutionLogWhereUniqueInput
  }

  /**
   * WorkflowExecutionLog deleteMany
   */
  export type WorkflowExecutionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowExecutionLogs to delete
     */
    where?: WorkflowExecutionLogWhereInput
  }

  /**
   * WorkflowExecutionLog without action
   */
  export type WorkflowExecutionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowExecutionLog
     */
    select?: WorkflowExecutionLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowExecutionLogInclude<ExtArgs> | null
  }


  /**
   * Model SegmentIncentive
   */

  export type AggregateSegmentIncentive = {
    _count: SegmentIncentiveCountAggregateOutputType | null
    _avg: SegmentIncentiveAvgAggregateOutputType | null
    _sum: SegmentIncentiveSumAggregateOutputType | null
    _min: SegmentIncentiveMinAggregateOutputType | null
    _max: SegmentIncentiveMaxAggregateOutputType | null
  }

  export type SegmentIncentiveAvgAggregateOutputType = {
    walletAmount: Decimal | null
    maxGrantsPerUser: number | null
  }

  export type SegmentIncentiveSumAggregateOutputType = {
    walletAmount: Decimal | null
    maxGrantsPerUser: number | null
  }

  export type SegmentIncentiveMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    name: string | null
    incentiveType: string | null
    couponId: string | null
    personaliseCoupon: boolean | null
    walletAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    maxGrantsPerUser: number | null
    displayChannel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentIncentiveMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    name: string | null
    incentiveType: string | null
    couponId: string | null
    personaliseCoupon: boolean | null
    walletAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    maxGrantsPerUser: number | null
    displayChannel: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SegmentIncentiveCountAggregateOutputType = {
    id: number
    organizationId: number
    segmentId: number
    name: number
    incentiveType: number
    couponId: number
    personaliseCoupon: number
    walletAmount: number
    startDate: number
    endDate: number
    maxGrantsPerUser: number
    displayChannel: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SegmentIncentiveAvgAggregateInputType = {
    walletAmount?: true
    maxGrantsPerUser?: true
  }

  export type SegmentIncentiveSumAggregateInputType = {
    walletAmount?: true
    maxGrantsPerUser?: true
  }

  export type SegmentIncentiveMinAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    incentiveType?: true
    couponId?: true
    personaliseCoupon?: true
    walletAmount?: true
    startDate?: true
    endDate?: true
    maxGrantsPerUser?: true
    displayChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentIncentiveMaxAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    incentiveType?: true
    couponId?: true
    personaliseCoupon?: true
    walletAmount?: true
    startDate?: true
    endDate?: true
    maxGrantsPerUser?: true
    displayChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SegmentIncentiveCountAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    name?: true
    incentiveType?: true
    couponId?: true
    personaliseCoupon?: true
    walletAmount?: true
    startDate?: true
    endDate?: true
    maxGrantsPerUser?: true
    displayChannel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SegmentIncentiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SegmentIncentive to aggregate.
     */
    where?: SegmentIncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentIncentives to fetch.
     */
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SegmentIncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentIncentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentIncentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SegmentIncentives
    **/
    _count?: true | SegmentIncentiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SegmentIncentiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SegmentIncentiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SegmentIncentiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SegmentIncentiveMaxAggregateInputType
  }

  export type GetSegmentIncentiveAggregateType<T extends SegmentIncentiveAggregateArgs> = {
        [P in keyof T & keyof AggregateSegmentIncentive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSegmentIncentive[P]>
      : GetScalarType<T[P], AggregateSegmentIncentive[P]>
  }




  export type SegmentIncentiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SegmentIncentiveWhereInput
    orderBy?: SegmentIncentiveOrderByWithAggregationInput | SegmentIncentiveOrderByWithAggregationInput[]
    by: SegmentIncentiveScalarFieldEnum[] | SegmentIncentiveScalarFieldEnum
    having?: SegmentIncentiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SegmentIncentiveCountAggregateInputType | true
    _avg?: SegmentIncentiveAvgAggregateInputType
    _sum?: SegmentIncentiveSumAggregateInputType
    _min?: SegmentIncentiveMinAggregateInputType
    _max?: SegmentIncentiveMaxAggregateInputType
  }

  export type SegmentIncentiveGroupByOutputType = {
    id: string
    organizationId: string
    segmentId: string
    name: string | null
    incentiveType: string
    couponId: string | null
    personaliseCoupon: boolean
    walletAmount: Decimal | null
    startDate: Date
    endDate: Date | null
    maxGrantsPerUser: number
    displayChannel: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SegmentIncentiveCountAggregateOutputType | null
    _avg: SegmentIncentiveAvgAggregateOutputType | null
    _sum: SegmentIncentiveSumAggregateOutputType | null
    _min: SegmentIncentiveMinAggregateOutputType | null
    _max: SegmentIncentiveMaxAggregateOutputType | null
  }

  type GetSegmentIncentiveGroupByPayload<T extends SegmentIncentiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SegmentIncentiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SegmentIncentiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SegmentIncentiveGroupByOutputType[P]>
            : GetScalarType<T[P], SegmentIncentiveGroupByOutputType[P]>
        }
      >
    >


  export type SegmentIncentiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    incentiveType?: boolean
    couponId?: boolean
    personaliseCoupon?: boolean
    walletAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    maxGrantsPerUser?: boolean
    displayChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    coupon?: boolean | SegmentIncentive$couponArgs<ExtArgs>
    grants?: boolean | SegmentIncentive$grantsArgs<ExtArgs>
    _count?: boolean | SegmentIncentiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["segmentIncentive"]>

  export type SegmentIncentiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    incentiveType?: boolean
    couponId?: boolean
    personaliseCoupon?: boolean
    walletAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    maxGrantsPerUser?: boolean
    displayChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    coupon?: boolean | SegmentIncentive$couponArgs<ExtArgs>
  }, ExtArgs["result"]["segmentIncentive"]>

  export type SegmentIncentiveSelectScalar = {
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    name?: boolean
    incentiveType?: boolean
    couponId?: boolean
    personaliseCoupon?: boolean
    walletAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    maxGrantsPerUser?: boolean
    displayChannel?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SegmentIncentiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    coupon?: boolean | SegmentIncentive$couponArgs<ExtArgs>
    grants?: boolean | SegmentIncentive$grantsArgs<ExtArgs>
    _count?: boolean | SegmentIncentiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SegmentIncentiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    coupon?: boolean | SegmentIncentive$couponArgs<ExtArgs>
  }

  export type $SegmentIncentivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SegmentIncentive"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      segment: Prisma.$CustomerSegmentPayload<ExtArgs>
      coupon: Prisma.$CouponPayload<ExtArgs> | null
      grants: Prisma.$IncentiveGrantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      segmentId: string
      name: string | null
      incentiveType: string
      couponId: string | null
      personaliseCoupon: boolean
      walletAmount: Prisma.Decimal | null
      startDate: Date
      endDate: Date | null
      maxGrantsPerUser: number
      displayChannel: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["segmentIncentive"]>
    composites: {}
  }

  type SegmentIncentiveGetPayload<S extends boolean | null | undefined | SegmentIncentiveDefaultArgs> = $Result.GetResult<Prisma.$SegmentIncentivePayload, S>

  type SegmentIncentiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SegmentIncentiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SegmentIncentiveCountAggregateInputType | true
    }

  export interface SegmentIncentiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SegmentIncentive'], meta: { name: 'SegmentIncentive' } }
    /**
     * Find zero or one SegmentIncentive that matches the filter.
     * @param {SegmentIncentiveFindUniqueArgs} args - Arguments to find a SegmentIncentive
     * @example
     * // Get one SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SegmentIncentiveFindUniqueArgs>(args: SelectSubset<T, SegmentIncentiveFindUniqueArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SegmentIncentive that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SegmentIncentiveFindUniqueOrThrowArgs} args - Arguments to find a SegmentIncentive
     * @example
     * // Get one SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SegmentIncentiveFindUniqueOrThrowArgs>(args: SelectSubset<T, SegmentIncentiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SegmentIncentive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveFindFirstArgs} args - Arguments to find a SegmentIncentive
     * @example
     * // Get one SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SegmentIncentiveFindFirstArgs>(args?: SelectSubset<T, SegmentIncentiveFindFirstArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SegmentIncentive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveFindFirstOrThrowArgs} args - Arguments to find a SegmentIncentive
     * @example
     * // Get one SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SegmentIncentiveFindFirstOrThrowArgs>(args?: SelectSubset<T, SegmentIncentiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SegmentIncentives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SegmentIncentives
     * const segmentIncentives = await prisma.segmentIncentive.findMany()
     * 
     * // Get first 10 SegmentIncentives
     * const segmentIncentives = await prisma.segmentIncentive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const segmentIncentiveWithIdOnly = await prisma.segmentIncentive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SegmentIncentiveFindManyArgs>(args?: SelectSubset<T, SegmentIncentiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SegmentIncentive.
     * @param {SegmentIncentiveCreateArgs} args - Arguments to create a SegmentIncentive.
     * @example
     * // Create one SegmentIncentive
     * const SegmentIncentive = await prisma.segmentIncentive.create({
     *   data: {
     *     // ... data to create a SegmentIncentive
     *   }
     * })
     * 
     */
    create<T extends SegmentIncentiveCreateArgs>(args: SelectSubset<T, SegmentIncentiveCreateArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SegmentIncentives.
     * @param {SegmentIncentiveCreateManyArgs} args - Arguments to create many SegmentIncentives.
     * @example
     * // Create many SegmentIncentives
     * const segmentIncentive = await prisma.segmentIncentive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SegmentIncentiveCreateManyArgs>(args?: SelectSubset<T, SegmentIncentiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SegmentIncentives and returns the data saved in the database.
     * @param {SegmentIncentiveCreateManyAndReturnArgs} args - Arguments to create many SegmentIncentives.
     * @example
     * // Create many SegmentIncentives
     * const segmentIncentive = await prisma.segmentIncentive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SegmentIncentives and only return the `id`
     * const segmentIncentiveWithIdOnly = await prisma.segmentIncentive.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SegmentIncentiveCreateManyAndReturnArgs>(args?: SelectSubset<T, SegmentIncentiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SegmentIncentive.
     * @param {SegmentIncentiveDeleteArgs} args - Arguments to delete one SegmentIncentive.
     * @example
     * // Delete one SegmentIncentive
     * const SegmentIncentive = await prisma.segmentIncentive.delete({
     *   where: {
     *     // ... filter to delete one SegmentIncentive
     *   }
     * })
     * 
     */
    delete<T extends SegmentIncentiveDeleteArgs>(args: SelectSubset<T, SegmentIncentiveDeleteArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SegmentIncentive.
     * @param {SegmentIncentiveUpdateArgs} args - Arguments to update one SegmentIncentive.
     * @example
     * // Update one SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SegmentIncentiveUpdateArgs>(args: SelectSubset<T, SegmentIncentiveUpdateArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SegmentIncentives.
     * @param {SegmentIncentiveDeleteManyArgs} args - Arguments to filter SegmentIncentives to delete.
     * @example
     * // Delete a few SegmentIncentives
     * const { count } = await prisma.segmentIncentive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SegmentIncentiveDeleteManyArgs>(args?: SelectSubset<T, SegmentIncentiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SegmentIncentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SegmentIncentives
     * const segmentIncentive = await prisma.segmentIncentive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SegmentIncentiveUpdateManyArgs>(args: SelectSubset<T, SegmentIncentiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SegmentIncentive.
     * @param {SegmentIncentiveUpsertArgs} args - Arguments to update or create a SegmentIncentive.
     * @example
     * // Update or create a SegmentIncentive
     * const segmentIncentive = await prisma.segmentIncentive.upsert({
     *   create: {
     *     // ... data to create a SegmentIncentive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SegmentIncentive we want to update
     *   }
     * })
     */
    upsert<T extends SegmentIncentiveUpsertArgs>(args: SelectSubset<T, SegmentIncentiveUpsertArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SegmentIncentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveCountArgs} args - Arguments to filter SegmentIncentives to count.
     * @example
     * // Count the number of SegmentIncentives
     * const count = await prisma.segmentIncentive.count({
     *   where: {
     *     // ... the filter for the SegmentIncentives we want to count
     *   }
     * })
    **/
    count<T extends SegmentIncentiveCountArgs>(
      args?: Subset<T, SegmentIncentiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SegmentIncentiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SegmentIncentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SegmentIncentiveAggregateArgs>(args: Subset<T, SegmentIncentiveAggregateArgs>): Prisma.PrismaPromise<GetSegmentIncentiveAggregateType<T>>

    /**
     * Group by SegmentIncentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SegmentIncentiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SegmentIncentiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SegmentIncentiveGroupByArgs['orderBy'] }
        : { orderBy?: SegmentIncentiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SegmentIncentiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSegmentIncentiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SegmentIncentive model
   */
  readonly fields: SegmentIncentiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SegmentIncentive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SegmentIncentiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    segment<T extends CustomerSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegmentDefaultArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coupon<T extends SegmentIncentive$couponArgs<ExtArgs> = {}>(args?: Subset<T, SegmentIncentive$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    grants<T extends SegmentIncentive$grantsArgs<ExtArgs> = {}>(args?: Subset<T, SegmentIncentive$grantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SegmentIncentive model
   */ 
  interface SegmentIncentiveFieldRefs {
    readonly id: FieldRef<"SegmentIncentive", 'String'>
    readonly organizationId: FieldRef<"SegmentIncentive", 'String'>
    readonly segmentId: FieldRef<"SegmentIncentive", 'String'>
    readonly name: FieldRef<"SegmentIncentive", 'String'>
    readonly incentiveType: FieldRef<"SegmentIncentive", 'String'>
    readonly couponId: FieldRef<"SegmentIncentive", 'String'>
    readonly personaliseCoupon: FieldRef<"SegmentIncentive", 'Boolean'>
    readonly walletAmount: FieldRef<"SegmentIncentive", 'Decimal'>
    readonly startDate: FieldRef<"SegmentIncentive", 'DateTime'>
    readonly endDate: FieldRef<"SegmentIncentive", 'DateTime'>
    readonly maxGrantsPerUser: FieldRef<"SegmentIncentive", 'Int'>
    readonly displayChannel: FieldRef<"SegmentIncentive", 'String'>
    readonly isActive: FieldRef<"SegmentIncentive", 'Boolean'>
    readonly createdAt: FieldRef<"SegmentIncentive", 'DateTime'>
    readonly updatedAt: FieldRef<"SegmentIncentive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SegmentIncentive findUnique
   */
  export type SegmentIncentiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter, which SegmentIncentive to fetch.
     */
    where: SegmentIncentiveWhereUniqueInput
  }

  /**
   * SegmentIncentive findUniqueOrThrow
   */
  export type SegmentIncentiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter, which SegmentIncentive to fetch.
     */
    where: SegmentIncentiveWhereUniqueInput
  }

  /**
   * SegmentIncentive findFirst
   */
  export type SegmentIncentiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter, which SegmentIncentive to fetch.
     */
    where?: SegmentIncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentIncentives to fetch.
     */
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SegmentIncentives.
     */
    cursor?: SegmentIncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentIncentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentIncentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SegmentIncentives.
     */
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * SegmentIncentive findFirstOrThrow
   */
  export type SegmentIncentiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter, which SegmentIncentive to fetch.
     */
    where?: SegmentIncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentIncentives to fetch.
     */
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SegmentIncentives.
     */
    cursor?: SegmentIncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentIncentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentIncentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SegmentIncentives.
     */
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * SegmentIncentive findMany
   */
  export type SegmentIncentiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter, which SegmentIncentives to fetch.
     */
    where?: SegmentIncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SegmentIncentives to fetch.
     */
    orderBy?: SegmentIncentiveOrderByWithRelationInput | SegmentIncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SegmentIncentives.
     */
    cursor?: SegmentIncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SegmentIncentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SegmentIncentives.
     */
    skip?: number
    distinct?: SegmentIncentiveScalarFieldEnum | SegmentIncentiveScalarFieldEnum[]
  }

  /**
   * SegmentIncentive create
   */
  export type SegmentIncentiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * The data needed to create a SegmentIncentive.
     */
    data: XOR<SegmentIncentiveCreateInput, SegmentIncentiveUncheckedCreateInput>
  }

  /**
   * SegmentIncentive createMany
   */
  export type SegmentIncentiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SegmentIncentives.
     */
    data: SegmentIncentiveCreateManyInput | SegmentIncentiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SegmentIncentive createManyAndReturn
   */
  export type SegmentIncentiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SegmentIncentives.
     */
    data: SegmentIncentiveCreateManyInput | SegmentIncentiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SegmentIncentive update
   */
  export type SegmentIncentiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * The data needed to update a SegmentIncentive.
     */
    data: XOR<SegmentIncentiveUpdateInput, SegmentIncentiveUncheckedUpdateInput>
    /**
     * Choose, which SegmentIncentive to update.
     */
    where: SegmentIncentiveWhereUniqueInput
  }

  /**
   * SegmentIncentive updateMany
   */
  export type SegmentIncentiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SegmentIncentives.
     */
    data: XOR<SegmentIncentiveUpdateManyMutationInput, SegmentIncentiveUncheckedUpdateManyInput>
    /**
     * Filter which SegmentIncentives to update
     */
    where?: SegmentIncentiveWhereInput
  }

  /**
   * SegmentIncentive upsert
   */
  export type SegmentIncentiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * The filter to search for the SegmentIncentive to update in case it exists.
     */
    where: SegmentIncentiveWhereUniqueInput
    /**
     * In case the SegmentIncentive found by the `where` argument doesn't exist, create a new SegmentIncentive with this data.
     */
    create: XOR<SegmentIncentiveCreateInput, SegmentIncentiveUncheckedCreateInput>
    /**
     * In case the SegmentIncentive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SegmentIncentiveUpdateInput, SegmentIncentiveUncheckedUpdateInput>
  }

  /**
   * SegmentIncentive delete
   */
  export type SegmentIncentiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
    /**
     * Filter which SegmentIncentive to delete.
     */
    where: SegmentIncentiveWhereUniqueInput
  }

  /**
   * SegmentIncentive deleteMany
   */
  export type SegmentIncentiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SegmentIncentives to delete
     */
    where?: SegmentIncentiveWhereInput
  }

  /**
   * SegmentIncentive.coupon
   */
  export type SegmentIncentive$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * SegmentIncentive.grants
   */
  export type SegmentIncentive$grantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    where?: IncentiveGrantWhereInput
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    cursor?: IncentiveGrantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * SegmentIncentive without action
   */
  export type SegmentIncentiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SegmentIncentive
     */
    select?: SegmentIncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SegmentIncentiveInclude<ExtArgs> | null
  }


  /**
   * Model MarketingTemplate
   */

  export type AggregateMarketingTemplate = {
    _count: MarketingTemplateCountAggregateOutputType | null
    _min: MarketingTemplateMinAggregateOutputType | null
    _max: MarketingTemplateMaxAggregateOutputType | null
  }

  export type MarketingTemplateMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    type: $Enums.MarketingTemplateType | null
    status: $Enums.MarketingTemplateStatus | null
    isStarter: boolean | null
    isFavorite: boolean | null
    thumbnailUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTemplateMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    type: $Enums.MarketingTemplateType | null
    status: $Enums.MarketingTemplateStatus | null
    isStarter: boolean | null
    isFavorite: boolean | null
    thumbnailUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTemplateCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    type: number
    content: number
    status: number
    isStarter: number
    isFavorite: number
    thumbnailUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingTemplateMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    type?: true
    status?: true
    isStarter?: true
    isFavorite?: true
    thumbnailUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTemplateMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    type?: true
    status?: true
    isStarter?: true
    isFavorite?: true
    thumbnailUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTemplateCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    type?: true
    content?: true
    status?: true
    isStarter?: true
    isFavorite?: true
    thumbnailUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTemplate to aggregate.
     */
    where?: MarketingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTemplates to fetch.
     */
    orderBy?: MarketingTemplateOrderByWithRelationInput | MarketingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingTemplates
    **/
    _count?: true | MarketingTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingTemplateMaxAggregateInputType
  }

  export type GetMarketingTemplateAggregateType<T extends MarketingTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingTemplate[P]>
      : GetScalarType<T[P], AggregateMarketingTemplate[P]>
  }




  export type MarketingTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingTemplateWhereInput
    orderBy?: MarketingTemplateOrderByWithAggregationInput | MarketingTemplateOrderByWithAggregationInput[]
    by: MarketingTemplateScalarFieldEnum[] | MarketingTemplateScalarFieldEnum
    having?: MarketingTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingTemplateCountAggregateInputType | true
    _min?: MarketingTemplateMinAggregateInputType
    _max?: MarketingTemplateMaxAggregateInputType
  }

  export type MarketingTemplateGroupByOutputType = {
    id: string
    organizationId: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content: JsonValue
    status: $Enums.MarketingTemplateStatus
    isStarter: boolean
    isFavorite: boolean
    thumbnailUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingTemplateCountAggregateOutputType | null
    _min: MarketingTemplateMinAggregateOutputType | null
    _max: MarketingTemplateMaxAggregateOutputType | null
  }

  type GetMarketingTemplateGroupByPayload<T extends MarketingTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingTemplateGroupByOutputType[P]>
        }
      >
    >


  export type MarketingTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | MarketingTemplate$organizationArgs<ExtArgs>
    inAppMessages?: boolean | MarketingTemplate$inAppMessagesArgs<ExtArgs>
    promotionBanners?: boolean | MarketingTemplate$promotionBannersArgs<ExtArgs>
    pushNotifications?: boolean | MarketingTemplate$pushNotificationsArgs<ExtArgs>
    _count?: boolean | MarketingTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingTemplate"]>

  export type MarketingTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | MarketingTemplate$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["marketingTemplate"]>

  export type MarketingTemplateSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    type?: boolean
    content?: boolean
    status?: boolean
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | MarketingTemplate$organizationArgs<ExtArgs>
    inAppMessages?: boolean | MarketingTemplate$inAppMessagesArgs<ExtArgs>
    promotionBanners?: boolean | MarketingTemplate$promotionBannersArgs<ExtArgs>
    pushNotifications?: boolean | MarketingTemplate$pushNotificationsArgs<ExtArgs>
    _count?: boolean | MarketingTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketingTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | MarketingTemplate$organizationArgs<ExtArgs>
  }

  export type $MarketingTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingTemplate"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      inAppMessages: Prisma.$InAppMessagePayload<ExtArgs>[]
      promotionBanners: Prisma.$PromotionBannerPayload<ExtArgs>[]
      pushNotifications: Prisma.$PushNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string | null
      name: string
      type: $Enums.MarketingTemplateType
      content: Prisma.JsonValue
      status: $Enums.MarketingTemplateStatus
      isStarter: boolean
      isFavorite: boolean
      thumbnailUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingTemplate"]>
    composites: {}
  }

  type MarketingTemplateGetPayload<S extends boolean | null | undefined | MarketingTemplateDefaultArgs> = $Result.GetResult<Prisma.$MarketingTemplatePayload, S>

  type MarketingTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketingTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketingTemplateCountAggregateInputType | true
    }

  export interface MarketingTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingTemplate'], meta: { name: 'MarketingTemplate' } }
    /**
     * Find zero or one MarketingTemplate that matches the filter.
     * @param {MarketingTemplateFindUniqueArgs} args - Arguments to find a MarketingTemplate
     * @example
     * // Get one MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingTemplateFindUniqueArgs>(args: SelectSubset<T, MarketingTemplateFindUniqueArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketingTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketingTemplateFindUniqueOrThrowArgs} args - Arguments to find a MarketingTemplate
     * @example
     * // Get one MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketingTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateFindFirstArgs} args - Arguments to find a MarketingTemplate
     * @example
     * // Get one MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingTemplateFindFirstArgs>(args?: SelectSubset<T, MarketingTemplateFindFirstArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketingTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateFindFirstOrThrowArgs} args - Arguments to find a MarketingTemplate
     * @example
     * // Get one MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketingTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingTemplates
     * const marketingTemplates = await prisma.marketingTemplate.findMany()
     * 
     * // Get first 10 MarketingTemplates
     * const marketingTemplates = await prisma.marketingTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingTemplateWithIdOnly = await prisma.marketingTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingTemplateFindManyArgs>(args?: SelectSubset<T, MarketingTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketingTemplate.
     * @param {MarketingTemplateCreateArgs} args - Arguments to create a MarketingTemplate.
     * @example
     * // Create one MarketingTemplate
     * const MarketingTemplate = await prisma.marketingTemplate.create({
     *   data: {
     *     // ... data to create a MarketingTemplate
     *   }
     * })
     * 
     */
    create<T extends MarketingTemplateCreateArgs>(args: SelectSubset<T, MarketingTemplateCreateArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketingTemplates.
     * @param {MarketingTemplateCreateManyArgs} args - Arguments to create many MarketingTemplates.
     * @example
     * // Create many MarketingTemplates
     * const marketingTemplate = await prisma.marketingTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingTemplateCreateManyArgs>(args?: SelectSubset<T, MarketingTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingTemplates and returns the data saved in the database.
     * @param {MarketingTemplateCreateManyAndReturnArgs} args - Arguments to create many MarketingTemplates.
     * @example
     * // Create many MarketingTemplates
     * const marketingTemplate = await prisma.marketingTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingTemplates and only return the `id`
     * const marketingTemplateWithIdOnly = await prisma.marketingTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketingTemplate.
     * @param {MarketingTemplateDeleteArgs} args - Arguments to delete one MarketingTemplate.
     * @example
     * // Delete one MarketingTemplate
     * const MarketingTemplate = await prisma.marketingTemplate.delete({
     *   where: {
     *     // ... filter to delete one MarketingTemplate
     *   }
     * })
     * 
     */
    delete<T extends MarketingTemplateDeleteArgs>(args: SelectSubset<T, MarketingTemplateDeleteArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketingTemplate.
     * @param {MarketingTemplateUpdateArgs} args - Arguments to update one MarketingTemplate.
     * @example
     * // Update one MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingTemplateUpdateArgs>(args: SelectSubset<T, MarketingTemplateUpdateArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketingTemplates.
     * @param {MarketingTemplateDeleteManyArgs} args - Arguments to filter MarketingTemplates to delete.
     * @example
     * // Delete a few MarketingTemplates
     * const { count } = await prisma.marketingTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingTemplateDeleteManyArgs>(args?: SelectSubset<T, MarketingTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingTemplates
     * const marketingTemplate = await prisma.marketingTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingTemplateUpdateManyArgs>(args: SelectSubset<T, MarketingTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketingTemplate.
     * @param {MarketingTemplateUpsertArgs} args - Arguments to update or create a MarketingTemplate.
     * @example
     * // Update or create a MarketingTemplate
     * const marketingTemplate = await prisma.marketingTemplate.upsert({
     *   create: {
     *     // ... data to create a MarketingTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingTemplate we want to update
     *   }
     * })
     */
    upsert<T extends MarketingTemplateUpsertArgs>(args: SelectSubset<T, MarketingTemplateUpsertArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketingTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateCountArgs} args - Arguments to filter MarketingTemplates to count.
     * @example
     * // Count the number of MarketingTemplates
     * const count = await prisma.marketingTemplate.count({
     *   where: {
     *     // ... the filter for the MarketingTemplates we want to count
     *   }
     * })
    **/
    count<T extends MarketingTemplateCountArgs>(
      args?: Subset<T, MarketingTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingTemplateAggregateArgs>(args: Subset<T, MarketingTemplateAggregateArgs>): Prisma.PrismaPromise<GetMarketingTemplateAggregateType<T>>

    /**
     * Group by MarketingTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingTemplateGroupByArgs['orderBy'] }
        : { orderBy?: MarketingTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingTemplate model
   */
  readonly fields: MarketingTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends MarketingTemplate$organizationArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTemplate$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inAppMessages<T extends MarketingTemplate$inAppMessagesArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTemplate$inAppMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InAppMessagePayload<ExtArgs>, T, "findMany"> | Null>
    promotionBanners<T extends MarketingTemplate$promotionBannersArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTemplate$promotionBannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionBannerPayload<ExtArgs>, T, "findMany"> | Null>
    pushNotifications<T extends MarketingTemplate$pushNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTemplate$pushNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingTemplate model
   */ 
  interface MarketingTemplateFieldRefs {
    readonly id: FieldRef<"MarketingTemplate", 'String'>
    readonly organizationId: FieldRef<"MarketingTemplate", 'String'>
    readonly name: FieldRef<"MarketingTemplate", 'String'>
    readonly type: FieldRef<"MarketingTemplate", 'MarketingTemplateType'>
    readonly content: FieldRef<"MarketingTemplate", 'Json'>
    readonly status: FieldRef<"MarketingTemplate", 'MarketingTemplateStatus'>
    readonly isStarter: FieldRef<"MarketingTemplate", 'Boolean'>
    readonly isFavorite: FieldRef<"MarketingTemplate", 'Boolean'>
    readonly thumbnailUrl: FieldRef<"MarketingTemplate", 'String'>
    readonly createdAt: FieldRef<"MarketingTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingTemplate findUnique
   */
  export type MarketingTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTemplate to fetch.
     */
    where: MarketingTemplateWhereUniqueInput
  }

  /**
   * MarketingTemplate findUniqueOrThrow
   */
  export type MarketingTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTemplate to fetch.
     */
    where: MarketingTemplateWhereUniqueInput
  }

  /**
   * MarketingTemplate findFirst
   */
  export type MarketingTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTemplate to fetch.
     */
    where?: MarketingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTemplates to fetch.
     */
    orderBy?: MarketingTemplateOrderByWithRelationInput | MarketingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTemplates.
     */
    cursor?: MarketingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTemplates.
     */
    distinct?: MarketingTemplateScalarFieldEnum | MarketingTemplateScalarFieldEnum[]
  }

  /**
   * MarketingTemplate findFirstOrThrow
   */
  export type MarketingTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTemplate to fetch.
     */
    where?: MarketingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTemplates to fetch.
     */
    orderBy?: MarketingTemplateOrderByWithRelationInput | MarketingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTemplates.
     */
    cursor?: MarketingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTemplates.
     */
    distinct?: MarketingTemplateScalarFieldEnum | MarketingTemplateScalarFieldEnum[]
  }

  /**
   * MarketingTemplate findMany
   */
  export type MarketingTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTemplates to fetch.
     */
    where?: MarketingTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTemplates to fetch.
     */
    orderBy?: MarketingTemplateOrderByWithRelationInput | MarketingTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingTemplates.
     */
    cursor?: MarketingTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTemplates.
     */
    skip?: number
    distinct?: MarketingTemplateScalarFieldEnum | MarketingTemplateScalarFieldEnum[]
  }

  /**
   * MarketingTemplate create
   */
  export type MarketingTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingTemplate.
     */
    data: XOR<MarketingTemplateCreateInput, MarketingTemplateUncheckedCreateInput>
  }

  /**
   * MarketingTemplate createMany
   */
  export type MarketingTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingTemplates.
     */
    data: MarketingTemplateCreateManyInput | MarketingTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTemplate createManyAndReturn
   */
  export type MarketingTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketingTemplates.
     */
    data: MarketingTemplateCreateManyInput | MarketingTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketingTemplate update
   */
  export type MarketingTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingTemplate.
     */
    data: XOR<MarketingTemplateUpdateInput, MarketingTemplateUncheckedUpdateInput>
    /**
     * Choose, which MarketingTemplate to update.
     */
    where: MarketingTemplateWhereUniqueInput
  }

  /**
   * MarketingTemplate updateMany
   */
  export type MarketingTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingTemplates.
     */
    data: XOR<MarketingTemplateUpdateManyMutationInput, MarketingTemplateUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTemplates to update
     */
    where?: MarketingTemplateWhereInput
  }

  /**
   * MarketingTemplate upsert
   */
  export type MarketingTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingTemplate to update in case it exists.
     */
    where: MarketingTemplateWhereUniqueInput
    /**
     * In case the MarketingTemplate found by the `where` argument doesn't exist, create a new MarketingTemplate with this data.
     */
    create: XOR<MarketingTemplateCreateInput, MarketingTemplateUncheckedCreateInput>
    /**
     * In case the MarketingTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingTemplateUpdateInput, MarketingTemplateUncheckedUpdateInput>
  }

  /**
   * MarketingTemplate delete
   */
  export type MarketingTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    /**
     * Filter which MarketingTemplate to delete.
     */
    where: MarketingTemplateWhereUniqueInput
  }

  /**
   * MarketingTemplate deleteMany
   */
  export type MarketingTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTemplates to delete
     */
    where?: MarketingTemplateWhereInput
  }

  /**
   * MarketingTemplate.organization
   */
  export type MarketingTemplate$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * MarketingTemplate.inAppMessages
   */
  export type MarketingTemplate$inAppMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InAppMessage
     */
    select?: InAppMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InAppMessageInclude<ExtArgs> | null
    where?: InAppMessageWhereInput
    orderBy?: InAppMessageOrderByWithRelationInput | InAppMessageOrderByWithRelationInput[]
    cursor?: InAppMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InAppMessageScalarFieldEnum | InAppMessageScalarFieldEnum[]
  }

  /**
   * MarketingTemplate.promotionBanners
   */
  export type MarketingTemplate$promotionBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionBanner
     */
    select?: PromotionBannerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionBannerInclude<ExtArgs> | null
    where?: PromotionBannerWhereInput
    orderBy?: PromotionBannerOrderByWithRelationInput | PromotionBannerOrderByWithRelationInput[]
    cursor?: PromotionBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionBannerScalarFieldEnum | PromotionBannerScalarFieldEnum[]
  }

  /**
   * MarketingTemplate.pushNotifications
   */
  export type MarketingTemplate$pushNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    where?: PushNotificationWhereInput
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    cursor?: PushNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * MarketingTemplate without action
   */
  export type MarketingTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
  }


  /**
   * Model PushNotification
   */

  export type AggregatePushNotification = {
    _count: PushNotificationCountAggregateOutputType | null
    _avg: PushNotificationAvgAggregateOutputType | null
    _sum: PushNotificationSumAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  export type PushNotificationAvgAggregateOutputType = {
    totalRecipients: number | null
  }

  export type PushNotificationSumAggregateOutputType = {
    totalRecipients: number | null
  }

  export type PushNotificationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    marketingTemplateId: string | null
    pushTitle: string | null
    pushBody: string | null
    deepLink: string | null
    status: $Enums.PushNotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    totalRecipients: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushNotificationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    segmentId: string | null
    marketingTemplateId: string | null
    pushTitle: string | null
    pushBody: string | null
    deepLink: string | null
    status: $Enums.PushNotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    totalRecipients: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PushNotificationCountAggregateOutputType = {
    id: number
    organizationId: number
    segmentId: number
    marketingTemplateId: number
    templateSnapshot: number
    pushTitle: number
    pushBody: number
    deepLink: number
    status: number
    scheduledAt: number
    sentAt: number
    totalRecipients: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PushNotificationAvgAggregateInputType = {
    totalRecipients?: true
  }

  export type PushNotificationSumAggregateInputType = {
    totalRecipients?: true
  }

  export type PushNotificationMinAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    marketingTemplateId?: true
    pushTitle?: true
    pushBody?: true
    deepLink?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    totalRecipients?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushNotificationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    marketingTemplateId?: true
    pushTitle?: true
    pushBody?: true
    deepLink?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    totalRecipients?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PushNotificationCountAggregateInputType = {
    id?: true
    organizationId?: true
    segmentId?: true
    marketingTemplateId?: true
    templateSnapshot?: true
    pushTitle?: true
    pushBody?: true
    deepLink?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    totalRecipients?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PushNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushNotification to aggregate.
     */
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     */
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushNotifications
    **/
    _count?: true | PushNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PushNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PushNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushNotificationMaxAggregateInputType
  }

  export type GetPushNotificationAggregateType<T extends PushNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePushNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushNotification[P]>
      : GetScalarType<T[P], AggregatePushNotification[P]>
  }




  export type PushNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationWhereInput
    orderBy?: PushNotificationOrderByWithAggregationInput | PushNotificationOrderByWithAggregationInput[]
    by: PushNotificationScalarFieldEnum[] | PushNotificationScalarFieldEnum
    having?: PushNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushNotificationCountAggregateInputType | true
    _avg?: PushNotificationAvgAggregateInputType
    _sum?: PushNotificationSumAggregateInputType
    _min?: PushNotificationMinAggregateInputType
    _max?: PushNotificationMaxAggregateInputType
  }

  export type PushNotificationGroupByOutputType = {
    id: string
    organizationId: string
    segmentId: string
    marketingTemplateId: string | null
    templateSnapshot: JsonValue | null
    pushTitle: string
    pushBody: string
    deepLink: string | null
    status: $Enums.PushNotificationStatus
    scheduledAt: Date | null
    sentAt: Date | null
    totalRecipients: number
    createdAt: Date
    updatedAt: Date
    _count: PushNotificationCountAggregateOutputType | null
    _avg: PushNotificationAvgAggregateOutputType | null
    _sum: PushNotificationSumAggregateOutputType | null
    _min: PushNotificationMinAggregateOutputType | null
    _max: PushNotificationMaxAggregateOutputType | null
  }

  type GetPushNotificationGroupByPayload<T extends PushNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], PushNotificationGroupByOutputType[P]>
        }
      >
    >


  export type PushNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    pushTitle?: boolean
    pushBody?: boolean
    deepLink?: boolean
    status?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    totalRecipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | PushNotification$marketingTemplateArgs<ExtArgs>
    logs?: boolean | PushNotification$logsArgs<ExtArgs>
    _count?: boolean | PushNotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushNotification"]>

  export type PushNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    pushTitle?: boolean
    pushBody?: boolean
    deepLink?: boolean
    status?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    totalRecipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | PushNotification$marketingTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["pushNotification"]>

  export type PushNotificationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    segmentId?: boolean
    marketingTemplateId?: boolean
    templateSnapshot?: boolean
    pushTitle?: boolean
    pushBody?: boolean
    deepLink?: boolean
    status?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    totalRecipients?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PushNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | PushNotification$marketingTemplateArgs<ExtArgs>
    logs?: boolean | PushNotification$logsArgs<ExtArgs>
    _count?: boolean | PushNotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PushNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    segment?: boolean | CustomerSegmentDefaultArgs<ExtArgs>
    marketingTemplate?: boolean | PushNotification$marketingTemplateArgs<ExtArgs>
  }

  export type $PushNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushNotification"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      segment: Prisma.$CustomerSegmentPayload<ExtArgs>
      marketingTemplate: Prisma.$MarketingTemplatePayload<ExtArgs> | null
      logs: Prisma.$PushNotificationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      segmentId: string
      marketingTemplateId: string | null
      templateSnapshot: Prisma.JsonValue | null
      pushTitle: string
      pushBody: string
      deepLink: string | null
      status: $Enums.PushNotificationStatus
      scheduledAt: Date | null
      sentAt: Date | null
      totalRecipients: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pushNotification"]>
    composites: {}
  }

  type PushNotificationGetPayload<S extends boolean | null | undefined | PushNotificationDefaultArgs> = $Result.GetResult<Prisma.$PushNotificationPayload, S>

  type PushNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PushNotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PushNotificationCountAggregateInputType | true
    }

  export interface PushNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushNotification'], meta: { name: 'PushNotification' } }
    /**
     * Find zero or one PushNotification that matches the filter.
     * @param {PushNotificationFindUniqueArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushNotificationFindUniqueArgs>(args: SelectSubset<T, PushNotificationFindUniqueArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PushNotification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PushNotificationFindUniqueOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PushNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PushNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushNotificationFindFirstArgs>(args?: SelectSubset<T, PushNotificationFindFirstArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PushNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindFirstOrThrowArgs} args - Arguments to find a PushNotification
     * @example
     * // Get one PushNotification
     * const pushNotification = await prisma.pushNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PushNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PushNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany()
     * 
     * // Get first 10 PushNotifications
     * const pushNotifications = await prisma.pushNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushNotificationWithIdOnly = await prisma.pushNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushNotificationFindManyArgs>(args?: SelectSubset<T, PushNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PushNotification.
     * @param {PushNotificationCreateArgs} args - Arguments to create a PushNotification.
     * @example
     * // Create one PushNotification
     * const PushNotification = await prisma.pushNotification.create({
     *   data: {
     *     // ... data to create a PushNotification
     *   }
     * })
     * 
     */
    create<T extends PushNotificationCreateArgs>(args: SelectSubset<T, PushNotificationCreateArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PushNotifications.
     * @param {PushNotificationCreateManyArgs} args - Arguments to create many PushNotifications.
     * @example
     * // Create many PushNotifications
     * const pushNotification = await prisma.pushNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushNotificationCreateManyArgs>(args?: SelectSubset<T, PushNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushNotifications and returns the data saved in the database.
     * @param {PushNotificationCreateManyAndReturnArgs} args - Arguments to create many PushNotifications.
     * @example
     * // Create many PushNotifications
     * const pushNotification = await prisma.pushNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushNotifications and only return the `id`
     * const pushNotificationWithIdOnly = await prisma.pushNotification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PushNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PushNotification.
     * @param {PushNotificationDeleteArgs} args - Arguments to delete one PushNotification.
     * @example
     * // Delete one PushNotification
     * const PushNotification = await prisma.pushNotification.delete({
     *   where: {
     *     // ... filter to delete one PushNotification
     *   }
     * })
     * 
     */
    delete<T extends PushNotificationDeleteArgs>(args: SelectSubset<T, PushNotificationDeleteArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PushNotification.
     * @param {PushNotificationUpdateArgs} args - Arguments to update one PushNotification.
     * @example
     * // Update one PushNotification
     * const pushNotification = await prisma.pushNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushNotificationUpdateArgs>(args: SelectSubset<T, PushNotificationUpdateArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PushNotifications.
     * @param {PushNotificationDeleteManyArgs} args - Arguments to filter PushNotifications to delete.
     * @example
     * // Delete a few PushNotifications
     * const { count } = await prisma.pushNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushNotificationDeleteManyArgs>(args?: SelectSubset<T, PushNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushNotifications
     * const pushNotification = await prisma.pushNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushNotificationUpdateManyArgs>(args: SelectSubset<T, PushNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PushNotification.
     * @param {PushNotificationUpsertArgs} args - Arguments to update or create a PushNotification.
     * @example
     * // Update or create a PushNotification
     * const pushNotification = await prisma.pushNotification.upsert({
     *   create: {
     *     // ... data to create a PushNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushNotification we want to update
     *   }
     * })
     */
    upsert<T extends PushNotificationUpsertArgs>(args: SelectSubset<T, PushNotificationUpsertArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PushNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationCountArgs} args - Arguments to filter PushNotifications to count.
     * @example
     * // Count the number of PushNotifications
     * const count = await prisma.pushNotification.count({
     *   where: {
     *     // ... the filter for the PushNotifications we want to count
     *   }
     * })
    **/
    count<T extends PushNotificationCountArgs>(
      args?: Subset<T, PushNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushNotificationAggregateArgs>(args: Subset<T, PushNotificationAggregateArgs>): Prisma.PrismaPromise<GetPushNotificationAggregateType<T>>

    /**
     * Group by PushNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushNotificationGroupByArgs['orderBy'] }
        : { orderBy?: PushNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushNotification model
   */
  readonly fields: PushNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    segment<T extends CustomerSegmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerSegmentDefaultArgs<ExtArgs>>): Prisma__CustomerSegmentClient<$Result.GetResult<Prisma.$CustomerSegmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    marketingTemplate<T extends PushNotification$marketingTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PushNotification$marketingTemplateArgs<ExtArgs>>): Prisma__MarketingTemplateClient<$Result.GetResult<Prisma.$MarketingTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    logs<T extends PushNotification$logsArgs<ExtArgs> = {}>(args?: Subset<T, PushNotification$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushNotification model
   */ 
  interface PushNotificationFieldRefs {
    readonly id: FieldRef<"PushNotification", 'String'>
    readonly organizationId: FieldRef<"PushNotification", 'String'>
    readonly segmentId: FieldRef<"PushNotification", 'String'>
    readonly marketingTemplateId: FieldRef<"PushNotification", 'String'>
    readonly templateSnapshot: FieldRef<"PushNotification", 'Json'>
    readonly pushTitle: FieldRef<"PushNotification", 'String'>
    readonly pushBody: FieldRef<"PushNotification", 'String'>
    readonly deepLink: FieldRef<"PushNotification", 'String'>
    readonly status: FieldRef<"PushNotification", 'PushNotificationStatus'>
    readonly scheduledAt: FieldRef<"PushNotification", 'DateTime'>
    readonly sentAt: FieldRef<"PushNotification", 'DateTime'>
    readonly totalRecipients: FieldRef<"PushNotification", 'Int'>
    readonly createdAt: FieldRef<"PushNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"PushNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushNotification findUnique
   */
  export type PushNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PushNotification to fetch.
     */
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification findUniqueOrThrow
   */
  export type PushNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PushNotification to fetch.
     */
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification findFirst
   */
  export type PushNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PushNotification to fetch.
     */
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     */
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotifications.
     */
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotifications.
     */
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * PushNotification findFirstOrThrow
   */
  export type PushNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PushNotification to fetch.
     */
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     */
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotifications.
     */
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotifications.
     */
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * PushNotification findMany
   */
  export type PushNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter, which PushNotifications to fetch.
     */
    where?: PushNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotifications to fetch.
     */
    orderBy?: PushNotificationOrderByWithRelationInput | PushNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushNotifications.
     */
    cursor?: PushNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotifications.
     */
    skip?: number
    distinct?: PushNotificationScalarFieldEnum | PushNotificationScalarFieldEnum[]
  }

  /**
   * PushNotification create
   */
  export type PushNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a PushNotification.
     */
    data: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
  }

  /**
   * PushNotification createMany
   */
  export type PushNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushNotifications.
     */
    data: PushNotificationCreateManyInput | PushNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushNotification createManyAndReturn
   */
  export type PushNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PushNotifications.
     */
    data: PushNotificationCreateManyInput | PushNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushNotification update
   */
  export type PushNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a PushNotification.
     */
    data: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
    /**
     * Choose, which PushNotification to update.
     */
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification updateMany
   */
  export type PushNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushNotifications.
     */
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyInput>
    /**
     * Filter which PushNotifications to update
     */
    where?: PushNotificationWhereInput
  }

  /**
   * PushNotification upsert
   */
  export type PushNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the PushNotification to update in case it exists.
     */
    where: PushNotificationWhereUniqueInput
    /**
     * In case the PushNotification found by the `where` argument doesn't exist, create a new PushNotification with this data.
     */
    create: XOR<PushNotificationCreateInput, PushNotificationUncheckedCreateInput>
    /**
     * In case the PushNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushNotificationUpdateInput, PushNotificationUncheckedUpdateInput>
  }

  /**
   * PushNotification delete
   */
  export type PushNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
    /**
     * Filter which PushNotification to delete.
     */
    where: PushNotificationWhereUniqueInput
  }

  /**
   * PushNotification deleteMany
   */
  export type PushNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushNotifications to delete
     */
    where?: PushNotificationWhereInput
  }

  /**
   * PushNotification.marketingTemplate
   */
  export type PushNotification$marketingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTemplate
     */
    select?: MarketingTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTemplateInclude<ExtArgs> | null
    where?: MarketingTemplateWhereInput
  }

  /**
   * PushNotification.logs
   */
  export type PushNotification$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    where?: PushNotificationLogWhereInput
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    cursor?: PushNotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushNotificationLogScalarFieldEnum | PushNotificationLogScalarFieldEnum[]
  }

  /**
   * PushNotification without action
   */
  export type PushNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotification
     */
    select?: PushNotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationInclude<ExtArgs> | null
  }


  /**
   * Model PushNotificationLog
   */

  export type AggregatePushNotificationLog = {
    _count: PushNotificationLogCountAggregateOutputType | null
    _min: PushNotificationLogMinAggregateOutputType | null
    _max: PushNotificationLogMaxAggregateOutputType | null
  }

  export type PushNotificationLogMinAggregateOutputType = {
    id: string | null
    pushNotificationId: string | null
    userId: string | null
    status: $Enums.PushDeliveryStatus | null
    sentAt: Date | null
  }

  export type PushNotificationLogMaxAggregateOutputType = {
    id: string | null
    pushNotificationId: string | null
    userId: string | null
    status: $Enums.PushDeliveryStatus | null
    sentAt: Date | null
  }

  export type PushNotificationLogCountAggregateOutputType = {
    id: number
    pushNotificationId: number
    userId: number
    status: number
    sentAt: number
    _all: number
  }


  export type PushNotificationLogMinAggregateInputType = {
    id?: true
    pushNotificationId?: true
    userId?: true
    status?: true
    sentAt?: true
  }

  export type PushNotificationLogMaxAggregateInputType = {
    id?: true
    pushNotificationId?: true
    userId?: true
    status?: true
    sentAt?: true
  }

  export type PushNotificationLogCountAggregateInputType = {
    id?: true
    pushNotificationId?: true
    userId?: true
    status?: true
    sentAt?: true
    _all?: true
  }

  export type PushNotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushNotificationLog to aggregate.
     */
    where?: PushNotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotificationLogs to fetch.
     */
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushNotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushNotificationLogs
    **/
    _count?: true | PushNotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushNotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushNotificationLogMaxAggregateInputType
  }

  export type GetPushNotificationLogAggregateType<T extends PushNotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePushNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushNotificationLog[P]>
      : GetScalarType<T[P], AggregatePushNotificationLog[P]>
  }




  export type PushNotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushNotificationLogWhereInput
    orderBy?: PushNotificationLogOrderByWithAggregationInput | PushNotificationLogOrderByWithAggregationInput[]
    by: PushNotificationLogScalarFieldEnum[] | PushNotificationLogScalarFieldEnum
    having?: PushNotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushNotificationLogCountAggregateInputType | true
    _min?: PushNotificationLogMinAggregateInputType
    _max?: PushNotificationLogMaxAggregateInputType
  }

  export type PushNotificationLogGroupByOutputType = {
    id: string
    pushNotificationId: string
    userId: string
    status: $Enums.PushDeliveryStatus
    sentAt: Date
    _count: PushNotificationLogCountAggregateOutputType | null
    _min: PushNotificationLogMinAggregateOutputType | null
    _max: PushNotificationLogMaxAggregateOutputType | null
  }

  type GetPushNotificationLogGroupByPayload<T extends PushNotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushNotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushNotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushNotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], PushNotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type PushNotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pushNotificationId?: boolean
    userId?: boolean
    status?: boolean
    sentAt?: boolean
    pushNotification?: boolean | PushNotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushNotificationLog"]>

  export type PushNotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pushNotificationId?: boolean
    userId?: boolean
    status?: boolean
    sentAt?: boolean
    pushNotification?: boolean | PushNotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushNotificationLog"]>

  export type PushNotificationLogSelectScalar = {
    id?: boolean
    pushNotificationId?: boolean
    userId?: boolean
    status?: boolean
    sentAt?: boolean
  }

  export type PushNotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pushNotification?: boolean | PushNotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushNotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pushNotification?: boolean | PushNotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushNotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushNotificationLog"
    objects: {
      pushNotification: Prisma.$PushNotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pushNotificationId: string
      userId: string
      status: $Enums.PushDeliveryStatus
      sentAt: Date
    }, ExtArgs["result"]["pushNotificationLog"]>
    composites: {}
  }

  type PushNotificationLogGetPayload<S extends boolean | null | undefined | PushNotificationLogDefaultArgs> = $Result.GetResult<Prisma.$PushNotificationLogPayload, S>

  type PushNotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PushNotificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PushNotificationLogCountAggregateInputType | true
    }

  export interface PushNotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushNotificationLog'], meta: { name: 'PushNotificationLog' } }
    /**
     * Find zero or one PushNotificationLog that matches the filter.
     * @param {PushNotificationLogFindUniqueArgs} args - Arguments to find a PushNotificationLog
     * @example
     * // Get one PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushNotificationLogFindUniqueArgs>(args: SelectSubset<T, PushNotificationLogFindUniqueArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PushNotificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PushNotificationLogFindUniqueOrThrowArgs} args - Arguments to find a PushNotificationLog
     * @example
     * // Get one PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushNotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PushNotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PushNotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogFindFirstArgs} args - Arguments to find a PushNotificationLog
     * @example
     * // Get one PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushNotificationLogFindFirstArgs>(args?: SelectSubset<T, PushNotificationLogFindFirstArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PushNotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogFindFirstOrThrowArgs} args - Arguments to find a PushNotificationLog
     * @example
     * // Get one PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushNotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PushNotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PushNotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushNotificationLogs
     * const pushNotificationLogs = await prisma.pushNotificationLog.findMany()
     * 
     * // Get first 10 PushNotificationLogs
     * const pushNotificationLogs = await prisma.pushNotificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushNotificationLogWithIdOnly = await prisma.pushNotificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushNotificationLogFindManyArgs>(args?: SelectSubset<T, PushNotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PushNotificationLog.
     * @param {PushNotificationLogCreateArgs} args - Arguments to create a PushNotificationLog.
     * @example
     * // Create one PushNotificationLog
     * const PushNotificationLog = await prisma.pushNotificationLog.create({
     *   data: {
     *     // ... data to create a PushNotificationLog
     *   }
     * })
     * 
     */
    create<T extends PushNotificationLogCreateArgs>(args: SelectSubset<T, PushNotificationLogCreateArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PushNotificationLogs.
     * @param {PushNotificationLogCreateManyArgs} args - Arguments to create many PushNotificationLogs.
     * @example
     * // Create many PushNotificationLogs
     * const pushNotificationLog = await prisma.pushNotificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushNotificationLogCreateManyArgs>(args?: SelectSubset<T, PushNotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushNotificationLogs and returns the data saved in the database.
     * @param {PushNotificationLogCreateManyAndReturnArgs} args - Arguments to create many PushNotificationLogs.
     * @example
     * // Create many PushNotificationLogs
     * const pushNotificationLog = await prisma.pushNotificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushNotificationLogs and only return the `id`
     * const pushNotificationLogWithIdOnly = await prisma.pushNotificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushNotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PushNotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PushNotificationLog.
     * @param {PushNotificationLogDeleteArgs} args - Arguments to delete one PushNotificationLog.
     * @example
     * // Delete one PushNotificationLog
     * const PushNotificationLog = await prisma.pushNotificationLog.delete({
     *   where: {
     *     // ... filter to delete one PushNotificationLog
     *   }
     * })
     * 
     */
    delete<T extends PushNotificationLogDeleteArgs>(args: SelectSubset<T, PushNotificationLogDeleteArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PushNotificationLog.
     * @param {PushNotificationLogUpdateArgs} args - Arguments to update one PushNotificationLog.
     * @example
     * // Update one PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushNotificationLogUpdateArgs>(args: SelectSubset<T, PushNotificationLogUpdateArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PushNotificationLogs.
     * @param {PushNotificationLogDeleteManyArgs} args - Arguments to filter PushNotificationLogs to delete.
     * @example
     * // Delete a few PushNotificationLogs
     * const { count } = await prisma.pushNotificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushNotificationLogDeleteManyArgs>(args?: SelectSubset<T, PushNotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushNotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushNotificationLogs
     * const pushNotificationLog = await prisma.pushNotificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushNotificationLogUpdateManyArgs>(args: SelectSubset<T, PushNotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PushNotificationLog.
     * @param {PushNotificationLogUpsertArgs} args - Arguments to update or create a PushNotificationLog.
     * @example
     * // Update or create a PushNotificationLog
     * const pushNotificationLog = await prisma.pushNotificationLog.upsert({
     *   create: {
     *     // ... data to create a PushNotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushNotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends PushNotificationLogUpsertArgs>(args: SelectSubset<T, PushNotificationLogUpsertArgs<ExtArgs>>): Prisma__PushNotificationLogClient<$Result.GetResult<Prisma.$PushNotificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PushNotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogCountArgs} args - Arguments to filter PushNotificationLogs to count.
     * @example
     * // Count the number of PushNotificationLogs
     * const count = await prisma.pushNotificationLog.count({
     *   where: {
     *     // ... the filter for the PushNotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends PushNotificationLogCountArgs>(
      args?: Subset<T, PushNotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushNotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushNotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushNotificationLogAggregateArgs>(args: Subset<T, PushNotificationLogAggregateArgs>): Prisma.PrismaPromise<GetPushNotificationLogAggregateType<T>>

    /**
     * Group by PushNotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushNotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushNotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushNotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: PushNotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushNotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushNotificationLog model
   */
  readonly fields: PushNotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushNotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushNotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pushNotification<T extends PushNotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PushNotificationDefaultArgs<ExtArgs>>): Prisma__PushNotificationClient<$Result.GetResult<Prisma.$PushNotificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushNotificationLog model
   */ 
  interface PushNotificationLogFieldRefs {
    readonly id: FieldRef<"PushNotificationLog", 'String'>
    readonly pushNotificationId: FieldRef<"PushNotificationLog", 'String'>
    readonly userId: FieldRef<"PushNotificationLog", 'String'>
    readonly status: FieldRef<"PushNotificationLog", 'PushDeliveryStatus'>
    readonly sentAt: FieldRef<"PushNotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushNotificationLog findUnique
   */
  export type PushNotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which PushNotificationLog to fetch.
     */
    where: PushNotificationLogWhereUniqueInput
  }

  /**
   * PushNotificationLog findUniqueOrThrow
   */
  export type PushNotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which PushNotificationLog to fetch.
     */
    where: PushNotificationLogWhereUniqueInput
  }

  /**
   * PushNotificationLog findFirst
   */
  export type PushNotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which PushNotificationLog to fetch.
     */
    where?: PushNotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotificationLogs to fetch.
     */
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotificationLogs.
     */
    cursor?: PushNotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotificationLogs.
     */
    distinct?: PushNotificationLogScalarFieldEnum | PushNotificationLogScalarFieldEnum[]
  }

  /**
   * PushNotificationLog findFirstOrThrow
   */
  export type PushNotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which PushNotificationLog to fetch.
     */
    where?: PushNotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotificationLogs to fetch.
     */
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushNotificationLogs.
     */
    cursor?: PushNotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushNotificationLogs.
     */
    distinct?: PushNotificationLogScalarFieldEnum | PushNotificationLogScalarFieldEnum[]
  }

  /**
   * PushNotificationLog findMany
   */
  export type PushNotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which PushNotificationLogs to fetch.
     */
    where?: PushNotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushNotificationLogs to fetch.
     */
    orderBy?: PushNotificationLogOrderByWithRelationInput | PushNotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushNotificationLogs.
     */
    cursor?: PushNotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushNotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushNotificationLogs.
     */
    skip?: number
    distinct?: PushNotificationLogScalarFieldEnum | PushNotificationLogScalarFieldEnum[]
  }

  /**
   * PushNotificationLog create
   */
  export type PushNotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PushNotificationLog.
     */
    data: XOR<PushNotificationLogCreateInput, PushNotificationLogUncheckedCreateInput>
  }

  /**
   * PushNotificationLog createMany
   */
  export type PushNotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushNotificationLogs.
     */
    data: PushNotificationLogCreateManyInput | PushNotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushNotificationLog createManyAndReturn
   */
  export type PushNotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PushNotificationLogs.
     */
    data: PushNotificationLogCreateManyInput | PushNotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushNotificationLog update
   */
  export type PushNotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PushNotificationLog.
     */
    data: XOR<PushNotificationLogUpdateInput, PushNotificationLogUncheckedUpdateInput>
    /**
     * Choose, which PushNotificationLog to update.
     */
    where: PushNotificationLogWhereUniqueInput
  }

  /**
   * PushNotificationLog updateMany
   */
  export type PushNotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushNotificationLogs.
     */
    data: XOR<PushNotificationLogUpdateManyMutationInput, PushNotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which PushNotificationLogs to update
     */
    where?: PushNotificationLogWhereInput
  }

  /**
   * PushNotificationLog upsert
   */
  export type PushNotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PushNotificationLog to update in case it exists.
     */
    where: PushNotificationLogWhereUniqueInput
    /**
     * In case the PushNotificationLog found by the `where` argument doesn't exist, create a new PushNotificationLog with this data.
     */
    create: XOR<PushNotificationLogCreateInput, PushNotificationLogUncheckedCreateInput>
    /**
     * In case the PushNotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushNotificationLogUpdateInput, PushNotificationLogUncheckedUpdateInput>
  }

  /**
   * PushNotificationLog delete
   */
  export type PushNotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
    /**
     * Filter which PushNotificationLog to delete.
     */
    where: PushNotificationLogWhereUniqueInput
  }

  /**
   * PushNotificationLog deleteMany
   */
  export type PushNotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushNotificationLogs to delete
     */
    where?: PushNotificationLogWhereInput
  }

  /**
   * PushNotificationLog without action
   */
  export type PushNotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushNotificationLog
     */
    select?: PushNotificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushNotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dhKey: string | null
    authKey: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dhKey: string | null
    authKey: string | null
    createdAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dhKey: number
    authKey: number
    createdAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dhKey?: true
    authKey?: true
    createdAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dhKey?: true
    authKey?: true
    createdAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dhKey?: true
    authKey?: true
    createdAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dhKey?: boolean
    authKey?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dhKey?: boolean
    authKey?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dhKey?: boolean
    authKey?: boolean
    createdAt?: boolean
  }

  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      endpoint: string
      p256dhKey: string
      authKey: string
      createdAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */ 
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dhKey: FieldRef<"PushSubscription", 'String'>
    readonly authKey: FieldRef<"PushSubscription", 'String'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PaymentProviderConfig
   */

  export type AggregatePaymentProviderConfig = {
    _count: PaymentProviderConfigCountAggregateOutputType | null
    _min: PaymentProviderConfigMinAggregateOutputType | null
    _max: PaymentProviderConfigMaxAggregateOutputType | null
  }

  export type PaymentProviderConfigMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    provider: string | null
    isEnabled: boolean | null
    configJson: string | null
    updatedAt: Date | null
    updatedById: string | null
  }

  export type PaymentProviderConfigMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    provider: string | null
    isEnabled: boolean | null
    configJson: string | null
    updatedAt: Date | null
    updatedById: string | null
  }

  export type PaymentProviderConfigCountAggregateOutputType = {
    id: number
    organizationId: number
    provider: number
    isEnabled: number
    configJson: number
    updatedAt: number
    updatedById: number
    _all: number
  }


  export type PaymentProviderConfigMinAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    isEnabled?: true
    configJson?: true
    updatedAt?: true
    updatedById?: true
  }

  export type PaymentProviderConfigMaxAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    isEnabled?: true
    configJson?: true
    updatedAt?: true
    updatedById?: true
  }

  export type PaymentProviderConfigCountAggregateInputType = {
    id?: true
    organizationId?: true
    provider?: true
    isEnabled?: true
    configJson?: true
    updatedAt?: true
    updatedById?: true
    _all?: true
  }

  export type PaymentProviderConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProviderConfig to aggregate.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentProviderConfigs
    **/
    _count?: true | PaymentProviderConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentProviderConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentProviderConfigMaxAggregateInputType
  }

  export type GetPaymentProviderConfigAggregateType<T extends PaymentProviderConfigAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentProviderConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentProviderConfig[P]>
      : GetScalarType<T[P], AggregatePaymentProviderConfig[P]>
  }




  export type PaymentProviderConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentProviderConfigWhereInput
    orderBy?: PaymentProviderConfigOrderByWithAggregationInput | PaymentProviderConfigOrderByWithAggregationInput[]
    by: PaymentProviderConfigScalarFieldEnum[] | PaymentProviderConfigScalarFieldEnum
    having?: PaymentProviderConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentProviderConfigCountAggregateInputType | true
    _min?: PaymentProviderConfigMinAggregateInputType
    _max?: PaymentProviderConfigMaxAggregateInputType
  }

  export type PaymentProviderConfigGroupByOutputType = {
    id: string
    organizationId: string
    provider: string
    isEnabled: boolean
    configJson: string
    updatedAt: Date
    updatedById: string | null
    _count: PaymentProviderConfigCountAggregateOutputType | null
    _min: PaymentProviderConfigMinAggregateOutputType | null
    _max: PaymentProviderConfigMaxAggregateOutputType | null
  }

  type GetPaymentProviderConfigGroupByPayload<T extends PaymentProviderConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentProviderConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentProviderConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentProviderConfigGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentProviderConfigGroupByOutputType[P]>
        }
      >
    >


  export type PaymentProviderConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    isEnabled?: boolean
    configJson?: boolean
    updatedAt?: boolean
    updatedById?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updatedBy?: boolean | PaymentProviderConfig$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentProviderConfig"]>

  export type PaymentProviderConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    isEnabled?: boolean
    configJson?: boolean
    updatedAt?: boolean
    updatedById?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updatedBy?: boolean | PaymentProviderConfig$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["paymentProviderConfig"]>

  export type PaymentProviderConfigSelectScalar = {
    id?: boolean
    organizationId?: boolean
    provider?: boolean
    isEnabled?: boolean
    configJson?: boolean
    updatedAt?: boolean
    updatedById?: boolean
  }

  export type PaymentProviderConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updatedBy?: boolean | PaymentProviderConfig$updatedByArgs<ExtArgs>
  }
  export type PaymentProviderConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    updatedBy?: boolean | PaymentProviderConfig$updatedByArgs<ExtArgs>
  }

  export type $PaymentProviderConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentProviderConfig"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      provider: string
      isEnabled: boolean
      configJson: string
      updatedAt: Date
      updatedById: string | null
    }, ExtArgs["result"]["paymentProviderConfig"]>
    composites: {}
  }

  type PaymentProviderConfigGetPayload<S extends boolean | null | undefined | PaymentProviderConfigDefaultArgs> = $Result.GetResult<Prisma.$PaymentProviderConfigPayload, S>

  type PaymentProviderConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentProviderConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentProviderConfigCountAggregateInputType | true
    }

  export interface PaymentProviderConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentProviderConfig'], meta: { name: 'PaymentProviderConfig' } }
    /**
     * Find zero or one PaymentProviderConfig that matches the filter.
     * @param {PaymentProviderConfigFindUniqueArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentProviderConfigFindUniqueArgs>(args: SelectSubset<T, PaymentProviderConfigFindUniqueArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentProviderConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentProviderConfigFindUniqueOrThrowArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentProviderConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentProviderConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindFirstArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentProviderConfigFindFirstArgs>(args?: SelectSubset<T, PaymentProviderConfigFindFirstArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentProviderConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindFirstOrThrowArgs} args - Arguments to find a PaymentProviderConfig
     * @example
     * // Get one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentProviderConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentProviderConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentProviderConfigs
     * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany()
     * 
     * // Get first 10 PaymentProviderConfigs
     * const paymentProviderConfigs = await prisma.paymentProviderConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentProviderConfigWithIdOnly = await prisma.paymentProviderConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentProviderConfigFindManyArgs>(args?: SelectSubset<T, PaymentProviderConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentProviderConfig.
     * @param {PaymentProviderConfigCreateArgs} args - Arguments to create a PaymentProviderConfig.
     * @example
     * // Create one PaymentProviderConfig
     * const PaymentProviderConfig = await prisma.paymentProviderConfig.create({
     *   data: {
     *     // ... data to create a PaymentProviderConfig
     *   }
     * })
     * 
     */
    create<T extends PaymentProviderConfigCreateArgs>(args: SelectSubset<T, PaymentProviderConfigCreateArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentProviderConfigs.
     * @param {PaymentProviderConfigCreateManyArgs} args - Arguments to create many PaymentProviderConfigs.
     * @example
     * // Create many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentProviderConfigCreateManyArgs>(args?: SelectSubset<T, PaymentProviderConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentProviderConfigs and returns the data saved in the database.
     * @param {PaymentProviderConfigCreateManyAndReturnArgs} args - Arguments to create many PaymentProviderConfigs.
     * @example
     * // Create many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentProviderConfigs and only return the `id`
     * const paymentProviderConfigWithIdOnly = await prisma.paymentProviderConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentProviderConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentProviderConfig.
     * @param {PaymentProviderConfigDeleteArgs} args - Arguments to delete one PaymentProviderConfig.
     * @example
     * // Delete one PaymentProviderConfig
     * const PaymentProviderConfig = await prisma.paymentProviderConfig.delete({
     *   where: {
     *     // ... filter to delete one PaymentProviderConfig
     *   }
     * })
     * 
     */
    delete<T extends PaymentProviderConfigDeleteArgs>(args: SelectSubset<T, PaymentProviderConfigDeleteArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentProviderConfig.
     * @param {PaymentProviderConfigUpdateArgs} args - Arguments to update one PaymentProviderConfig.
     * @example
     * // Update one PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentProviderConfigUpdateArgs>(args: SelectSubset<T, PaymentProviderConfigUpdateArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentProviderConfigs.
     * @param {PaymentProviderConfigDeleteManyArgs} args - Arguments to filter PaymentProviderConfigs to delete.
     * @example
     * // Delete a few PaymentProviderConfigs
     * const { count } = await prisma.paymentProviderConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentProviderConfigDeleteManyArgs>(args?: SelectSubset<T, PaymentProviderConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentProviderConfigs
     * const paymentProviderConfig = await prisma.paymentProviderConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentProviderConfigUpdateManyArgs>(args: SelectSubset<T, PaymentProviderConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentProviderConfig.
     * @param {PaymentProviderConfigUpsertArgs} args - Arguments to update or create a PaymentProviderConfig.
     * @example
     * // Update or create a PaymentProviderConfig
     * const paymentProviderConfig = await prisma.paymentProviderConfig.upsert({
     *   create: {
     *     // ... data to create a PaymentProviderConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentProviderConfig we want to update
     *   }
     * })
     */
    upsert<T extends PaymentProviderConfigUpsertArgs>(args: SelectSubset<T, PaymentProviderConfigUpsertArgs<ExtArgs>>): Prisma__PaymentProviderConfigClient<$Result.GetResult<Prisma.$PaymentProviderConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentProviderConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigCountArgs} args - Arguments to filter PaymentProviderConfigs to count.
     * @example
     * // Count the number of PaymentProviderConfigs
     * const count = await prisma.paymentProviderConfig.count({
     *   where: {
     *     // ... the filter for the PaymentProviderConfigs we want to count
     *   }
     * })
    **/
    count<T extends PaymentProviderConfigCountArgs>(
      args?: Subset<T, PaymentProviderConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentProviderConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentProviderConfigAggregateArgs>(args: Subset<T, PaymentProviderConfigAggregateArgs>): Prisma.PrismaPromise<GetPaymentProviderConfigAggregateType<T>>

    /**
     * Group by PaymentProviderConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentProviderConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentProviderConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentProviderConfigGroupByArgs['orderBy'] }
        : { orderBy?: PaymentProviderConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentProviderConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentProviderConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentProviderConfig model
   */
  readonly fields: PaymentProviderConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentProviderConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentProviderConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    updatedBy<T extends PaymentProviderConfig$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, PaymentProviderConfig$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentProviderConfig model
   */ 
  interface PaymentProviderConfigFieldRefs {
    readonly id: FieldRef<"PaymentProviderConfig", 'String'>
    readonly organizationId: FieldRef<"PaymentProviderConfig", 'String'>
    readonly provider: FieldRef<"PaymentProviderConfig", 'String'>
    readonly isEnabled: FieldRef<"PaymentProviderConfig", 'Boolean'>
    readonly configJson: FieldRef<"PaymentProviderConfig", 'String'>
    readonly updatedAt: FieldRef<"PaymentProviderConfig", 'DateTime'>
    readonly updatedById: FieldRef<"PaymentProviderConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentProviderConfig findUnique
   */
  export type PaymentProviderConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig findUniqueOrThrow
   */
  export type PaymentProviderConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig findFirst
   */
  export type PaymentProviderConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviderConfigs.
     */
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig findFirstOrThrow
   */
  export type PaymentProviderConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfig to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentProviderConfigs.
     */
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig findMany
   */
  export type PaymentProviderConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter, which PaymentProviderConfigs to fetch.
     */
    where?: PaymentProviderConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentProviderConfigs to fetch.
     */
    orderBy?: PaymentProviderConfigOrderByWithRelationInput | PaymentProviderConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentProviderConfigs.
     */
    cursor?: PaymentProviderConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentProviderConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentProviderConfigs.
     */
    skip?: number
    distinct?: PaymentProviderConfigScalarFieldEnum | PaymentProviderConfigScalarFieldEnum[]
  }

  /**
   * PaymentProviderConfig create
   */
  export type PaymentProviderConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentProviderConfig.
     */
    data: XOR<PaymentProviderConfigCreateInput, PaymentProviderConfigUncheckedCreateInput>
  }

  /**
   * PaymentProviderConfig createMany
   */
  export type PaymentProviderConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentProviderConfigs.
     */
    data: PaymentProviderConfigCreateManyInput | PaymentProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentProviderConfig createManyAndReturn
   */
  export type PaymentProviderConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentProviderConfigs.
     */
    data: PaymentProviderConfigCreateManyInput | PaymentProviderConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentProviderConfig update
   */
  export type PaymentProviderConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentProviderConfig.
     */
    data: XOR<PaymentProviderConfigUpdateInput, PaymentProviderConfigUncheckedUpdateInput>
    /**
     * Choose, which PaymentProviderConfig to update.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig updateMany
   */
  export type PaymentProviderConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentProviderConfigs.
     */
    data: XOR<PaymentProviderConfigUpdateManyMutationInput, PaymentProviderConfigUncheckedUpdateManyInput>
    /**
     * Filter which PaymentProviderConfigs to update
     */
    where?: PaymentProviderConfigWhereInput
  }

  /**
   * PaymentProviderConfig upsert
   */
  export type PaymentProviderConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentProviderConfig to update in case it exists.
     */
    where: PaymentProviderConfigWhereUniqueInput
    /**
     * In case the PaymentProviderConfig found by the `where` argument doesn't exist, create a new PaymentProviderConfig with this data.
     */
    create: XOR<PaymentProviderConfigCreateInput, PaymentProviderConfigUncheckedCreateInput>
    /**
     * In case the PaymentProviderConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentProviderConfigUpdateInput, PaymentProviderConfigUncheckedUpdateInput>
  }

  /**
   * PaymentProviderConfig delete
   */
  export type PaymentProviderConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
    /**
     * Filter which PaymentProviderConfig to delete.
     */
    where: PaymentProviderConfigWhereUniqueInput
  }

  /**
   * PaymentProviderConfig deleteMany
   */
  export type PaymentProviderConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentProviderConfigs to delete
     */
    where?: PaymentProviderConfigWhereInput
  }

  /**
   * PaymentProviderConfig.updatedBy
   */
  export type PaymentProviderConfig$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PaymentProviderConfig without action
   */
  export type PaymentProviderConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentProviderConfig
     */
    select?: PaymentProviderConfigSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentProviderConfigInclude<ExtArgs> | null
  }


  /**
   * Model IncentiveGrant
   */

  export type AggregateIncentiveGrant = {
    _count: IncentiveGrantCountAggregateOutputType | null
    _min: IncentiveGrantMinAggregateOutputType | null
    _max: IncentiveGrantMaxAggregateOutputType | null
  }

  export type IncentiveGrantMinAggregateOutputType = {
    id: string | null
    segmentIncentiveId: string | null
    userId: string | null
    grantedAt: Date | null
    couponCode: string | null
    couponId: string | null
    walletTransactionId: string | null
    redeemedAt: Date | null
    redeemedOrderId: string | null
  }

  export type IncentiveGrantMaxAggregateOutputType = {
    id: string | null
    segmentIncentiveId: string | null
    userId: string | null
    grantedAt: Date | null
    couponCode: string | null
    couponId: string | null
    walletTransactionId: string | null
    redeemedAt: Date | null
    redeemedOrderId: string | null
  }

  export type IncentiveGrantCountAggregateOutputType = {
    id: number
    segmentIncentiveId: number
    userId: number
    grantedAt: number
    couponCode: number
    couponId: number
    walletTransactionId: number
    redeemedAt: number
    redeemedOrderId: number
    _all: number
  }


  export type IncentiveGrantMinAggregateInputType = {
    id?: true
    segmentIncentiveId?: true
    userId?: true
    grantedAt?: true
    couponCode?: true
    couponId?: true
    walletTransactionId?: true
    redeemedAt?: true
    redeemedOrderId?: true
  }

  export type IncentiveGrantMaxAggregateInputType = {
    id?: true
    segmentIncentiveId?: true
    userId?: true
    grantedAt?: true
    couponCode?: true
    couponId?: true
    walletTransactionId?: true
    redeemedAt?: true
    redeemedOrderId?: true
  }

  export type IncentiveGrantCountAggregateInputType = {
    id?: true
    segmentIncentiveId?: true
    userId?: true
    grantedAt?: true
    couponCode?: true
    couponId?: true
    walletTransactionId?: true
    redeemedAt?: true
    redeemedOrderId?: true
    _all?: true
  }

  export type IncentiveGrantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncentiveGrant to aggregate.
     */
    where?: IncentiveGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncentiveGrants to fetch.
     */
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncentiveGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncentiveGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncentiveGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncentiveGrants
    **/
    _count?: true | IncentiveGrantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncentiveGrantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncentiveGrantMaxAggregateInputType
  }

  export type GetIncentiveGrantAggregateType<T extends IncentiveGrantAggregateArgs> = {
        [P in keyof T & keyof AggregateIncentiveGrant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncentiveGrant[P]>
      : GetScalarType<T[P], AggregateIncentiveGrant[P]>
  }




  export type IncentiveGrantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveGrantWhereInput
    orderBy?: IncentiveGrantOrderByWithAggregationInput | IncentiveGrantOrderByWithAggregationInput[]
    by: IncentiveGrantScalarFieldEnum[] | IncentiveGrantScalarFieldEnum
    having?: IncentiveGrantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncentiveGrantCountAggregateInputType | true
    _min?: IncentiveGrantMinAggregateInputType
    _max?: IncentiveGrantMaxAggregateInputType
  }

  export type IncentiveGrantGroupByOutputType = {
    id: string
    segmentIncentiveId: string
    userId: string
    grantedAt: Date
    couponCode: string | null
    couponId: string | null
    walletTransactionId: string | null
    redeemedAt: Date | null
    redeemedOrderId: string | null
    _count: IncentiveGrantCountAggregateOutputType | null
    _min: IncentiveGrantMinAggregateOutputType | null
    _max: IncentiveGrantMaxAggregateOutputType | null
  }

  type GetIncentiveGrantGroupByPayload<T extends IncentiveGrantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncentiveGrantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncentiveGrantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncentiveGrantGroupByOutputType[P]>
            : GetScalarType<T[P], IncentiveGrantGroupByOutputType[P]>
        }
      >
    >


  export type IncentiveGrantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segmentIncentiveId?: boolean
    userId?: boolean
    grantedAt?: boolean
    couponCode?: boolean
    couponId?: boolean
    walletTransactionId?: boolean
    redeemedAt?: boolean
    redeemedOrderId?: boolean
    segmentIncentive?: boolean | SegmentIncentiveDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | IncentiveGrant$couponArgs<ExtArgs>
    walletTransaction?: boolean | IncentiveGrant$walletTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["incentiveGrant"]>

  export type IncentiveGrantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    segmentIncentiveId?: boolean
    userId?: boolean
    grantedAt?: boolean
    couponCode?: boolean
    couponId?: boolean
    walletTransactionId?: boolean
    redeemedAt?: boolean
    redeemedOrderId?: boolean
    segmentIncentive?: boolean | SegmentIncentiveDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | IncentiveGrant$couponArgs<ExtArgs>
  }, ExtArgs["result"]["incentiveGrant"]>

  export type IncentiveGrantSelectScalar = {
    id?: boolean
    segmentIncentiveId?: boolean
    userId?: boolean
    grantedAt?: boolean
    couponCode?: boolean
    couponId?: boolean
    walletTransactionId?: boolean
    redeemedAt?: boolean
    redeemedOrderId?: boolean
  }

  export type IncentiveGrantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segmentIncentive?: boolean | SegmentIncentiveDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | IncentiveGrant$couponArgs<ExtArgs>
    walletTransaction?: boolean | IncentiveGrant$walletTransactionArgs<ExtArgs>
  }
  export type IncentiveGrantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    segmentIncentive?: boolean | SegmentIncentiveDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coupon?: boolean | IncentiveGrant$couponArgs<ExtArgs>
  }

  export type $IncentiveGrantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncentiveGrant"
    objects: {
      segmentIncentive: Prisma.$SegmentIncentivePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      coupon: Prisma.$CouponPayload<ExtArgs> | null
      walletTransaction: Prisma.$WalletTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      segmentIncentiveId: string
      userId: string
      grantedAt: Date
      couponCode: string | null
      couponId: string | null
      walletTransactionId: string | null
      redeemedAt: Date | null
      redeemedOrderId: string | null
    }, ExtArgs["result"]["incentiveGrant"]>
    composites: {}
  }

  type IncentiveGrantGetPayload<S extends boolean | null | undefined | IncentiveGrantDefaultArgs> = $Result.GetResult<Prisma.$IncentiveGrantPayload, S>

  type IncentiveGrantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncentiveGrantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncentiveGrantCountAggregateInputType | true
    }

  export interface IncentiveGrantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncentiveGrant'], meta: { name: 'IncentiveGrant' } }
    /**
     * Find zero or one IncentiveGrant that matches the filter.
     * @param {IncentiveGrantFindUniqueArgs} args - Arguments to find a IncentiveGrant
     * @example
     * // Get one IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncentiveGrantFindUniqueArgs>(args: SelectSubset<T, IncentiveGrantFindUniqueArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncentiveGrant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncentiveGrantFindUniqueOrThrowArgs} args - Arguments to find a IncentiveGrant
     * @example
     * // Get one IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncentiveGrantFindUniqueOrThrowArgs>(args: SelectSubset<T, IncentiveGrantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncentiveGrant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantFindFirstArgs} args - Arguments to find a IncentiveGrant
     * @example
     * // Get one IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncentiveGrantFindFirstArgs>(args?: SelectSubset<T, IncentiveGrantFindFirstArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncentiveGrant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantFindFirstOrThrowArgs} args - Arguments to find a IncentiveGrant
     * @example
     * // Get one IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncentiveGrantFindFirstOrThrowArgs>(args?: SelectSubset<T, IncentiveGrantFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncentiveGrants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncentiveGrants
     * const incentiveGrants = await prisma.incentiveGrant.findMany()
     * 
     * // Get first 10 IncentiveGrants
     * const incentiveGrants = await prisma.incentiveGrant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incentiveGrantWithIdOnly = await prisma.incentiveGrant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncentiveGrantFindManyArgs>(args?: SelectSubset<T, IncentiveGrantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncentiveGrant.
     * @param {IncentiveGrantCreateArgs} args - Arguments to create a IncentiveGrant.
     * @example
     * // Create one IncentiveGrant
     * const IncentiveGrant = await prisma.incentiveGrant.create({
     *   data: {
     *     // ... data to create a IncentiveGrant
     *   }
     * })
     * 
     */
    create<T extends IncentiveGrantCreateArgs>(args: SelectSubset<T, IncentiveGrantCreateArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncentiveGrants.
     * @param {IncentiveGrantCreateManyArgs} args - Arguments to create many IncentiveGrants.
     * @example
     * // Create many IncentiveGrants
     * const incentiveGrant = await prisma.incentiveGrant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncentiveGrantCreateManyArgs>(args?: SelectSubset<T, IncentiveGrantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncentiveGrants and returns the data saved in the database.
     * @param {IncentiveGrantCreateManyAndReturnArgs} args - Arguments to create many IncentiveGrants.
     * @example
     * // Create many IncentiveGrants
     * const incentiveGrant = await prisma.incentiveGrant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncentiveGrants and only return the `id`
     * const incentiveGrantWithIdOnly = await prisma.incentiveGrant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncentiveGrantCreateManyAndReturnArgs>(args?: SelectSubset<T, IncentiveGrantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncentiveGrant.
     * @param {IncentiveGrantDeleteArgs} args - Arguments to delete one IncentiveGrant.
     * @example
     * // Delete one IncentiveGrant
     * const IncentiveGrant = await prisma.incentiveGrant.delete({
     *   where: {
     *     // ... filter to delete one IncentiveGrant
     *   }
     * })
     * 
     */
    delete<T extends IncentiveGrantDeleteArgs>(args: SelectSubset<T, IncentiveGrantDeleteArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncentiveGrant.
     * @param {IncentiveGrantUpdateArgs} args - Arguments to update one IncentiveGrant.
     * @example
     * // Update one IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncentiveGrantUpdateArgs>(args: SelectSubset<T, IncentiveGrantUpdateArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncentiveGrants.
     * @param {IncentiveGrantDeleteManyArgs} args - Arguments to filter IncentiveGrants to delete.
     * @example
     * // Delete a few IncentiveGrants
     * const { count } = await prisma.incentiveGrant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncentiveGrantDeleteManyArgs>(args?: SelectSubset<T, IncentiveGrantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncentiveGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncentiveGrants
     * const incentiveGrant = await prisma.incentiveGrant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncentiveGrantUpdateManyArgs>(args: SelectSubset<T, IncentiveGrantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncentiveGrant.
     * @param {IncentiveGrantUpsertArgs} args - Arguments to update or create a IncentiveGrant.
     * @example
     * // Update or create a IncentiveGrant
     * const incentiveGrant = await prisma.incentiveGrant.upsert({
     *   create: {
     *     // ... data to create a IncentiveGrant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncentiveGrant we want to update
     *   }
     * })
     */
    upsert<T extends IncentiveGrantUpsertArgs>(args: SelectSubset<T, IncentiveGrantUpsertArgs<ExtArgs>>): Prisma__IncentiveGrantClient<$Result.GetResult<Prisma.$IncentiveGrantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncentiveGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantCountArgs} args - Arguments to filter IncentiveGrants to count.
     * @example
     * // Count the number of IncentiveGrants
     * const count = await prisma.incentiveGrant.count({
     *   where: {
     *     // ... the filter for the IncentiveGrants we want to count
     *   }
     * })
    **/
    count<T extends IncentiveGrantCountArgs>(
      args?: Subset<T, IncentiveGrantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncentiveGrantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncentiveGrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncentiveGrantAggregateArgs>(args: Subset<T, IncentiveGrantAggregateArgs>): Prisma.PrismaPromise<GetIncentiveGrantAggregateType<T>>

    /**
     * Group by IncentiveGrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGrantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncentiveGrantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncentiveGrantGroupByArgs['orderBy'] }
        : { orderBy?: IncentiveGrantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncentiveGrantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncentiveGrantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncentiveGrant model
   */
  readonly fields: IncentiveGrantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncentiveGrant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncentiveGrantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    segmentIncentive<T extends SegmentIncentiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SegmentIncentiveDefaultArgs<ExtArgs>>): Prisma__SegmentIncentiveClient<$Result.GetResult<Prisma.$SegmentIncentivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    coupon<T extends IncentiveGrant$couponArgs<ExtArgs> = {}>(args?: Subset<T, IncentiveGrant$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    walletTransaction<T extends IncentiveGrant$walletTransactionArgs<ExtArgs> = {}>(args?: Subset<T, IncentiveGrant$walletTransactionArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncentiveGrant model
   */ 
  interface IncentiveGrantFieldRefs {
    readonly id: FieldRef<"IncentiveGrant", 'String'>
    readonly segmentIncentiveId: FieldRef<"IncentiveGrant", 'String'>
    readonly userId: FieldRef<"IncentiveGrant", 'String'>
    readonly grantedAt: FieldRef<"IncentiveGrant", 'DateTime'>
    readonly couponCode: FieldRef<"IncentiveGrant", 'String'>
    readonly couponId: FieldRef<"IncentiveGrant", 'String'>
    readonly walletTransactionId: FieldRef<"IncentiveGrant", 'String'>
    readonly redeemedAt: FieldRef<"IncentiveGrant", 'DateTime'>
    readonly redeemedOrderId: FieldRef<"IncentiveGrant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IncentiveGrant findUnique
   */
  export type IncentiveGrantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter, which IncentiveGrant to fetch.
     */
    where: IncentiveGrantWhereUniqueInput
  }

  /**
   * IncentiveGrant findUniqueOrThrow
   */
  export type IncentiveGrantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter, which IncentiveGrant to fetch.
     */
    where: IncentiveGrantWhereUniqueInput
  }

  /**
   * IncentiveGrant findFirst
   */
  export type IncentiveGrantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter, which IncentiveGrant to fetch.
     */
    where?: IncentiveGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncentiveGrants to fetch.
     */
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncentiveGrants.
     */
    cursor?: IncentiveGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncentiveGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncentiveGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncentiveGrants.
     */
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * IncentiveGrant findFirstOrThrow
   */
  export type IncentiveGrantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter, which IncentiveGrant to fetch.
     */
    where?: IncentiveGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncentiveGrants to fetch.
     */
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncentiveGrants.
     */
    cursor?: IncentiveGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncentiveGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncentiveGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncentiveGrants.
     */
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * IncentiveGrant findMany
   */
  export type IncentiveGrantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter, which IncentiveGrants to fetch.
     */
    where?: IncentiveGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncentiveGrants to fetch.
     */
    orderBy?: IncentiveGrantOrderByWithRelationInput | IncentiveGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncentiveGrants.
     */
    cursor?: IncentiveGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncentiveGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncentiveGrants.
     */
    skip?: number
    distinct?: IncentiveGrantScalarFieldEnum | IncentiveGrantScalarFieldEnum[]
  }

  /**
   * IncentiveGrant create
   */
  export type IncentiveGrantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * The data needed to create a IncentiveGrant.
     */
    data: XOR<IncentiveGrantCreateInput, IncentiveGrantUncheckedCreateInput>
  }

  /**
   * IncentiveGrant createMany
   */
  export type IncentiveGrantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncentiveGrants.
     */
    data: IncentiveGrantCreateManyInput | IncentiveGrantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncentiveGrant createManyAndReturn
   */
  export type IncentiveGrantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncentiveGrants.
     */
    data: IncentiveGrantCreateManyInput | IncentiveGrantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IncentiveGrant update
   */
  export type IncentiveGrantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * The data needed to update a IncentiveGrant.
     */
    data: XOR<IncentiveGrantUpdateInput, IncentiveGrantUncheckedUpdateInput>
    /**
     * Choose, which IncentiveGrant to update.
     */
    where: IncentiveGrantWhereUniqueInput
  }

  /**
   * IncentiveGrant updateMany
   */
  export type IncentiveGrantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncentiveGrants.
     */
    data: XOR<IncentiveGrantUpdateManyMutationInput, IncentiveGrantUncheckedUpdateManyInput>
    /**
     * Filter which IncentiveGrants to update
     */
    where?: IncentiveGrantWhereInput
  }

  /**
   * IncentiveGrant upsert
   */
  export type IncentiveGrantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * The filter to search for the IncentiveGrant to update in case it exists.
     */
    where: IncentiveGrantWhereUniqueInput
    /**
     * In case the IncentiveGrant found by the `where` argument doesn't exist, create a new IncentiveGrant with this data.
     */
    create: XOR<IncentiveGrantCreateInput, IncentiveGrantUncheckedCreateInput>
    /**
     * In case the IncentiveGrant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncentiveGrantUpdateInput, IncentiveGrantUncheckedUpdateInput>
  }

  /**
   * IncentiveGrant delete
   */
  export type IncentiveGrantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
    /**
     * Filter which IncentiveGrant to delete.
     */
    where: IncentiveGrantWhereUniqueInput
  }

  /**
   * IncentiveGrant deleteMany
   */
  export type IncentiveGrantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncentiveGrants to delete
     */
    where?: IncentiveGrantWhereInput
  }

  /**
   * IncentiveGrant.coupon
   */
  export type IncentiveGrant$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * IncentiveGrant.walletTransaction
   */
  export type IncentiveGrant$walletTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
  }

  /**
   * IncentiveGrant without action
   */
  export type IncentiveGrantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncentiveGrant
     */
    select?: IncentiveGrantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveGrantInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logoUrl: 'logoUrl',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contractNumber: 'contractNumber',
    isActive: 'isActive',
    subsidyType: 'subsidyType',
    subsidyValue: 'subsidyValue',
    subsidyMaxPerDay: 'subsidyMaxPerDay',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyInvoiceScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    year: 'year',
    month: 'month',
    status: 'status',
    totalAmount: 'totalAmount',
    invoicedAt: 'invoicedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyInvoiceScalarFieldEnum = (typeof CompanyInvoiceScalarFieldEnum)[keyof typeof CompanyInvoiceScalarFieldEnum]


  export const CompanyInvoiceItemScalarFieldEnum: {
    id: 'id',
    companyInvoiceId: 'companyInvoiceId',
    orderId: 'orderId',
    orderNumber: 'orderNumber',
    orderDate: 'orderDate',
    employeeName: 'employeeName',
    amount: 'amount'
  };

  export type CompanyInvoiceItemScalarFieldEnum = (typeof CompanyInvoiceItemScalarFieldEnum)[keyof typeof CompanyInvoiceItemScalarFieldEnum]


  export const CompanyEmployeeScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    userId: 'userId',
    employeeNumber: 'employeeNumber',
    department: 'department',
    isActive: 'isActive',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    createdAt: 'createdAt'
  };

  export type CompanyEmployeeScalarFieldEnum = (typeof CompanyEmployeeScalarFieldEnum)[keyof typeof CompanyEmployeeScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    openingHours: 'openingHours',
    workingDays: 'workingDays',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    role: 'role',
    image: 'image',
    organizationId: 'organizationId',
    marketingEmailConsent: 'marketingEmailConsent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    balance: 'balance',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    amount: 'amount',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    description: 'description',
    orderId: 'orderId',
    performedById: 'performedById',
    incentiveGrantId: 'incentiveGrantId',
    paymentProvider: 'paymentProvider',
    externalPaymentId: 'externalPaymentId',
    createdAt: 'createdAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const UserLocationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    createdAt: 'createdAt'
  };

  export type UserLocationScalarFieldEnum = (typeof UserLocationScalarFieldEnum)[keyof typeof UserLocationScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    weekNumber: 'weekNumber',
    year: 'year',
    startDate: 'startDate',
    endDate: 'endDate',
    isPublished: 'isPublished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const PromotionBannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    imageUrl: 'imageUrl',
    couponId: 'couponId',
    isActive: 'isActive',
    marketingTemplateId: 'marketingTemplateId',
    templateSnapshot: 'templateSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionBannerScalarFieldEnum = (typeof PromotionBannerScalarFieldEnum)[keyof typeof PromotionBannerScalarFieldEnum]


  export const MenuPromotionBannerScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    promotionBannerId: 'promotionBannerId',
    sortOrder: 'sortOrder'
  };

  export type MenuPromotionBannerScalarFieldEnum = (typeof MenuPromotionBannerScalarFieldEnum)[keyof typeof MenuPromotionBannerScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    dishId: 'dishId',
    date: 'date',
    available: 'available',
    price: 'price',
    maxOrders: 'maxOrders',
    currentOrders: 'currentOrders',
    isPromotion: 'isPromotion',
    promotionPrice: 'promotionPrice',
    promotionLabel: 'promotionLabel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const DishScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    category: 'category',
    calories: 'calories',
    protein: 'protein',
    carbs: 'carbs',
    fat: 'fat',
    allergens: 'allergens',
    dietTags: 'dietTags',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DishScalarFieldEnum = (typeof DishScalarFieldEnum)[keyof typeof DishScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    status: 'status',
    totalAmount: 'totalAmount',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    paymentIntentId: 'paymentIntentId',
    pickupCode: 'pickupCode',
    pickupDate: 'pickupDate',
    pickupTimeSlot: 'pickupTimeSlot',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pickedUpAt: 'pickedUpAt',
    couponCode: 'couponCode',
    discountAmount: 'discountAmount',
    finalAmount: 'finalAmount',
    employerSubsidyAmount: 'employerSubsidyAmount',
    employerCompanyId: 'employerCompanyId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    discountValue: 'discountValue',
    freeItemDishId: 'freeItemDishId',
    locationId: 'locationId',
    startDate: 'startDate',
    endDate: 'endDate',
    maxUses: 'maxUses',
    maxUsesPerUser: 'maxUsesPerUser',
    currentUses: 'currentUses',
    minOrderAmount: 'minOrderAmount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const CouponRedemptionScalarFieldEnum: {
    id: 'id',
    couponId: 'couponId',
    userId: 'userId',
    orderId: 'orderId',
    redeemedAt: 'redeemedAt'
  };

  export type CouponRedemptionScalarFieldEnum = (typeof CouponRedemptionScalarFieldEnum)[keyof typeof CouponRedemptionScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    menuItemId: 'menuItemId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const MetadataScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetadataScalarFieldEnum = (typeof MetadataScalarFieldEnum)[keyof typeof MetadataScalarFieldEnum]


  export const CustomerSegmentScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    description: 'description',
    rulesCombination: 'rulesCombination',
    rules: 'rules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerSegmentScalarFieldEnum = (typeof CustomerSegmentScalarFieldEnum)[keyof typeof CustomerSegmentScalarFieldEnum]


  export const InAppMessageScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    segmentId: 'segmentId',
    title: 'title',
    body: 'body',
    linkUrl: 'linkUrl',
    displayPlace: 'displayPlace',
    displayType: 'displayType',
    slotId: 'slotId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    marketingTemplateId: 'marketingTemplateId',
    templateSnapshot: 'templateSnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InAppMessageScalarFieldEnum = (typeof InAppMessageScalarFieldEnum)[keyof typeof InAppMessageScalarFieldEnum]


  export const InAppMessageReadScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type InAppMessageReadScalarFieldEnum = (typeof InAppMessageReadScalarFieldEnum)[keyof typeof InAppMessageReadScalarFieldEnum]


  export const MarketingWorkflowScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    segmentId: 'segmentId',
    name: 'name',
    triggerType: 'triggerType',
    triggerConfig: 'triggerConfig',
    actionType: 'actionType',
    actionConfig: 'actionConfig',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingWorkflowScalarFieldEnum = (typeof MarketingWorkflowScalarFieldEnum)[keyof typeof MarketingWorkflowScalarFieldEnum]


  export const WorkflowExecutionLogScalarFieldEnum: {
    id: 'id',
    workflowId: 'workflowId',
    executedAt: 'executedAt',
    status: 'status',
    message: 'message',
    details: 'details'
  };

  export type WorkflowExecutionLogScalarFieldEnum = (typeof WorkflowExecutionLogScalarFieldEnum)[keyof typeof WorkflowExecutionLogScalarFieldEnum]


  export const SegmentIncentiveScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    segmentId: 'segmentId',
    name: 'name',
    incentiveType: 'incentiveType',
    couponId: 'couponId',
    personaliseCoupon: 'personaliseCoupon',
    walletAmount: 'walletAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    maxGrantsPerUser: 'maxGrantsPerUser',
    displayChannel: 'displayChannel',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SegmentIncentiveScalarFieldEnum = (typeof SegmentIncentiveScalarFieldEnum)[keyof typeof SegmentIncentiveScalarFieldEnum]


  export const MarketingTemplateScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    type: 'type',
    content: 'content',
    status: 'status',
    isStarter: 'isStarter',
    isFavorite: 'isFavorite',
    thumbnailUrl: 'thumbnailUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingTemplateScalarFieldEnum = (typeof MarketingTemplateScalarFieldEnum)[keyof typeof MarketingTemplateScalarFieldEnum]


  export const PushNotificationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    segmentId: 'segmentId',
    marketingTemplateId: 'marketingTemplateId',
    templateSnapshot: 'templateSnapshot',
    pushTitle: 'pushTitle',
    pushBody: 'pushBody',
    deepLink: 'deepLink',
    status: 'status',
    scheduledAt: 'scheduledAt',
    sentAt: 'sentAt',
    totalRecipients: 'totalRecipients',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PushNotificationScalarFieldEnum = (typeof PushNotificationScalarFieldEnum)[keyof typeof PushNotificationScalarFieldEnum]


  export const PushNotificationLogScalarFieldEnum: {
    id: 'id',
    pushNotificationId: 'pushNotificationId',
    userId: 'userId',
    status: 'status',
    sentAt: 'sentAt'
  };

  export type PushNotificationLogScalarFieldEnum = (typeof PushNotificationLogScalarFieldEnum)[keyof typeof PushNotificationLogScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dhKey: 'p256dhKey',
    authKey: 'authKey',
    createdAt: 'createdAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const PaymentProviderConfigScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    provider: 'provider',
    isEnabled: 'isEnabled',
    configJson: 'configJson',
    updatedAt: 'updatedAt',
    updatedById: 'updatedById'
  };

  export type PaymentProviderConfigScalarFieldEnum = (typeof PaymentProviderConfigScalarFieldEnum)[keyof typeof PaymentProviderConfigScalarFieldEnum]


  export const IncentiveGrantScalarFieldEnum: {
    id: 'id',
    segmentIncentiveId: 'segmentIncentiveId',
    userId: 'userId',
    grantedAt: 'grantedAt',
    couponCode: 'couponCode',
    couponId: 'couponId',
    walletTransactionId: 'walletTransactionId',
    redeemedAt: 'redeemedAt',
    redeemedOrderId: 'redeemedOrderId'
  };

  export type IncentiveGrantScalarFieldEnum = (typeof IncentiveGrantScalarFieldEnum)[keyof typeof IncentiveGrantScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SubsidyType'
   */
  export type EnumSubsidyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubsidyType'>
    


  /**
   * Reference to a field of type 'SubsidyType[]'
   */
  export type ListEnumSubsidyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubsidyType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'WalletTransactionType'
   */
  export type EnumWalletTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletTransactionType'>
    


  /**
   * Reference to a field of type 'WalletTransactionType[]'
   */
  export type ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletTransactionType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'CouponType'
   */
  export type EnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponType'>
    


  /**
   * Reference to a field of type 'CouponType[]'
   */
  export type ListEnumCouponTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponType[]'>
    


  /**
   * Reference to a field of type 'MetadataType'
   */
  export type EnumMetadataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetadataType'>
    


  /**
   * Reference to a field of type 'MetadataType[]'
   */
  export type ListEnumMetadataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetadataType[]'>
    


  /**
   * Reference to a field of type 'MarketingTemplateType'
   */
  export type EnumMarketingTemplateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketingTemplateType'>
    


  /**
   * Reference to a field of type 'MarketingTemplateType[]'
   */
  export type ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketingTemplateType[]'>
    


  /**
   * Reference to a field of type 'MarketingTemplateStatus'
   */
  export type EnumMarketingTemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketingTemplateStatus'>
    


  /**
   * Reference to a field of type 'MarketingTemplateStatus[]'
   */
  export type ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MarketingTemplateStatus[]'>
    


  /**
   * Reference to a field of type 'PushNotificationStatus'
   */
  export type EnumPushNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PushNotificationStatus'>
    


  /**
   * Reference to a field of type 'PushNotificationStatus[]'
   */
  export type ListEnumPushNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PushNotificationStatus[]'>
    


  /**
   * Reference to a field of type 'PushDeliveryStatus'
   */
  export type EnumPushDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PushDeliveryStatus'>
    


  /**
   * Reference to a field of type 'PushDeliveryStatus[]'
   */
  export type ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PushDeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    primaryColor?: StringNullableFilter<"Organization"> | string | null
    secondaryColor?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    locations?: LocationListRelationFilter
    users?: UserListRelationFilter
    segments?: CustomerSegmentListRelationFilter
    inAppMessages?: InAppMessageListRelationFilter
    workflows?: MarketingWorkflowListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    marketingTemplates?: MarketingTemplateListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
    paymentConfigs?: PaymentProviderConfigListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locations?: LocationOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    segments?: CustomerSegmentOrderByRelationAggregateInput
    inAppMessages?: InAppMessageOrderByRelationAggregateInput
    workflows?: MarketingWorkflowOrderByRelationAggregateInput
    segmentIncentives?: SegmentIncentiveOrderByRelationAggregateInput
    marketingTemplates?: MarketingTemplateOrderByRelationAggregateInput
    pushNotifications?: PushNotificationOrderByRelationAggregateInput
    paymentConfigs?: PaymentProviderConfigOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    primaryColor?: StringNullableFilter<"Organization"> | string | null
    secondaryColor?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    locations?: LocationListRelationFilter
    users?: UserListRelationFilter
    segments?: CustomerSegmentListRelationFilter
    inAppMessages?: InAppMessageListRelationFilter
    workflows?: MarketingWorkflowListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    marketingTemplates?: MarketingTemplateListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
    paymentConfigs?: PaymentProviderConfigListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    contractNumber?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    subsidyType?: EnumSubsidyTypeFilter<"Company"> | $Enums.SubsidyType
    subsidyValue?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    validFrom?: DateTimeNullableFilter<"Company"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    employees?: CompanyEmployeeListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: CompanyInvoiceListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subsidyType?: SortOrder
    subsidyValue?: SortOrderInput | SortOrder
    subsidyMaxPerDay?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: CompanyEmployeeOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    invoices?: CompanyInvoiceOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    contractNumber?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    subsidyType?: EnumSubsidyTypeFilter<"Company"> | $Enums.SubsidyType
    subsidyValue?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: DecimalNullableFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    validFrom?: DateTimeNullableFilter<"Company"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"Company"> | Date | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    employees?: CompanyEmployeeListRelationFilter
    orders?: OrderListRelationFilter
    invoices?: CompanyInvoiceListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contractNumber?: SortOrderInput | SortOrder
    isActive?: SortOrder
    subsidyType?: SortOrder
    subsidyValue?: SortOrderInput | SortOrder
    subsidyMaxPerDay?: SortOrderInput | SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    contractNumber?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    subsidyType?: EnumSubsidyTypeWithAggregatesFilter<"Company"> | $Enums.SubsidyType
    subsidyValue?: DecimalNullableWithAggregatesFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: DecimalNullableWithAggregatesFilter<"Company"> | Decimal | DecimalJsLike | number | string | null
    validFrom?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    validUntil?: DateTimeNullableWithAggregatesFilter<"Company"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CompanyInvoiceWhereInput = {
    AND?: CompanyInvoiceWhereInput | CompanyInvoiceWhereInput[]
    OR?: CompanyInvoiceWhereInput[]
    NOT?: CompanyInvoiceWhereInput | CompanyInvoiceWhereInput[]
    id?: StringFilter<"CompanyInvoice"> | string
    companyId?: StringFilter<"CompanyInvoice"> | string
    year?: IntFilter<"CompanyInvoice"> | number
    month?: IntFilter<"CompanyInvoice"> | number
    status?: StringFilter<"CompanyInvoice"> | string
    totalAmount?: DecimalFilter<"CompanyInvoice"> | Decimal | DecimalJsLike | number | string
    invoicedAt?: DateTimeNullableFilter<"CompanyInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    items?: CompanyInvoiceItemListRelationFilter
  }

  export type CompanyInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    invoicedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    items?: CompanyInvoiceItemOrderByRelationAggregateInput
  }

  export type CompanyInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_year_month?: CompanyInvoiceCompanyIdYearMonthCompoundUniqueInput
    AND?: CompanyInvoiceWhereInput | CompanyInvoiceWhereInput[]
    OR?: CompanyInvoiceWhereInput[]
    NOT?: CompanyInvoiceWhereInput | CompanyInvoiceWhereInput[]
    companyId?: StringFilter<"CompanyInvoice"> | string
    year?: IntFilter<"CompanyInvoice"> | number
    month?: IntFilter<"CompanyInvoice"> | number
    status?: StringFilter<"CompanyInvoice"> | string
    totalAmount?: DecimalFilter<"CompanyInvoice"> | Decimal | DecimalJsLike | number | string
    invoicedAt?: DateTimeNullableFilter<"CompanyInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    items?: CompanyInvoiceItemListRelationFilter
  }, "id" | "companyId_year_month">

  export type CompanyInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    invoicedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyInvoiceCountOrderByAggregateInput
    _avg?: CompanyInvoiceAvgOrderByAggregateInput
    _max?: CompanyInvoiceMaxOrderByAggregateInput
    _min?: CompanyInvoiceMinOrderByAggregateInput
    _sum?: CompanyInvoiceSumOrderByAggregateInput
  }

  export type CompanyInvoiceScalarWhereWithAggregatesInput = {
    AND?: CompanyInvoiceScalarWhereWithAggregatesInput | CompanyInvoiceScalarWhereWithAggregatesInput[]
    OR?: CompanyInvoiceScalarWhereWithAggregatesInput[]
    NOT?: CompanyInvoiceScalarWhereWithAggregatesInput | CompanyInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyInvoice"> | string
    companyId?: StringWithAggregatesFilter<"CompanyInvoice"> | string
    year?: IntWithAggregatesFilter<"CompanyInvoice"> | number
    month?: IntWithAggregatesFilter<"CompanyInvoice"> | number
    status?: StringWithAggregatesFilter<"CompanyInvoice"> | string
    totalAmount?: DecimalWithAggregatesFilter<"CompanyInvoice"> | Decimal | DecimalJsLike | number | string
    invoicedAt?: DateTimeNullableWithAggregatesFilter<"CompanyInvoice"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyInvoice"> | Date | string
  }

  export type CompanyInvoiceItemWhereInput = {
    AND?: CompanyInvoiceItemWhereInput | CompanyInvoiceItemWhereInput[]
    OR?: CompanyInvoiceItemWhereInput[]
    NOT?: CompanyInvoiceItemWhereInput | CompanyInvoiceItemWhereInput[]
    id?: StringFilter<"CompanyInvoiceItem"> | string
    companyInvoiceId?: StringFilter<"CompanyInvoiceItem"> | string
    orderId?: StringFilter<"CompanyInvoiceItem"> | string
    orderNumber?: StringFilter<"CompanyInvoiceItem"> | string
    orderDate?: DateTimeFilter<"CompanyInvoiceItem"> | Date | string
    employeeName?: StringFilter<"CompanyInvoiceItem"> | string
    amount?: DecimalFilter<"CompanyInvoiceItem"> | Decimal | DecimalJsLike | number | string
    companyInvoice?: XOR<CompanyInvoiceRelationFilter, CompanyInvoiceWhereInput>
  }

  export type CompanyInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    companyInvoiceId?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    orderDate?: SortOrder
    employeeName?: SortOrder
    amount?: SortOrder
    companyInvoice?: CompanyInvoiceOrderByWithRelationInput
  }

  export type CompanyInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: CompanyInvoiceItemWhereInput | CompanyInvoiceItemWhereInput[]
    OR?: CompanyInvoiceItemWhereInput[]
    NOT?: CompanyInvoiceItemWhereInput | CompanyInvoiceItemWhereInput[]
    companyInvoiceId?: StringFilter<"CompanyInvoiceItem"> | string
    orderNumber?: StringFilter<"CompanyInvoiceItem"> | string
    orderDate?: DateTimeFilter<"CompanyInvoiceItem"> | Date | string
    employeeName?: StringFilter<"CompanyInvoiceItem"> | string
    amount?: DecimalFilter<"CompanyInvoiceItem"> | Decimal | DecimalJsLike | number | string
    companyInvoice?: XOR<CompanyInvoiceRelationFilter, CompanyInvoiceWhereInput>
  }, "id" | "orderId">

  export type CompanyInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    companyInvoiceId?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    orderDate?: SortOrder
    employeeName?: SortOrder
    amount?: SortOrder
    _count?: CompanyInvoiceItemCountOrderByAggregateInput
    _avg?: CompanyInvoiceItemAvgOrderByAggregateInput
    _max?: CompanyInvoiceItemMaxOrderByAggregateInput
    _min?: CompanyInvoiceItemMinOrderByAggregateInput
    _sum?: CompanyInvoiceItemSumOrderByAggregateInput
  }

  export type CompanyInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: CompanyInvoiceItemScalarWhereWithAggregatesInput | CompanyInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: CompanyInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: CompanyInvoiceItemScalarWhereWithAggregatesInput | CompanyInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyInvoiceItem"> | string
    companyInvoiceId?: StringWithAggregatesFilter<"CompanyInvoiceItem"> | string
    orderId?: StringWithAggregatesFilter<"CompanyInvoiceItem"> | string
    orderNumber?: StringWithAggregatesFilter<"CompanyInvoiceItem"> | string
    orderDate?: DateTimeWithAggregatesFilter<"CompanyInvoiceItem"> | Date | string
    employeeName?: StringWithAggregatesFilter<"CompanyInvoiceItem"> | string
    amount?: DecimalWithAggregatesFilter<"CompanyInvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type CompanyEmployeeWhereInput = {
    AND?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    OR?: CompanyEmployeeWhereInput[]
    NOT?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    id?: StringFilter<"CompanyEmployee"> | string
    companyId?: StringFilter<"CompanyEmployee"> | string
    userId?: StringFilter<"CompanyEmployee"> | string
    employeeNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    isActive?: BoolFilter<"CompanyEmployee"> | boolean
    validFrom?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CompanyEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    isActive?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CompanyEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId_userId?: CompanyEmployeeCompanyIdUserIdCompoundUniqueInput
    AND?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    OR?: CompanyEmployeeWhereInput[]
    NOT?: CompanyEmployeeWhereInput | CompanyEmployeeWhereInput[]
    companyId?: StringFilter<"CompanyEmployee"> | string
    userId?: StringFilter<"CompanyEmployee"> | string
    employeeNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    isActive?: BoolFilter<"CompanyEmployee"> | boolean
    validFrom?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "companyId_userId">

  export type CompanyEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    employeeNumber?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    isActive?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CompanyEmployeeCountOrderByAggregateInput
    _max?: CompanyEmployeeMaxOrderByAggregateInput
    _min?: CompanyEmployeeMinOrderByAggregateInput
  }

  export type CompanyEmployeeScalarWhereWithAggregatesInput = {
    AND?: CompanyEmployeeScalarWhereWithAggregatesInput | CompanyEmployeeScalarWhereWithAggregatesInput[]
    OR?: CompanyEmployeeScalarWhereWithAggregatesInput[]
    NOT?: CompanyEmployeeScalarWhereWithAggregatesInput | CompanyEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    companyId?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    userId?: StringWithAggregatesFilter<"CompanyEmployee"> | string
    employeeNumber?: StringNullableWithAggregatesFilter<"CompanyEmployee"> | string | null
    department?: StringNullableWithAggregatesFilter<"CompanyEmployee"> | string | null
    isActive?: BoolWithAggregatesFilter<"CompanyEmployee"> | boolean
    validFrom?: DateTimeNullableWithAggregatesFilter<"CompanyEmployee"> | Date | string | null
    validUntil?: DateTimeNullableWithAggregatesFilter<"CompanyEmployee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyEmployee"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    organizationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    email?: StringNullableFilter<"Location"> | string | null
    openingHours?: JsonNullableFilter<"Location">
    workingDays?: IntNullableListFilter<"Location">
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    menus?: MenuListRelationFilter
    orders?: OrderListRelationFilter
    users?: UserLocationListRelationFilter
    coupons?: CouponListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    workingDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    menus?: MenuOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    users?: UserLocationOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    organizationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    email?: StringNullableFilter<"Location"> | string | null
    openingHours?: JsonNullableFilter<"Location">
    workingDays?: IntNullableListFilter<"Location">
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    menus?: MenuListRelationFilter
    orders?: OrderListRelationFilter
    users?: UserLocationListRelationFilter
    coupons?: CouponListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    openingHours?: SortOrderInput | SortOrder
    workingDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    organizationId?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Location"> | string | null
    email?: StringNullableWithAggregatesFilter<"Location"> | string | null
    openingHours?: JsonNullableWithAggregatesFilter<"Location">
    workingDays?: IntNullableListFilter<"Location">
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    marketingEmailConsent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    locations?: UserLocationListRelationFilter
    companyEmployees?: CompanyEmployeeListRelationFilter
    orders?: OrderListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    couponRedemptions?: CouponRedemptionListRelationFilter
    incentiveGrants?: IncentiveGrantListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
    performedWalletActions?: WalletTransactionListRelationFilter
    pushNotificationLogs?: PushNotificationLogListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    paymentConfigChanges?: PaymentProviderConfigListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    marketingEmailConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    locations?: UserLocationOrderByRelationAggregateInput
    companyEmployees?: CompanyEmployeeOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    couponRedemptions?: CouponRedemptionOrderByRelationAggregateInput
    incentiveGrants?: IncentiveGrantOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    walletTransactions?: WalletTransactionOrderByRelationAggregateInput
    performedWalletActions?: WalletTransactionOrderByRelationAggregateInput
    pushNotificationLogs?: PushNotificationLogOrderByRelationAggregateInput
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput
    paymentConfigChanges?: PaymentProviderConfigOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    marketingEmailConsent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    locations?: UserLocationListRelationFilter
    companyEmployees?: CompanyEmployeeListRelationFilter
    orders?: OrderListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    couponRedemptions?: CouponRedemptionListRelationFilter
    incentiveGrants?: IncentiveGrantListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
    performedWalletActions?: WalletTransactionListRelationFilter
    pushNotificationLogs?: PushNotificationLogListRelationFilter
    pushSubscriptions?: PushSubscriptionListRelationFilter
    paymentConfigChanges?: PaymentProviderConfigListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    marketingEmailConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    marketingEmailConsent?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: DecimalFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: DecimalWithAggregatesFilter<"Wallet"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    performedById?: StringNullableFilter<"WalletTransaction"> | string | null
    incentiveGrantId?: StringNullableFilter<"WalletTransaction"> | string | null
    paymentProvider?: StringNullableFilter<"WalletTransaction"> | string | null
    externalPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    performedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    incentiveGrant?: XOR<IncentiveGrantNullableRelationFilter, IncentiveGrantWhereInput> | null
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    incentiveGrantId?: SortOrderInput | SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    externalPaymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
    performedBy?: UserOrderByWithRelationInput
    incentiveGrant?: IncentiveGrantOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incentiveGrantId?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    userId?: StringFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    performedById?: StringNullableFilter<"WalletTransaction"> | string | null
    paymentProvider?: StringNullableFilter<"WalletTransaction"> | string | null
    externalPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableRelationFilter, OrderWhereInput> | null
    performedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    incentiveGrant?: XOR<IncentiveGrantNullableRelationFilter, IncentiveGrantWhereInput> | null
  }, "id" | "incentiveGrantId">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    incentiveGrantId?: SortOrderInput | SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    externalPaymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    userId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeWithAggregatesFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amount?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    performedById?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    incentiveGrantId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    paymentProvider?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    externalPaymentId?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type UserLocationWhereInput = {
    AND?: UserLocationWhereInput | UserLocationWhereInput[]
    OR?: UserLocationWhereInput[]
    NOT?: UserLocationWhereInput | UserLocationWhereInput[]
    id?: StringFilter<"UserLocation"> | string
    userId?: StringFilter<"UserLocation"> | string
    locationId?: StringFilter<"UserLocation"> | string
    createdAt?: DateTimeFilter<"UserLocation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
  }

  export type UserLocationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type UserLocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId?: UserLocationUserIdLocationIdCompoundUniqueInput
    AND?: UserLocationWhereInput | UserLocationWhereInput[]
    OR?: UserLocationWhereInput[]
    NOT?: UserLocationWhereInput | UserLocationWhereInput[]
    userId?: StringFilter<"UserLocation"> | string
    locationId?: StringFilter<"UserLocation"> | string
    createdAt?: DateTimeFilter<"UserLocation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
  }, "id" | "userId_locationId">

  export type UserLocationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    _count?: UserLocationCountOrderByAggregateInput
    _max?: UserLocationMaxOrderByAggregateInput
    _min?: UserLocationMinOrderByAggregateInput
  }

  export type UserLocationScalarWhereWithAggregatesInput = {
    AND?: UserLocationScalarWhereWithAggregatesInput | UserLocationScalarWhereWithAggregatesInput[]
    OR?: UserLocationScalarWhereWithAggregatesInput[]
    NOT?: UserLocationScalarWhereWithAggregatesInput | UserLocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLocation"> | string
    userId?: StringWithAggregatesFilter<"UserLocation"> | string
    locationId?: StringWithAggregatesFilter<"UserLocation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserLocation"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: StringFilter<"Menu"> | string
    locationId?: StringFilter<"Menu"> | string
    weekNumber?: IntFilter<"Menu"> | number
    year?: IntFilter<"Menu"> | number
    startDate?: DateTimeFilter<"Menu"> | Date | string
    endDate?: DateTimeFilter<"Menu"> | Date | string
    isPublished?: BoolFilter<"Menu"> | boolean
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    menuItems?: MenuItemListRelationFilter
    promotionBanners?: MenuPromotionBannerListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    menuItems?: MenuItemOrderByRelationAggregateInput
    promotionBanners?: MenuPromotionBannerOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    locationId_weekNumber_year?: MenuLocationIdWeekNumberYearCompoundUniqueInput
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    locationId?: StringFilter<"Menu"> | string
    weekNumber?: IntFilter<"Menu"> | number
    year?: IntFilter<"Menu"> | number
    startDate?: DateTimeFilter<"Menu"> | Date | string
    endDate?: DateTimeFilter<"Menu"> | Date | string
    isPublished?: BoolFilter<"Menu"> | boolean
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    menuItems?: MenuItemListRelationFilter
    promotionBanners?: MenuPromotionBannerListRelationFilter
  }, "id" | "locationId_weekNumber_year">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _avg?: MenuAvgOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
    _sum?: MenuSumOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Menu"> | string
    locationId?: StringWithAggregatesFilter<"Menu"> | string
    weekNumber?: IntWithAggregatesFilter<"Menu"> | number
    year?: IntWithAggregatesFilter<"Menu"> | number
    startDate?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    isPublished?: BoolWithAggregatesFilter<"Menu"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type PromotionBannerWhereInput = {
    AND?: PromotionBannerWhereInput | PromotionBannerWhereInput[]
    OR?: PromotionBannerWhereInput[]
    NOT?: PromotionBannerWhereInput | PromotionBannerWhereInput[]
    id?: StringFilter<"PromotionBanner"> | string
    title?: StringFilter<"PromotionBanner"> | string
    subtitle?: StringNullableFilter<"PromotionBanner"> | string | null
    imageUrl?: StringNullableFilter<"PromotionBanner"> | string | null
    couponId?: StringNullableFilter<"PromotionBanner"> | string | null
    isActive?: BoolFilter<"PromotionBanner"> | boolean
    marketingTemplateId?: StringNullableFilter<"PromotionBanner"> | string | null
    templateSnapshot?: JsonNullableFilter<"PromotionBanner">
    createdAt?: DateTimeFilter<"PromotionBanner"> | Date | string
    updatedAt?: DateTimeFilter<"PromotionBanner"> | Date | string
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    menuAssignments?: MenuPromotionBannerListRelationFilter
  }

  export type PromotionBannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    coupon?: CouponOrderByWithRelationInput
    marketingTemplate?: MarketingTemplateOrderByWithRelationInput
    menuAssignments?: MenuPromotionBannerOrderByRelationAggregateInput
  }

  export type PromotionBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionBannerWhereInput | PromotionBannerWhereInput[]
    OR?: PromotionBannerWhereInput[]
    NOT?: PromotionBannerWhereInput | PromotionBannerWhereInput[]
    title?: StringFilter<"PromotionBanner"> | string
    subtitle?: StringNullableFilter<"PromotionBanner"> | string | null
    imageUrl?: StringNullableFilter<"PromotionBanner"> | string | null
    couponId?: StringNullableFilter<"PromotionBanner"> | string | null
    isActive?: BoolFilter<"PromotionBanner"> | boolean
    marketingTemplateId?: StringNullableFilter<"PromotionBanner"> | string | null
    templateSnapshot?: JsonNullableFilter<"PromotionBanner">
    createdAt?: DateTimeFilter<"PromotionBanner"> | Date | string
    updatedAt?: DateTimeFilter<"PromotionBanner"> | Date | string
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    menuAssignments?: MenuPromotionBannerListRelationFilter
  }, "id">

  export type PromotionBannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionBannerCountOrderByAggregateInput
    _max?: PromotionBannerMaxOrderByAggregateInput
    _min?: PromotionBannerMinOrderByAggregateInput
  }

  export type PromotionBannerScalarWhereWithAggregatesInput = {
    AND?: PromotionBannerScalarWhereWithAggregatesInput | PromotionBannerScalarWhereWithAggregatesInput[]
    OR?: PromotionBannerScalarWhereWithAggregatesInput[]
    NOT?: PromotionBannerScalarWhereWithAggregatesInput | PromotionBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromotionBanner"> | string
    title?: StringWithAggregatesFilter<"PromotionBanner"> | string
    subtitle?: StringNullableWithAggregatesFilter<"PromotionBanner"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"PromotionBanner"> | string | null
    couponId?: StringNullableWithAggregatesFilter<"PromotionBanner"> | string | null
    isActive?: BoolWithAggregatesFilter<"PromotionBanner"> | boolean
    marketingTemplateId?: StringNullableWithAggregatesFilter<"PromotionBanner"> | string | null
    templateSnapshot?: JsonNullableWithAggregatesFilter<"PromotionBanner">
    createdAt?: DateTimeWithAggregatesFilter<"PromotionBanner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromotionBanner"> | Date | string
  }

  export type MenuPromotionBannerWhereInput = {
    AND?: MenuPromotionBannerWhereInput | MenuPromotionBannerWhereInput[]
    OR?: MenuPromotionBannerWhereInput[]
    NOT?: MenuPromotionBannerWhereInput | MenuPromotionBannerWhereInput[]
    id?: StringFilter<"MenuPromotionBanner"> | string
    menuId?: StringFilter<"MenuPromotionBanner"> | string
    promotionBannerId?: StringFilter<"MenuPromotionBanner"> | string
    sortOrder?: IntFilter<"MenuPromotionBanner"> | number
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    promotionBanner?: XOR<PromotionBannerRelationFilter, PromotionBannerWhereInput>
  }

  export type MenuPromotionBannerOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    promotionBannerId?: SortOrder
    sortOrder?: SortOrder
    menu?: MenuOrderByWithRelationInput
    promotionBanner?: PromotionBannerOrderByWithRelationInput
  }

  export type MenuPromotionBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    menuId_promotionBannerId?: MenuPromotionBannerMenuIdPromotionBannerIdCompoundUniqueInput
    AND?: MenuPromotionBannerWhereInput | MenuPromotionBannerWhereInput[]
    OR?: MenuPromotionBannerWhereInput[]
    NOT?: MenuPromotionBannerWhereInput | MenuPromotionBannerWhereInput[]
    menuId?: StringFilter<"MenuPromotionBanner"> | string
    promotionBannerId?: StringFilter<"MenuPromotionBanner"> | string
    sortOrder?: IntFilter<"MenuPromotionBanner"> | number
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    promotionBanner?: XOR<PromotionBannerRelationFilter, PromotionBannerWhereInput>
  }, "id" | "menuId_promotionBannerId">

  export type MenuPromotionBannerOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    promotionBannerId?: SortOrder
    sortOrder?: SortOrder
    _count?: MenuPromotionBannerCountOrderByAggregateInput
    _avg?: MenuPromotionBannerAvgOrderByAggregateInput
    _max?: MenuPromotionBannerMaxOrderByAggregateInput
    _min?: MenuPromotionBannerMinOrderByAggregateInput
    _sum?: MenuPromotionBannerSumOrderByAggregateInput
  }

  export type MenuPromotionBannerScalarWhereWithAggregatesInput = {
    AND?: MenuPromotionBannerScalarWhereWithAggregatesInput | MenuPromotionBannerScalarWhereWithAggregatesInput[]
    OR?: MenuPromotionBannerScalarWhereWithAggregatesInput[]
    NOT?: MenuPromotionBannerScalarWhereWithAggregatesInput | MenuPromotionBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenuPromotionBanner"> | string
    menuId?: StringWithAggregatesFilter<"MenuPromotionBanner"> | string
    promotionBannerId?: StringWithAggregatesFilter<"MenuPromotionBanner"> | string
    sortOrder?: IntWithAggregatesFilter<"MenuPromotionBanner"> | number
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    menuId?: StringFilter<"MenuItem"> | string
    dishId?: StringFilter<"MenuItem"> | string
    date?: DateTimeFilter<"MenuItem"> | Date | string
    available?: BoolFilter<"MenuItem"> | boolean
    price?: DecimalFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string
    maxOrders?: IntNullableFilter<"MenuItem"> | number | null
    currentOrders?: IntFilter<"MenuItem"> | number
    isPromotion?: BoolFilter<"MenuItem"> | boolean
    promotionPrice?: DecimalNullableFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    dish?: XOR<DishRelationFilter, DishWhereInput>
    orderItems?: OrderItemListRelationFilter
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    dishId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    maxOrders?: SortOrderInput | SortOrder
    currentOrders?: SortOrder
    isPromotion?: SortOrder
    promotionPrice?: SortOrderInput | SortOrder
    promotionLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menu?: MenuOrderByWithRelationInput
    dish?: DishOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    menuId?: StringFilter<"MenuItem"> | string
    dishId?: StringFilter<"MenuItem"> | string
    date?: DateTimeFilter<"MenuItem"> | Date | string
    available?: BoolFilter<"MenuItem"> | boolean
    price?: DecimalFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string
    maxOrders?: IntNullableFilter<"MenuItem"> | number | null
    currentOrders?: IntFilter<"MenuItem"> | number
    isPromotion?: BoolFilter<"MenuItem"> | boolean
    promotionPrice?: DecimalNullableFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    menu?: XOR<MenuRelationFilter, MenuWhereInput>
    dish?: XOR<DishRelationFilter, DishWhereInput>
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    dishId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    maxOrders?: SortOrderInput | SortOrder
    currentOrders?: SortOrder
    isPromotion?: SortOrder
    promotionPrice?: SortOrderInput | SortOrder
    promotionLabel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MenuItem"> | string
    menuId?: StringWithAggregatesFilter<"MenuItem"> | string
    dishId?: StringWithAggregatesFilter<"MenuItem"> | string
    date?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    available?: BoolWithAggregatesFilter<"MenuItem"> | boolean
    price?: DecimalWithAggregatesFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string
    maxOrders?: IntNullableWithAggregatesFilter<"MenuItem"> | number | null
    currentOrders?: IntWithAggregatesFilter<"MenuItem"> | number
    isPromotion?: BoolWithAggregatesFilter<"MenuItem"> | boolean
    promotionPrice?: DecimalNullableWithAggregatesFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type DishWhereInput = {
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    id?: StringFilter<"Dish"> | string
    name?: StringFilter<"Dish"> | string
    description?: StringNullableFilter<"Dish"> | string | null
    imageUrl?: StringNullableFilter<"Dish"> | string | null
    category?: StringNullableFilter<"Dish"> | string | null
    calories?: IntNullableFilter<"Dish"> | number | null
    protein?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    carbs?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    fat?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    allergens?: StringNullableListFilter<"Dish">
    dietTags?: StringNullableListFilter<"Dish">
    isActive?: BoolFilter<"Dish"> | boolean
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    menuItems?: MenuItemListRelationFilter
    coupons?: CouponListRelationFilter
  }

  export type DishOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    allergens?: SortOrder
    dietTags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menuItems?: MenuItemOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
  }

  export type DishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    name?: StringFilter<"Dish"> | string
    description?: StringNullableFilter<"Dish"> | string | null
    imageUrl?: StringNullableFilter<"Dish"> | string | null
    category?: StringNullableFilter<"Dish"> | string | null
    calories?: IntNullableFilter<"Dish"> | number | null
    protein?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    carbs?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    fat?: DecimalNullableFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    allergens?: StringNullableListFilter<"Dish">
    dietTags?: StringNullableListFilter<"Dish">
    isActive?: BoolFilter<"Dish"> | boolean
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    menuItems?: MenuItemListRelationFilter
    coupons?: CouponListRelationFilter
  }, "id">

  export type DishOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbs?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    allergens?: SortOrder
    dietTags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DishCountOrderByAggregateInput
    _avg?: DishAvgOrderByAggregateInput
    _max?: DishMaxOrderByAggregateInput
    _min?: DishMinOrderByAggregateInput
    _sum?: DishSumOrderByAggregateInput
  }

  export type DishScalarWhereWithAggregatesInput = {
    AND?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    OR?: DishScalarWhereWithAggregatesInput[]
    NOT?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dish"> | string
    name?: StringWithAggregatesFilter<"Dish"> | string
    description?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    category?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    calories?: IntNullableWithAggregatesFilter<"Dish"> | number | null
    protein?: DecimalNullableWithAggregatesFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    carbs?: DecimalNullableWithAggregatesFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    fat?: DecimalNullableWithAggregatesFilter<"Dish"> | Decimal | DecimalJsLike | number | string | null
    allergens?: StringNullableListFilter<"Dish">
    dietTags?: StringNullableListFilter<"Dish">
    isActive?: BoolWithAggregatesFilter<"Dish"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentIntentId?: StringNullableFilter<"Order"> | string | null
    pickupCode?: StringFilter<"Order"> | string
    pickupDate?: DateTimeFilter<"Order"> | Date | string
    pickupTimeSlot?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    couponCode?: StringNullableFilter<"Order"> | string | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    items?: OrderItemListRelationFilter
    couponRedemptions?: CouponRedemptionListRelationFilter
    employerCompany?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    pickupCode?: SortOrder
    pickupDate?: SortOrder
    pickupTimeSlot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    employerSubsidyAmount?: SortOrderInput | SortOrder
    employerCompanyId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    couponRedemptions?: CouponRedemptionOrderByRelationAggregateInput
    employerCompany?: CompanyOrderByWithRelationInput
    walletTransactions?: WalletTransactionOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pickupCode?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentIntentId?: StringNullableFilter<"Order"> | string | null
    pickupDate?: DateTimeFilter<"Order"> | Date | string
    pickupTimeSlot?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    couponCode?: StringNullableFilter<"Order"> | string | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: StringNullableFilter<"Order"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    location?: XOR<LocationRelationFilter, LocationWhereInput>
    items?: OrderItemListRelationFilter
    couponRedemptions?: CouponRedemptionListRelationFilter
    employerCompany?: XOR<CompanyNullableRelationFilter, CompanyWhereInput> | null
    walletTransactions?: WalletTransactionListRelationFilter
  }, "id" | "pickupCode">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    pickupCode?: SortOrder
    pickupDate?: SortOrder
    pickupTimeSlot?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickedUpAt?: SortOrderInput | SortOrder
    couponCode?: SortOrderInput | SortOrder
    discountAmount?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    employerSubsidyAmount?: SortOrderInput | SortOrder
    employerCompanyId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    locationId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    pickupCode?: StringWithAggregatesFilter<"Order"> | string
    pickupDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    pickupTimeSlot?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    pickedUpAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    couponCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    discountAmount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: DecimalNullableWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType
    discountValue?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: StringNullableFilter<"Coupon"> | string | null
    locationId?: StringNullableFilter<"Coupon"> | string | null
    startDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    maxUsesPerUser?: IntFilter<"Coupon"> | number
    currentUses?: IntFilter<"Coupon"> | number
    minOrderAmount?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    freeItemDish?: XOR<DishNullableRelationFilter, DishWhereInput> | null
    redemptions?: CouponRedemptionListRelationFilter
    incentiveGrants?: IncentiveGrantListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    promotionBanners?: PromotionBannerListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountValue?: SortOrderInput | SortOrder
    freeItemDishId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    freeItemDish?: DishOrderByWithRelationInput
    redemptions?: CouponRedemptionOrderByRelationAggregateInput
    incentiveGrants?: IncentiveGrantOrderByRelationAggregateInput
    segmentIncentives?: SegmentIncentiveOrderByRelationAggregateInput
    promotionBanners?: PromotionBannerOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    name?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType
    discountValue?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: StringNullableFilter<"Coupon"> | string | null
    locationId?: StringNullableFilter<"Coupon"> | string | null
    startDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    maxUsesPerUser?: IntFilter<"Coupon"> | number
    currentUses?: IntFilter<"Coupon"> | number
    minOrderAmount?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    location?: XOR<LocationNullableRelationFilter, LocationWhereInput> | null
    freeItemDish?: XOR<DishNullableRelationFilter, DishWhereInput> | null
    redemptions?: CouponRedemptionListRelationFilter
    incentiveGrants?: IncentiveGrantListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    promotionBanners?: PromotionBannerListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountValue?: SortOrderInput | SortOrder
    freeItemDishId?: SortOrderInput | SortOrder
    locationId?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    name?: StringWithAggregatesFilter<"Coupon"> | string
    description?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    type?: EnumCouponTypeWithAggregatesFilter<"Coupon"> | $Enums.CouponType
    discountValue?: DecimalNullableWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    locationId?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Coupon"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    maxUsesPerUser?: IntWithAggregatesFilter<"Coupon"> | number
    currentUses?: IntWithAggregatesFilter<"Coupon"> | number
    minOrderAmount?: DecimalNullableWithAggregatesFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Coupon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type CouponRedemptionWhereInput = {
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringFilter<"CouponRedemption"> | string
    orderId?: StringFilter<"CouponRedemption"> | string
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
    coupon?: XOR<CouponRelationFilter, CouponWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type CouponRedemptionOrderByWithRelationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
    coupon?: CouponOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type CouponRedemptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    couponId_userId_orderId?: CouponRedemptionCouponIdUserIdOrderIdCompoundUniqueInput
    AND?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    OR?: CouponRedemptionWhereInput[]
    NOT?: CouponRedemptionWhereInput | CouponRedemptionWhereInput[]
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringFilter<"CouponRedemption"> | string
    orderId?: StringFilter<"CouponRedemption"> | string
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
    coupon?: XOR<CouponRelationFilter, CouponWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "couponId_userId_orderId">

  export type CouponRedemptionOrderByWithAggregationInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
    _count?: CouponRedemptionCountOrderByAggregateInput
    _max?: CouponRedemptionMaxOrderByAggregateInput
    _min?: CouponRedemptionMinOrderByAggregateInput
  }

  export type CouponRedemptionScalarWhereWithAggregatesInput = {
    AND?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    OR?: CouponRedemptionScalarWhereWithAggregatesInput[]
    NOT?: CouponRedemptionScalarWhereWithAggregatesInput | CouponRedemptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CouponRedemption"> | string
    couponId?: StringWithAggregatesFilter<"CouponRedemption"> | string
    userId?: StringWithAggregatesFilter<"CouponRedemption"> | string
    orderId?: StringWithAggregatesFilter<"CouponRedemption"> | string
    redeemedAt?: DateTimeWithAggregatesFilter<"CouponRedemption"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    menuItemId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    menuItem?: XOR<MenuItemRelationFilter, MenuItemWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    menuItem?: MenuItemOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    menuItemId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    menuItem?: XOR<MenuItemRelationFilter, MenuItemWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    menuItemId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type MetadataWhereInput = {
    AND?: MetadataWhereInput | MetadataWhereInput[]
    OR?: MetadataWhereInput[]
    NOT?: MetadataWhereInput | MetadataWhereInput[]
    id?: StringFilter<"Metadata"> | string
    type?: EnumMetadataTypeFilter<"Metadata"> | $Enums.MetadataType
    name?: StringFilter<"Metadata"> | string
    description?: StringNullableFilter<"Metadata"> | string | null
    icon?: StringNullableFilter<"Metadata"> | string | null
    color?: StringNullableFilter<"Metadata"> | string | null
    isActive?: BoolFilter<"Metadata"> | boolean
    sortOrder?: IntFilter<"Metadata"> | number
    createdAt?: DateTimeFilter<"Metadata"> | Date | string
    updatedAt?: DateTimeFilter<"Metadata"> | Date | string
  }

  export type MetadataOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_name?: MetadataTypeNameCompoundUniqueInput
    AND?: MetadataWhereInput | MetadataWhereInput[]
    OR?: MetadataWhereInput[]
    NOT?: MetadataWhereInput | MetadataWhereInput[]
    type?: EnumMetadataTypeFilter<"Metadata"> | $Enums.MetadataType
    name?: StringFilter<"Metadata"> | string
    description?: StringNullableFilter<"Metadata"> | string | null
    icon?: StringNullableFilter<"Metadata"> | string | null
    color?: StringNullableFilter<"Metadata"> | string | null
    isActive?: BoolFilter<"Metadata"> | boolean
    sortOrder?: IntFilter<"Metadata"> | number
    createdAt?: DateTimeFilter<"Metadata"> | Date | string
    updatedAt?: DateTimeFilter<"Metadata"> | Date | string
  }, "id" | "type_name">

  export type MetadataOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MetadataCountOrderByAggregateInput
    _avg?: MetadataAvgOrderByAggregateInput
    _max?: MetadataMaxOrderByAggregateInput
    _min?: MetadataMinOrderByAggregateInput
    _sum?: MetadataSumOrderByAggregateInput
  }

  export type MetadataScalarWhereWithAggregatesInput = {
    AND?: MetadataScalarWhereWithAggregatesInput | MetadataScalarWhereWithAggregatesInput[]
    OR?: MetadataScalarWhereWithAggregatesInput[]
    NOT?: MetadataScalarWhereWithAggregatesInput | MetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Metadata"> | string
    type?: EnumMetadataTypeWithAggregatesFilter<"Metadata"> | $Enums.MetadataType
    name?: StringWithAggregatesFilter<"Metadata"> | string
    description?: StringNullableWithAggregatesFilter<"Metadata"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Metadata"> | string | null
    color?: StringNullableWithAggregatesFilter<"Metadata"> | string | null
    isActive?: BoolWithAggregatesFilter<"Metadata"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Metadata"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Metadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Metadata"> | Date | string
  }

  export type CustomerSegmentWhereInput = {
    AND?: CustomerSegmentWhereInput | CustomerSegmentWhereInput[]
    OR?: CustomerSegmentWhereInput[]
    NOT?: CustomerSegmentWhereInput | CustomerSegmentWhereInput[]
    id?: StringFilter<"CustomerSegment"> | string
    organizationId?: StringFilter<"CustomerSegment"> | string
    name?: StringFilter<"CustomerSegment"> | string
    description?: StringNullableFilter<"CustomerSegment"> | string | null
    rulesCombination?: StringFilter<"CustomerSegment"> | string
    rules?: JsonFilter<"CustomerSegment">
    createdAt?: DateTimeFilter<"CustomerSegment"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSegment"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    inAppMessages?: InAppMessageListRelationFilter
    workflows?: MarketingWorkflowListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
  }

  export type CustomerSegmentOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rulesCombination?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    inAppMessages?: InAppMessageOrderByRelationAggregateInput
    workflows?: MarketingWorkflowOrderByRelationAggregateInput
    segmentIncentives?: SegmentIncentiveOrderByRelationAggregateInput
    pushNotifications?: PushNotificationOrderByRelationAggregateInput
  }

  export type CustomerSegmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_name?: CustomerSegmentOrganizationIdNameCompoundUniqueInput
    AND?: CustomerSegmentWhereInput | CustomerSegmentWhereInput[]
    OR?: CustomerSegmentWhereInput[]
    NOT?: CustomerSegmentWhereInput | CustomerSegmentWhereInput[]
    organizationId?: StringFilter<"CustomerSegment"> | string
    name?: StringFilter<"CustomerSegment"> | string
    description?: StringNullableFilter<"CustomerSegment"> | string | null
    rulesCombination?: StringFilter<"CustomerSegment"> | string
    rules?: JsonFilter<"CustomerSegment">
    createdAt?: DateTimeFilter<"CustomerSegment"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSegment"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    inAppMessages?: InAppMessageListRelationFilter
    workflows?: MarketingWorkflowListRelationFilter
    segmentIncentives?: SegmentIncentiveListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
  }, "id" | "organizationId_name">

  export type CustomerSegmentOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rulesCombination?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerSegmentCountOrderByAggregateInput
    _max?: CustomerSegmentMaxOrderByAggregateInput
    _min?: CustomerSegmentMinOrderByAggregateInput
  }

  export type CustomerSegmentScalarWhereWithAggregatesInput = {
    AND?: CustomerSegmentScalarWhereWithAggregatesInput | CustomerSegmentScalarWhereWithAggregatesInput[]
    OR?: CustomerSegmentScalarWhereWithAggregatesInput[]
    NOT?: CustomerSegmentScalarWhereWithAggregatesInput | CustomerSegmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerSegment"> | string
    organizationId?: StringWithAggregatesFilter<"CustomerSegment"> | string
    name?: StringWithAggregatesFilter<"CustomerSegment"> | string
    description?: StringNullableWithAggregatesFilter<"CustomerSegment"> | string | null
    rulesCombination?: StringWithAggregatesFilter<"CustomerSegment"> | string
    rules?: JsonWithAggregatesFilter<"CustomerSegment">
    createdAt?: DateTimeWithAggregatesFilter<"CustomerSegment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerSegment"> | Date | string
  }

  export type InAppMessageWhereInput = {
    AND?: InAppMessageWhereInput | InAppMessageWhereInput[]
    OR?: InAppMessageWhereInput[]
    NOT?: InAppMessageWhereInput | InAppMessageWhereInput[]
    id?: StringFilter<"InAppMessage"> | string
    organizationId?: StringFilter<"InAppMessage"> | string
    segmentId?: StringFilter<"InAppMessage"> | string
    title?: StringNullableFilter<"InAppMessage"> | string | null
    body?: StringFilter<"InAppMessage"> | string
    linkUrl?: StringNullableFilter<"InAppMessage"> | string | null
    displayPlace?: StringFilter<"InAppMessage"> | string
    displayType?: StringFilter<"InAppMessage"> | string
    slotId?: StringNullableFilter<"InAppMessage"> | string | null
    startDate?: DateTimeFilter<"InAppMessage"> | Date | string
    endDate?: DateTimeNullableFilter<"InAppMessage"> | Date | string | null
    isActive?: BoolFilter<"InAppMessage"> | boolean
    marketingTemplateId?: StringNullableFilter<"InAppMessage"> | string | null
    templateSnapshot?: JsonNullableFilter<"InAppMessage">
    createdAt?: DateTimeFilter<"InAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"InAppMessage"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    readBy?: InAppMessageReadListRelationFilter
  }

  export type InAppMessageOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    displayPlace?: SortOrder
    displayType?: SortOrder
    slotId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    segment?: CustomerSegmentOrderByWithRelationInput
    marketingTemplate?: MarketingTemplateOrderByWithRelationInput
    readBy?: InAppMessageReadOrderByRelationAggregateInput
  }

  export type InAppMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InAppMessageWhereInput | InAppMessageWhereInput[]
    OR?: InAppMessageWhereInput[]
    NOT?: InAppMessageWhereInput | InAppMessageWhereInput[]
    organizationId?: StringFilter<"InAppMessage"> | string
    segmentId?: StringFilter<"InAppMessage"> | string
    title?: StringNullableFilter<"InAppMessage"> | string | null
    body?: StringFilter<"InAppMessage"> | string
    linkUrl?: StringNullableFilter<"InAppMessage"> | string | null
    displayPlace?: StringFilter<"InAppMessage"> | string
    displayType?: StringFilter<"InAppMessage"> | string
    slotId?: StringNullableFilter<"InAppMessage"> | string | null
    startDate?: DateTimeFilter<"InAppMessage"> | Date | string
    endDate?: DateTimeNullableFilter<"InAppMessage"> | Date | string | null
    isActive?: BoolFilter<"InAppMessage"> | boolean
    marketingTemplateId?: StringNullableFilter<"InAppMessage"> | string | null
    templateSnapshot?: JsonNullableFilter<"InAppMessage">
    createdAt?: DateTimeFilter<"InAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"InAppMessage"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    readBy?: InAppMessageReadListRelationFilter
  }, "id">

  export type InAppMessageOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    title?: SortOrderInput | SortOrder
    body?: SortOrder
    linkUrl?: SortOrderInput | SortOrder
    displayPlace?: SortOrder
    displayType?: SortOrder
    slotId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InAppMessageCountOrderByAggregateInput
    _max?: InAppMessageMaxOrderByAggregateInput
    _min?: InAppMessageMinOrderByAggregateInput
  }

  export type InAppMessageScalarWhereWithAggregatesInput = {
    AND?: InAppMessageScalarWhereWithAggregatesInput | InAppMessageScalarWhereWithAggregatesInput[]
    OR?: InAppMessageScalarWhereWithAggregatesInput[]
    NOT?: InAppMessageScalarWhereWithAggregatesInput | InAppMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InAppMessage"> | string
    organizationId?: StringWithAggregatesFilter<"InAppMessage"> | string
    segmentId?: StringWithAggregatesFilter<"InAppMessage"> | string
    title?: StringNullableWithAggregatesFilter<"InAppMessage"> | string | null
    body?: StringWithAggregatesFilter<"InAppMessage"> | string
    linkUrl?: StringNullableWithAggregatesFilter<"InAppMessage"> | string | null
    displayPlace?: StringWithAggregatesFilter<"InAppMessage"> | string
    displayType?: StringWithAggregatesFilter<"InAppMessage"> | string
    slotId?: StringNullableWithAggregatesFilter<"InAppMessage"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"InAppMessage"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"InAppMessage"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"InAppMessage"> | boolean
    marketingTemplateId?: StringNullableWithAggregatesFilter<"InAppMessage"> | string | null
    templateSnapshot?: JsonNullableWithAggregatesFilter<"InAppMessage">
    createdAt?: DateTimeWithAggregatesFilter<"InAppMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InAppMessage"> | Date | string
  }

  export type InAppMessageReadWhereInput = {
    AND?: InAppMessageReadWhereInput | InAppMessageReadWhereInput[]
    OR?: InAppMessageReadWhereInput[]
    NOT?: InAppMessageReadWhereInput | InAppMessageReadWhereInput[]
    id?: StringFilter<"InAppMessageRead"> | string
    messageId?: StringFilter<"InAppMessageRead"> | string
    userId?: StringFilter<"InAppMessageRead"> | string
    readAt?: DateTimeFilter<"InAppMessageRead"> | Date | string
    message?: XOR<InAppMessageRelationFilter, InAppMessageWhereInput>
  }

  export type InAppMessageReadOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: InAppMessageOrderByWithRelationInput
  }

  export type InAppMessageReadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: InAppMessageReadMessageIdUserIdCompoundUniqueInput
    AND?: InAppMessageReadWhereInput | InAppMessageReadWhereInput[]
    OR?: InAppMessageReadWhereInput[]
    NOT?: InAppMessageReadWhereInput | InAppMessageReadWhereInput[]
    messageId?: StringFilter<"InAppMessageRead"> | string
    userId?: StringFilter<"InAppMessageRead"> | string
    readAt?: DateTimeFilter<"InAppMessageRead"> | Date | string
    message?: XOR<InAppMessageRelationFilter, InAppMessageWhereInput>
  }, "id" | "messageId_userId">

  export type InAppMessageReadOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: InAppMessageReadCountOrderByAggregateInput
    _max?: InAppMessageReadMaxOrderByAggregateInput
    _min?: InAppMessageReadMinOrderByAggregateInput
  }

  export type InAppMessageReadScalarWhereWithAggregatesInput = {
    AND?: InAppMessageReadScalarWhereWithAggregatesInput | InAppMessageReadScalarWhereWithAggregatesInput[]
    OR?: InAppMessageReadScalarWhereWithAggregatesInput[]
    NOT?: InAppMessageReadScalarWhereWithAggregatesInput | InAppMessageReadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InAppMessageRead"> | string
    messageId?: StringWithAggregatesFilter<"InAppMessageRead"> | string
    userId?: StringWithAggregatesFilter<"InAppMessageRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"InAppMessageRead"> | Date | string
  }

  export type MarketingWorkflowWhereInput = {
    AND?: MarketingWorkflowWhereInput | MarketingWorkflowWhereInput[]
    OR?: MarketingWorkflowWhereInput[]
    NOT?: MarketingWorkflowWhereInput | MarketingWorkflowWhereInput[]
    id?: StringFilter<"MarketingWorkflow"> | string
    organizationId?: StringFilter<"MarketingWorkflow"> | string
    segmentId?: StringFilter<"MarketingWorkflow"> | string
    name?: StringFilter<"MarketingWorkflow"> | string
    triggerType?: StringFilter<"MarketingWorkflow"> | string
    triggerConfig?: JsonFilter<"MarketingWorkflow">
    actionType?: StringFilter<"MarketingWorkflow"> | string
    actionConfig?: JsonFilter<"MarketingWorkflow">
    isActive?: BoolFilter<"MarketingWorkflow"> | boolean
    createdAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    executionLogs?: WorkflowExecutionLogListRelationFilter
  }

  export type MarketingWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    segment?: CustomerSegmentOrderByWithRelationInput
    executionLogs?: WorkflowExecutionLogOrderByRelationAggregateInput
  }

  export type MarketingWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingWorkflowWhereInput | MarketingWorkflowWhereInput[]
    OR?: MarketingWorkflowWhereInput[]
    NOT?: MarketingWorkflowWhereInput | MarketingWorkflowWhereInput[]
    organizationId?: StringFilter<"MarketingWorkflow"> | string
    segmentId?: StringFilter<"MarketingWorkflow"> | string
    name?: StringFilter<"MarketingWorkflow"> | string
    triggerType?: StringFilter<"MarketingWorkflow"> | string
    triggerConfig?: JsonFilter<"MarketingWorkflow">
    actionType?: StringFilter<"MarketingWorkflow"> | string
    actionConfig?: JsonFilter<"MarketingWorkflow">
    isActive?: BoolFilter<"MarketingWorkflow"> | boolean
    createdAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    executionLogs?: WorkflowExecutionLogListRelationFilter
  }, "id">

  export type MarketingWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingWorkflowCountOrderByAggregateInput
    _max?: MarketingWorkflowMaxOrderByAggregateInput
    _min?: MarketingWorkflowMinOrderByAggregateInput
  }

  export type MarketingWorkflowScalarWhereWithAggregatesInput = {
    AND?: MarketingWorkflowScalarWhereWithAggregatesInput | MarketingWorkflowScalarWhereWithAggregatesInput[]
    OR?: MarketingWorkflowScalarWhereWithAggregatesInput[]
    NOT?: MarketingWorkflowScalarWhereWithAggregatesInput | MarketingWorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    organizationId?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    segmentId?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    name?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    triggerType?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    triggerConfig?: JsonWithAggregatesFilter<"MarketingWorkflow">
    actionType?: StringWithAggregatesFilter<"MarketingWorkflow"> | string
    actionConfig?: JsonWithAggregatesFilter<"MarketingWorkflow">
    isActive?: BoolWithAggregatesFilter<"MarketingWorkflow"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MarketingWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingWorkflow"> | Date | string
  }

  export type WorkflowExecutionLogWhereInput = {
    AND?: WorkflowExecutionLogWhereInput | WorkflowExecutionLogWhereInput[]
    OR?: WorkflowExecutionLogWhereInput[]
    NOT?: WorkflowExecutionLogWhereInput | WorkflowExecutionLogWhereInput[]
    id?: StringFilter<"WorkflowExecutionLog"> | string
    workflowId?: StringFilter<"WorkflowExecutionLog"> | string
    executedAt?: DateTimeFilter<"WorkflowExecutionLog"> | Date | string
    status?: StringFilter<"WorkflowExecutionLog"> | string
    message?: StringNullableFilter<"WorkflowExecutionLog"> | string | null
    details?: JsonNullableFilter<"WorkflowExecutionLog">
    workflow?: XOR<MarketingWorkflowRelationFilter, MarketingWorkflowWhereInput>
  }

  export type WorkflowExecutionLogOrderByWithRelationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    workflow?: MarketingWorkflowOrderByWithRelationInput
  }

  export type WorkflowExecutionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkflowExecutionLogWhereInput | WorkflowExecutionLogWhereInput[]
    OR?: WorkflowExecutionLogWhereInput[]
    NOT?: WorkflowExecutionLogWhereInput | WorkflowExecutionLogWhereInput[]
    workflowId?: StringFilter<"WorkflowExecutionLog"> | string
    executedAt?: DateTimeFilter<"WorkflowExecutionLog"> | Date | string
    status?: StringFilter<"WorkflowExecutionLog"> | string
    message?: StringNullableFilter<"WorkflowExecutionLog"> | string | null
    details?: JsonNullableFilter<"WorkflowExecutionLog">
    workflow?: XOR<MarketingWorkflowRelationFilter, MarketingWorkflowWhereInput>
  }, "id">

  export type WorkflowExecutionLogOrderByWithAggregationInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: WorkflowExecutionLogCountOrderByAggregateInput
    _max?: WorkflowExecutionLogMaxOrderByAggregateInput
    _min?: WorkflowExecutionLogMinOrderByAggregateInput
  }

  export type WorkflowExecutionLogScalarWhereWithAggregatesInput = {
    AND?: WorkflowExecutionLogScalarWhereWithAggregatesInput | WorkflowExecutionLogScalarWhereWithAggregatesInput[]
    OR?: WorkflowExecutionLogScalarWhereWithAggregatesInput[]
    NOT?: WorkflowExecutionLogScalarWhereWithAggregatesInput | WorkflowExecutionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowExecutionLog"> | string
    workflowId?: StringWithAggregatesFilter<"WorkflowExecutionLog"> | string
    executedAt?: DateTimeWithAggregatesFilter<"WorkflowExecutionLog"> | Date | string
    status?: StringWithAggregatesFilter<"WorkflowExecutionLog"> | string
    message?: StringNullableWithAggregatesFilter<"WorkflowExecutionLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"WorkflowExecutionLog">
  }

  export type SegmentIncentiveWhereInput = {
    AND?: SegmentIncentiveWhereInput | SegmentIncentiveWhereInput[]
    OR?: SegmentIncentiveWhereInput[]
    NOT?: SegmentIncentiveWhereInput | SegmentIncentiveWhereInput[]
    id?: StringFilter<"SegmentIncentive"> | string
    organizationId?: StringFilter<"SegmentIncentive"> | string
    segmentId?: StringFilter<"SegmentIncentive"> | string
    name?: StringNullableFilter<"SegmentIncentive"> | string | null
    incentiveType?: StringFilter<"SegmentIncentive"> | string
    couponId?: StringNullableFilter<"SegmentIncentive"> | string | null
    personaliseCoupon?: BoolFilter<"SegmentIncentive"> | boolean
    walletAmount?: DecimalNullableFilter<"SegmentIncentive"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"SegmentIncentive"> | Date | string
    endDate?: DateTimeNullableFilter<"SegmentIncentive"> | Date | string | null
    maxGrantsPerUser?: IntFilter<"SegmentIncentive"> | number
    displayChannel?: StringFilter<"SegmentIncentive"> | string
    isActive?: BoolFilter<"SegmentIncentive"> | boolean
    createdAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
    updatedAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    grants?: IncentiveGrantListRelationFilter
  }

  export type SegmentIncentiveOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrderInput | SortOrder
    incentiveType?: SortOrder
    couponId?: SortOrderInput | SortOrder
    personaliseCoupon?: SortOrder
    walletAmount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxGrantsPerUser?: SortOrder
    displayChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    segment?: CustomerSegmentOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
    grants?: IncentiveGrantOrderByRelationAggregateInput
  }

  export type SegmentIncentiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SegmentIncentiveWhereInput | SegmentIncentiveWhereInput[]
    OR?: SegmentIncentiveWhereInput[]
    NOT?: SegmentIncentiveWhereInput | SegmentIncentiveWhereInput[]
    organizationId?: StringFilter<"SegmentIncentive"> | string
    segmentId?: StringFilter<"SegmentIncentive"> | string
    name?: StringNullableFilter<"SegmentIncentive"> | string | null
    incentiveType?: StringFilter<"SegmentIncentive"> | string
    couponId?: StringNullableFilter<"SegmentIncentive"> | string | null
    personaliseCoupon?: BoolFilter<"SegmentIncentive"> | boolean
    walletAmount?: DecimalNullableFilter<"SegmentIncentive"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"SegmentIncentive"> | Date | string
    endDate?: DateTimeNullableFilter<"SegmentIncentive"> | Date | string | null
    maxGrantsPerUser?: IntFilter<"SegmentIncentive"> | number
    displayChannel?: StringFilter<"SegmentIncentive"> | string
    isActive?: BoolFilter<"SegmentIncentive"> | boolean
    createdAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
    updatedAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    grants?: IncentiveGrantListRelationFilter
  }, "id">

  export type SegmentIncentiveOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrderInput | SortOrder
    incentiveType?: SortOrder
    couponId?: SortOrderInput | SortOrder
    personaliseCoupon?: SortOrder
    walletAmount?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    maxGrantsPerUser?: SortOrder
    displayChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SegmentIncentiveCountOrderByAggregateInput
    _avg?: SegmentIncentiveAvgOrderByAggregateInput
    _max?: SegmentIncentiveMaxOrderByAggregateInput
    _min?: SegmentIncentiveMinOrderByAggregateInput
    _sum?: SegmentIncentiveSumOrderByAggregateInput
  }

  export type SegmentIncentiveScalarWhereWithAggregatesInput = {
    AND?: SegmentIncentiveScalarWhereWithAggregatesInput | SegmentIncentiveScalarWhereWithAggregatesInput[]
    OR?: SegmentIncentiveScalarWhereWithAggregatesInput[]
    NOT?: SegmentIncentiveScalarWhereWithAggregatesInput | SegmentIncentiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SegmentIncentive"> | string
    organizationId?: StringWithAggregatesFilter<"SegmentIncentive"> | string
    segmentId?: StringWithAggregatesFilter<"SegmentIncentive"> | string
    name?: StringNullableWithAggregatesFilter<"SegmentIncentive"> | string | null
    incentiveType?: StringWithAggregatesFilter<"SegmentIncentive"> | string
    couponId?: StringNullableWithAggregatesFilter<"SegmentIncentive"> | string | null
    personaliseCoupon?: BoolWithAggregatesFilter<"SegmentIncentive"> | boolean
    walletAmount?: DecimalNullableWithAggregatesFilter<"SegmentIncentive"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeWithAggregatesFilter<"SegmentIncentive"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"SegmentIncentive"> | Date | string | null
    maxGrantsPerUser?: IntWithAggregatesFilter<"SegmentIncentive"> | number
    displayChannel?: StringWithAggregatesFilter<"SegmentIncentive"> | string
    isActive?: BoolWithAggregatesFilter<"SegmentIncentive"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SegmentIncentive"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SegmentIncentive"> | Date | string
  }

  export type MarketingTemplateWhereInput = {
    AND?: MarketingTemplateWhereInput | MarketingTemplateWhereInput[]
    OR?: MarketingTemplateWhereInput[]
    NOT?: MarketingTemplateWhereInput | MarketingTemplateWhereInput[]
    id?: StringFilter<"MarketingTemplate"> | string
    organizationId?: StringNullableFilter<"MarketingTemplate"> | string | null
    name?: StringFilter<"MarketingTemplate"> | string
    type?: EnumMarketingTemplateTypeFilter<"MarketingTemplate"> | $Enums.MarketingTemplateType
    content?: JsonFilter<"MarketingTemplate">
    status?: EnumMarketingTemplateStatusFilter<"MarketingTemplate"> | $Enums.MarketingTemplateStatus
    isStarter?: BoolFilter<"MarketingTemplate"> | boolean
    isFavorite?: BoolFilter<"MarketingTemplate"> | boolean
    thumbnailUrl?: StringNullableFilter<"MarketingTemplate"> | string | null
    createdAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    inAppMessages?: InAppMessageListRelationFilter
    promotionBanners?: PromotionBannerListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
  }

  export type MarketingTemplateOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isStarter?: SortOrder
    isFavorite?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    inAppMessages?: InAppMessageOrderByRelationAggregateInput
    promotionBanners?: PromotionBannerOrderByRelationAggregateInput
    pushNotifications?: PushNotificationOrderByRelationAggregateInput
  }

  export type MarketingTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingTemplateWhereInput | MarketingTemplateWhereInput[]
    OR?: MarketingTemplateWhereInput[]
    NOT?: MarketingTemplateWhereInput | MarketingTemplateWhereInput[]
    organizationId?: StringNullableFilter<"MarketingTemplate"> | string | null
    name?: StringFilter<"MarketingTemplate"> | string
    type?: EnumMarketingTemplateTypeFilter<"MarketingTemplate"> | $Enums.MarketingTemplateType
    content?: JsonFilter<"MarketingTemplate">
    status?: EnumMarketingTemplateStatusFilter<"MarketingTemplate"> | $Enums.MarketingTemplateStatus
    isStarter?: BoolFilter<"MarketingTemplate"> | boolean
    isFavorite?: BoolFilter<"MarketingTemplate"> | boolean
    thumbnailUrl?: StringNullableFilter<"MarketingTemplate"> | string | null
    createdAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    inAppMessages?: InAppMessageListRelationFilter
    promotionBanners?: PromotionBannerListRelationFilter
    pushNotifications?: PushNotificationListRelationFilter
  }, "id">

  export type MarketingTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isStarter?: SortOrder
    isFavorite?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingTemplateCountOrderByAggregateInput
    _max?: MarketingTemplateMaxOrderByAggregateInput
    _min?: MarketingTemplateMinOrderByAggregateInput
  }

  export type MarketingTemplateScalarWhereWithAggregatesInput = {
    AND?: MarketingTemplateScalarWhereWithAggregatesInput | MarketingTemplateScalarWhereWithAggregatesInput[]
    OR?: MarketingTemplateScalarWhereWithAggregatesInput[]
    NOT?: MarketingTemplateScalarWhereWithAggregatesInput | MarketingTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingTemplate"> | string
    organizationId?: StringNullableWithAggregatesFilter<"MarketingTemplate"> | string | null
    name?: StringWithAggregatesFilter<"MarketingTemplate"> | string
    type?: EnumMarketingTemplateTypeWithAggregatesFilter<"MarketingTemplate"> | $Enums.MarketingTemplateType
    content?: JsonWithAggregatesFilter<"MarketingTemplate">
    status?: EnumMarketingTemplateStatusWithAggregatesFilter<"MarketingTemplate"> | $Enums.MarketingTemplateStatus
    isStarter?: BoolWithAggregatesFilter<"MarketingTemplate"> | boolean
    isFavorite?: BoolWithAggregatesFilter<"MarketingTemplate"> | boolean
    thumbnailUrl?: StringNullableWithAggregatesFilter<"MarketingTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingTemplate"> | Date | string
  }

  export type PushNotificationWhereInput = {
    AND?: PushNotificationWhereInput | PushNotificationWhereInput[]
    OR?: PushNotificationWhereInput[]
    NOT?: PushNotificationWhereInput | PushNotificationWhereInput[]
    id?: StringFilter<"PushNotification"> | string
    organizationId?: StringFilter<"PushNotification"> | string
    segmentId?: StringFilter<"PushNotification"> | string
    marketingTemplateId?: StringNullableFilter<"PushNotification"> | string | null
    templateSnapshot?: JsonNullableFilter<"PushNotification">
    pushTitle?: StringFilter<"PushNotification"> | string
    pushBody?: StringFilter<"PushNotification"> | string
    deepLink?: StringNullableFilter<"PushNotification"> | string | null
    status?: EnumPushNotificationStatusFilter<"PushNotification"> | $Enums.PushNotificationStatus
    scheduledAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    totalRecipients?: IntFilter<"PushNotification"> | number
    createdAt?: DateTimeFilter<"PushNotification"> | Date | string
    updatedAt?: DateTimeFilter<"PushNotification"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    logs?: PushNotificationLogListRelationFilter
  }

  export type PushNotificationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    pushTitle?: SortOrder
    pushBody?: SortOrder
    deepLink?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    totalRecipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    segment?: CustomerSegmentOrderByWithRelationInput
    marketingTemplate?: MarketingTemplateOrderByWithRelationInput
    logs?: PushNotificationLogOrderByRelationAggregateInput
  }

  export type PushNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PushNotificationWhereInput | PushNotificationWhereInput[]
    OR?: PushNotificationWhereInput[]
    NOT?: PushNotificationWhereInput | PushNotificationWhereInput[]
    organizationId?: StringFilter<"PushNotification"> | string
    segmentId?: StringFilter<"PushNotification"> | string
    marketingTemplateId?: StringNullableFilter<"PushNotification"> | string | null
    templateSnapshot?: JsonNullableFilter<"PushNotification">
    pushTitle?: StringFilter<"PushNotification"> | string
    pushBody?: StringFilter<"PushNotification"> | string
    deepLink?: StringNullableFilter<"PushNotification"> | string | null
    status?: EnumPushNotificationStatusFilter<"PushNotification"> | $Enums.PushNotificationStatus
    scheduledAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    totalRecipients?: IntFilter<"PushNotification"> | number
    createdAt?: DateTimeFilter<"PushNotification"> | Date | string
    updatedAt?: DateTimeFilter<"PushNotification"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    segment?: XOR<CustomerSegmentRelationFilter, CustomerSegmentWhereInput>
    marketingTemplate?: XOR<MarketingTemplateNullableRelationFilter, MarketingTemplateWhereInput> | null
    logs?: PushNotificationLogListRelationFilter
  }, "id">

  export type PushNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    marketingTemplateId?: SortOrderInput | SortOrder
    templateSnapshot?: SortOrderInput | SortOrder
    pushTitle?: SortOrder
    pushBody?: SortOrder
    deepLink?: SortOrderInput | SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    totalRecipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PushNotificationCountOrderByAggregateInput
    _avg?: PushNotificationAvgOrderByAggregateInput
    _max?: PushNotificationMaxOrderByAggregateInput
    _min?: PushNotificationMinOrderByAggregateInput
    _sum?: PushNotificationSumOrderByAggregateInput
  }

  export type PushNotificationScalarWhereWithAggregatesInput = {
    AND?: PushNotificationScalarWhereWithAggregatesInput | PushNotificationScalarWhereWithAggregatesInput[]
    OR?: PushNotificationScalarWhereWithAggregatesInput[]
    NOT?: PushNotificationScalarWhereWithAggregatesInput | PushNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushNotification"> | string
    organizationId?: StringWithAggregatesFilter<"PushNotification"> | string
    segmentId?: StringWithAggregatesFilter<"PushNotification"> | string
    marketingTemplateId?: StringNullableWithAggregatesFilter<"PushNotification"> | string | null
    templateSnapshot?: JsonNullableWithAggregatesFilter<"PushNotification">
    pushTitle?: StringWithAggregatesFilter<"PushNotification"> | string
    pushBody?: StringWithAggregatesFilter<"PushNotification"> | string
    deepLink?: StringNullableWithAggregatesFilter<"PushNotification"> | string | null
    status?: EnumPushNotificationStatusWithAggregatesFilter<"PushNotification"> | $Enums.PushNotificationStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"PushNotification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"PushNotification"> | Date | string | null
    totalRecipients?: IntWithAggregatesFilter<"PushNotification"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PushNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushNotification"> | Date | string
  }

  export type PushNotificationLogWhereInput = {
    AND?: PushNotificationLogWhereInput | PushNotificationLogWhereInput[]
    OR?: PushNotificationLogWhereInput[]
    NOT?: PushNotificationLogWhereInput | PushNotificationLogWhereInput[]
    id?: StringFilter<"PushNotificationLog"> | string
    pushNotificationId?: StringFilter<"PushNotificationLog"> | string
    userId?: StringFilter<"PushNotificationLog"> | string
    status?: EnumPushDeliveryStatusFilter<"PushNotificationLog"> | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFilter<"PushNotificationLog"> | Date | string
    pushNotification?: XOR<PushNotificationRelationFilter, PushNotificationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PushNotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    pushNotificationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    pushNotification?: PushNotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PushNotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pushNotificationId_userId?: PushNotificationLogPushNotificationIdUserIdCompoundUniqueInput
    AND?: PushNotificationLogWhereInput | PushNotificationLogWhereInput[]
    OR?: PushNotificationLogWhereInput[]
    NOT?: PushNotificationLogWhereInput | PushNotificationLogWhereInput[]
    pushNotificationId?: StringFilter<"PushNotificationLog"> | string
    userId?: StringFilter<"PushNotificationLog"> | string
    status?: EnumPushDeliveryStatusFilter<"PushNotificationLog"> | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFilter<"PushNotificationLog"> | Date | string
    pushNotification?: XOR<PushNotificationRelationFilter, PushNotificationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "pushNotificationId_userId">

  export type PushNotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    pushNotificationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    _count?: PushNotificationLogCountOrderByAggregateInput
    _max?: PushNotificationLogMaxOrderByAggregateInput
    _min?: PushNotificationLogMinOrderByAggregateInput
  }

  export type PushNotificationLogScalarWhereWithAggregatesInput = {
    AND?: PushNotificationLogScalarWhereWithAggregatesInput | PushNotificationLogScalarWhereWithAggregatesInput[]
    OR?: PushNotificationLogScalarWhereWithAggregatesInput[]
    NOT?: PushNotificationLogScalarWhereWithAggregatesInput | PushNotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushNotificationLog"> | string
    pushNotificationId?: StringWithAggregatesFilter<"PushNotificationLog"> | string
    userId?: StringWithAggregatesFilter<"PushNotificationLog"> | string
    status?: EnumPushDeliveryStatusWithAggregatesFilter<"PushNotificationLog"> | $Enums.PushDeliveryStatus
    sentAt?: DateTimeWithAggregatesFilter<"PushNotificationLog"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dhKey?: StringFilter<"PushSubscription"> | string
    authKey?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dhKey?: SortOrder
    authKey?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_endpoint?: PushSubscriptionUserIdEndpointCompoundUniqueInput
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dhKey?: StringFilter<"PushSubscription"> | string
    authKey?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dhKey?: SortOrder
    authKey?: SortOrder
    createdAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dhKey?: StringWithAggregatesFilter<"PushSubscription"> | string
    authKey?: StringWithAggregatesFilter<"PushSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type PaymentProviderConfigWhereInput = {
    AND?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    OR?: PaymentProviderConfigWhereInput[]
    NOT?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    id?: StringFilter<"PaymentProviderConfig"> | string
    organizationId?: StringFilter<"PaymentProviderConfig"> | string
    provider?: StringFilter<"PaymentProviderConfig"> | string
    isEnabled?: BoolFilter<"PaymentProviderConfig"> | boolean
    configJson?: StringFilter<"PaymentProviderConfig"> | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedById?: StringNullableFilter<"PaymentProviderConfig"> | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PaymentProviderConfigOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    isEnabled?: SortOrder
    configJson?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type PaymentProviderConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_provider?: PaymentProviderConfigOrganizationIdProviderCompoundUniqueInput
    AND?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    OR?: PaymentProviderConfigWhereInput[]
    NOT?: PaymentProviderConfigWhereInput | PaymentProviderConfigWhereInput[]
    organizationId?: StringFilter<"PaymentProviderConfig"> | string
    provider?: StringFilter<"PaymentProviderConfig"> | string
    isEnabled?: BoolFilter<"PaymentProviderConfig"> | boolean
    configJson?: StringFilter<"PaymentProviderConfig"> | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedById?: StringNullableFilter<"PaymentProviderConfig"> | string | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "organizationId_provider">

  export type PaymentProviderConfigOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    isEnabled?: SortOrder
    configJson?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: PaymentProviderConfigCountOrderByAggregateInput
    _max?: PaymentProviderConfigMaxOrderByAggregateInput
    _min?: PaymentProviderConfigMinOrderByAggregateInput
  }

  export type PaymentProviderConfigScalarWhereWithAggregatesInput = {
    AND?: PaymentProviderConfigScalarWhereWithAggregatesInput | PaymentProviderConfigScalarWhereWithAggregatesInput[]
    OR?: PaymentProviderConfigScalarWhereWithAggregatesInput[]
    NOT?: PaymentProviderConfigScalarWhereWithAggregatesInput | PaymentProviderConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    organizationId?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    provider?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    isEnabled?: BoolWithAggregatesFilter<"PaymentProviderConfig"> | boolean
    configJson?: StringWithAggregatesFilter<"PaymentProviderConfig"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentProviderConfig"> | Date | string
    updatedById?: StringNullableWithAggregatesFilter<"PaymentProviderConfig"> | string | null
  }

  export type IncentiveGrantWhereInput = {
    AND?: IncentiveGrantWhereInput | IncentiveGrantWhereInput[]
    OR?: IncentiveGrantWhereInput[]
    NOT?: IncentiveGrantWhereInput | IncentiveGrantWhereInput[]
    id?: StringFilter<"IncentiveGrant"> | string
    segmentIncentiveId?: StringFilter<"IncentiveGrant"> | string
    userId?: StringFilter<"IncentiveGrant"> | string
    grantedAt?: DateTimeFilter<"IncentiveGrant"> | Date | string
    couponCode?: StringNullableFilter<"IncentiveGrant"> | string | null
    couponId?: StringNullableFilter<"IncentiveGrant"> | string | null
    walletTransactionId?: StringNullableFilter<"IncentiveGrant"> | string | null
    redeemedAt?: DateTimeNullableFilter<"IncentiveGrant"> | Date | string | null
    redeemedOrderId?: StringNullableFilter<"IncentiveGrant"> | string | null
    segmentIncentive?: XOR<SegmentIncentiveRelationFilter, SegmentIncentiveWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    walletTransaction?: XOR<WalletTransactionNullableRelationFilter, WalletTransactionWhereInput> | null
  }

  export type IncentiveGrantOrderByWithRelationInput = {
    id?: SortOrder
    segmentIncentiveId?: SortOrder
    userId?: SortOrder
    grantedAt?: SortOrder
    couponCode?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    walletTransactionId?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    redeemedOrderId?: SortOrderInput | SortOrder
    segmentIncentive?: SegmentIncentiveOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
    walletTransaction?: WalletTransactionOrderByWithRelationInput
  }

  export type IncentiveGrantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    segmentIncentiveId_userId?: IncentiveGrantSegmentIncentiveIdUserIdCompoundUniqueInput
    AND?: IncentiveGrantWhereInput | IncentiveGrantWhereInput[]
    OR?: IncentiveGrantWhereInput[]
    NOT?: IncentiveGrantWhereInput | IncentiveGrantWhereInput[]
    segmentIncentiveId?: StringFilter<"IncentiveGrant"> | string
    userId?: StringFilter<"IncentiveGrant"> | string
    grantedAt?: DateTimeFilter<"IncentiveGrant"> | Date | string
    couponCode?: StringNullableFilter<"IncentiveGrant"> | string | null
    couponId?: StringNullableFilter<"IncentiveGrant"> | string | null
    walletTransactionId?: StringNullableFilter<"IncentiveGrant"> | string | null
    redeemedAt?: DateTimeNullableFilter<"IncentiveGrant"> | Date | string | null
    redeemedOrderId?: StringNullableFilter<"IncentiveGrant"> | string | null
    segmentIncentive?: XOR<SegmentIncentiveRelationFilter, SegmentIncentiveWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    coupon?: XOR<CouponNullableRelationFilter, CouponWhereInput> | null
    walletTransaction?: XOR<WalletTransactionNullableRelationFilter, WalletTransactionWhereInput> | null
  }, "id" | "segmentIncentiveId_userId">

  export type IncentiveGrantOrderByWithAggregationInput = {
    id?: SortOrder
    segmentIncentiveId?: SortOrder
    userId?: SortOrder
    grantedAt?: SortOrder
    couponCode?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    walletTransactionId?: SortOrderInput | SortOrder
    redeemedAt?: SortOrderInput | SortOrder
    redeemedOrderId?: SortOrderInput | SortOrder
    _count?: IncentiveGrantCountOrderByAggregateInput
    _max?: IncentiveGrantMaxOrderByAggregateInput
    _min?: IncentiveGrantMinOrderByAggregateInput
  }

  export type IncentiveGrantScalarWhereWithAggregatesInput = {
    AND?: IncentiveGrantScalarWhereWithAggregatesInput | IncentiveGrantScalarWhereWithAggregatesInput[]
    OR?: IncentiveGrantScalarWhereWithAggregatesInput[]
    NOT?: IncentiveGrantScalarWhereWithAggregatesInput | IncentiveGrantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncentiveGrant"> | string
    segmentIncentiveId?: StringWithAggregatesFilter<"IncentiveGrant"> | string
    userId?: StringWithAggregatesFilter<"IncentiveGrant"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"IncentiveGrant"> | Date | string
    couponCode?: StringNullableWithAggregatesFilter<"IncentiveGrant"> | string | null
    couponId?: StringNullableWithAggregatesFilter<"IncentiveGrant"> | string | null
    walletTransactionId?: StringNullableWithAggregatesFilter<"IncentiveGrant"> | string | null
    redeemedAt?: DateTimeNullableWithAggregatesFilter<"IncentiveGrant"> | Date | string | null
    redeemedOrderId?: StringNullableWithAggregatesFilter<"IncentiveGrant"> | string | null
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    orders?: OrderCreateNestedManyWithoutEmployerCompanyInput
    invoices?: CompanyInvoiceCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    orders?: OrderUncheckedCreateNestedManyWithoutEmployerCompanyInput
    invoices?: CompanyInvoiceUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    orders?: OrderUpdateManyWithoutEmployerCompanyNestedInput
    invoices?: CompanyInvoiceUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEmployerCompanyNestedInput
    invoices?: CompanyInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvoiceCreateInput = {
    id?: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
    items?: CompanyInvoiceItemCreateNestedManyWithoutCompanyInvoiceInput
  }

  export type CompanyInvoiceUncheckedCreateInput = {
    id?: string
    companyId: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CompanyInvoiceItemUncheckedCreateNestedManyWithoutCompanyInvoiceInput
  }

  export type CompanyInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
    items?: CompanyInvoiceItemUpdateManyWithoutCompanyInvoiceNestedInput
  }

  export type CompanyInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CompanyInvoiceItemUncheckedUpdateManyWithoutCompanyInvoiceNestedInput
  }

  export type CompanyInvoiceCreateManyInput = {
    id?: string
    companyId: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvoiceItemCreateInput = {
    id?: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
    companyInvoice: CompanyInvoiceCreateNestedOneWithoutItemsInput
  }

  export type CompanyInvoiceItemUncheckedCreateInput = {
    id?: string
    companyInvoiceId: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    companyInvoice?: CompanyInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type CompanyInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyInvoiceId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemCreateManyInput = {
    id?: string
    companyInvoiceId: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyInvoiceId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CompanyEmployeeCreateInput = {
    id?: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutCompanyEmployeesInput
  }

  export type CompanyEmployeeUncheckedCreateInput = {
    id?: string
    companyId: string
    userId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type CompanyEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutCompanyEmployeesNestedInput
  }

  export type CompanyEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeCreateManyInput = {
    id?: string
    companyId: string
    userId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type CompanyEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    menus?: MenuCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    users?: UserLocationCreateNestedManyWithoutLocationInput
    coupons?: CouponCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    users?: UserLocationUncheckedCreateNestedManyWithoutLocationInput
    coupons?: CouponUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    menus?: MenuUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    users?: UserLocationUpdateManyWithoutLocationNestedInput
    coupons?: CouponUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserLocationUncheckedUpdateManyWithoutLocationNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    balance?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    balance?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
    performedBy?: UserCreateNestedOneWithoutPerformedWalletActionsInput
    incentiveGrant?: IncentiveGrantCreateNestedOneWithoutWalletTransactionInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
    performedBy?: UserUpdateOneWithoutPerformedWalletActionsNestedInput
    incentiveGrant?: IncentiveGrantUpdateOneWithoutWalletTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLocationsInput
    location: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserLocationUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    createdAt?: Date | string
  }

  export type UserLocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLocationsNestedInput
    location?: LocationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserLocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    createdAt?: Date | string
  }

  export type UserLocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenusInput
    menuItems?: MenuItemCreateNestedManyWithoutMenuInput
    promotionBanners?: MenuPromotionBannerCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: string
    locationId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutMenuInput
    promotionBanners?: MenuPromotionBannerUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenusNestedInput
    menuItems?: MenuItemUpdateManyWithoutMenuNestedInput
    promotionBanners?: MenuPromotionBannerUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutMenuNestedInput
    promotionBanners?: MenuPromotionBannerUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: string
    locationId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionBannerCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon?: CouponCreateNestedOneWithoutPromotionBannersInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPromotionBannersInput
    menuAssignments?: MenuPromotionBannerCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerUncheckedCreateInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    couponId?: string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    menuAssignments?: MenuPromotionBannerUncheckedCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneWithoutPromotionBannersNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPromotionBannersNestedInput
    menuAssignments?: MenuPromotionBannerUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuAssignments?: MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerCreateManyInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    couponId?: string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionBannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionBannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuPromotionBannerCreateInput = {
    id?: string
    sortOrder?: number
    menu: MenuCreateNestedOneWithoutPromotionBannersInput
    promotionBanner: PromotionBannerCreateNestedOneWithoutMenuAssignmentsInput
  }

  export type MenuPromotionBannerUncheckedCreateInput = {
    id?: string
    menuId: string
    promotionBannerId: string
    sortOrder?: number
  }

  export type MenuPromotionBannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    menu?: MenuUpdateOneRequiredWithoutPromotionBannersNestedInput
    promotionBanner?: PromotionBannerUpdateOneRequiredWithoutMenuAssignmentsNestedInput
  }

  export type MenuPromotionBannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    promotionBannerId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuPromotionBannerCreateManyInput = {
    id?: string
    menuId: string
    promotionBannerId: string
    sortOrder?: number
  }

  export type MenuPromotionBannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuPromotionBannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    promotionBannerId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuItemCreateInput = {
    id?: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutMenuItemsInput
    dish: DishCreateNestedOneWithoutMenuItemsInput
    orderItems?: OrderItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: string
    menuId: string
    dishId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutMenuItemsNestedInput
    dish?: DishUpdateOneRequiredWithoutMenuItemsNestedInput
    orderItems?: OrderItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemCreateManyInput = {
    id?: string
    menuId: string
    dishId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DishCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemCreateNestedManyWithoutDishInput
    coupons?: CouponCreateNestedManyWithoutFreeItemDishInput
  }

  export type DishUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutDishInput
    coupons?: CouponUncheckedCreateNestedManyWithoutFreeItemDishInput
  }

  export type DishUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUpdateManyWithoutDishNestedInput
    coupons?: CouponUpdateManyWithoutFreeItemDishNestedInput
  }

  export type DishUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutDishNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutFreeItemDishNestedInput
  }

  export type DishCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DishUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DishUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateInput = {
    id?: string
    redeemedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutRedemptionsInput
    user: UserCreateNestedOneWithoutCouponRedemptionsInput
    order: OrderCreateNestedOneWithoutCouponRedemptionsInput
  }

  export type CouponRedemptionUncheckedCreateInput = {
    id?: string
    couponId: string
    userId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutRedemptionsNestedInput
    user?: UserUpdateOneRequiredWithoutCouponRedemptionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCouponRedemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateManyInput = {
    id?: string
    couponId: string
    userId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type CouponRedemptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    menuItem: MenuItemCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    menuItemId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    menuItem?: MenuItemUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    menuItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    menuItemId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    menuItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetadataCreateInput = {
    id?: string
    type: $Enums.MetadataType
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetadataUncheckedCreateInput = {
    id?: string
    type: $Enums.MetadataType
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMetadataTypeFieldUpdateOperationsInput | $Enums.MetadataType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMetadataTypeFieldUpdateOperationsInput | $Enums.MetadataType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetadataCreateManyInput = {
    id?: string
    type: $Enums.MetadataType
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMetadataTypeFieldUpdateOperationsInput | $Enums.MetadataType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMetadataTypeFieldUpdateOperationsInput | $Enums.MetadataType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentsInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentsNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSegmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageCreateInput = {
    id?: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInAppMessagesInput
    segment: CustomerSegmentCreateNestedOneWithoutInAppMessagesInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutInAppMessagesInput
    readBy?: InAppMessageReadCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageUncheckedCreateInput = {
    id?: string
    organizationId: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    readBy?: InAppMessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInAppMessagesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutInAppMessagesNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutInAppMessagesNestedInput
    readBy?: InAppMessageReadUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readBy?: InAppMessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageCreateManyInput = {
    id?: string
    organizationId: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InAppMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadCreateInput = {
    id?: string
    userId: string
    readAt?: Date | string
    message: InAppMessageCreateNestedOneWithoutReadByInput
  }

  export type InAppMessageReadUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type InAppMessageReadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: InAppMessageUpdateOneRequiredWithoutReadByNestedInput
  }

  export type InAppMessageReadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type InAppMessageReadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingWorkflowCreateInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput
    segment: CustomerSegmentCreateNestedOneWithoutWorkflowsInput
    executionLogs?: WorkflowExecutionLogCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowUncheckedCreateInput = {
    id?: string
    organizationId: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    executionLogs?: WorkflowExecutionLogUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutWorkflowsNestedInput
    executionLogs?: WorkflowExecutionLogUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionLogs?: WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowCreateManyInput = {
    id?: string
    organizationId: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingWorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingWorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowExecutionLogCreateInput = {
    id?: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    workflow: MarketingWorkflowCreateNestedOneWithoutExecutionLogsInput
  }

  export type WorkflowExecutionLogUncheckedCreateInput = {
    id?: string
    workflowId: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    workflow?: MarketingWorkflowUpdateOneRequiredWithoutExecutionLogsNestedInput
  }

  export type WorkflowExecutionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogCreateManyInput = {
    id?: string
    workflowId: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workflowId?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SegmentIncentiveCreateInput = {
    id?: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentIncentivesInput
    segment: CustomerSegmentCreateNestedOneWithoutSegmentIncentivesInput
    coupon?: CouponCreateNestedOneWithoutSegmentIncentivesInput
    grants?: IncentiveGrantCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveUncheckedCreateInput = {
    id?: string
    organizationId: string
    segmentId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grants?: IncentiveGrantUncheckedCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    coupon?: CouponUpdateOneWithoutSegmentIncentivesNestedInput
    grants?: IncentiveGrantUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grants?: IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveCreateManyInput = {
    id?: string
    organizationId: string
    segmentId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentIncentiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentIncentiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTemplateCreateInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutMarketingTemplatesInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUncheckedCreateInput = {
    id?: string
    organizationId?: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutMarketingTemplatesNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateCreateManyInput = {
    id?: string
    organizationId?: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationCreateInput = {
    id?: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPushNotificationsInput
    segment: CustomerSegmentCreateNestedOneWithoutPushNotificationsInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPushNotificationsInput
    logs?: PushNotificationLogCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationUncheckedCreateInput = {
    id?: string
    organizationId: string
    segmentId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: PushNotificationLogUncheckedCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPushNotificationsNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutPushNotificationsNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPushNotificationsNestedInput
    logs?: PushNotificationLogUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: PushNotificationLogUncheckedUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationCreateManyInput = {
    id?: string
    organizationId: string
    segmentId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogCreateInput = {
    id?: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
    pushNotification: PushNotificationCreateNestedOneWithoutLogsInput
    user: UserCreateNestedOneWithoutPushNotificationLogsInput
  }

  export type PushNotificationLogUncheckedCreateInput = {
    id?: string
    pushNotificationId: string
    userId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushNotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushNotification?: PushNotificationUpdateOneRequiredWithoutLogsNestedInput
    user?: UserUpdateOneRequiredWithoutPushNotificationLogsNestedInput
  }

  export type PushNotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogCreateManyInput = {
    id?: string
    pushNotificationId: string
    userId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushNotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionsInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigCreateInput = {
    id?: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPaymentConfigsInput
    updatedBy?: UserCreateNestedOneWithoutPaymentConfigChangesInput
  }

  export type PaymentProviderConfigUncheckedCreateInput = {
    id?: string
    organizationId: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type PaymentProviderConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPaymentConfigsNestedInput
    updatedBy?: UserUpdateOneWithoutPaymentConfigChangesNestedInput
  }

  export type PaymentProviderConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentProviderConfigCreateManyInput = {
    id?: string
    organizationId: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type PaymentProviderConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncentiveGrantCreateInput = {
    id?: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    segmentIncentive: SegmentIncentiveCreateNestedOneWithoutGrantsInput
    user: UserCreateNestedOneWithoutIncentiveGrantsInput
    coupon?: CouponCreateNestedOneWithoutIncentiveGrantsInput
    walletTransaction?: WalletTransactionCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantUncheckedCreateInput = {
    id?: string
    segmentIncentiveId: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    walletTransaction?: WalletTransactionUncheckedCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    segmentIncentive?: SegmentIncentiveUpdateOneRequiredWithoutGrantsNestedInput
    user?: UserUpdateOneRequiredWithoutIncentiveGrantsNestedInput
    coupon?: CouponUpdateOneWithoutIncentiveGrantsNestedInput
    walletTransaction?: WalletTransactionUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransaction?: WalletTransactionUncheckedUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantCreateManyInput = {
    id?: string
    segmentIncentiveId: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
  }

  export type IncentiveGrantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IncentiveGrantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CustomerSegmentListRelationFilter = {
    every?: CustomerSegmentWhereInput
    some?: CustomerSegmentWhereInput
    none?: CustomerSegmentWhereInput
  }

  export type InAppMessageListRelationFilter = {
    every?: InAppMessageWhereInput
    some?: InAppMessageWhereInput
    none?: InAppMessageWhereInput
  }

  export type MarketingWorkflowListRelationFilter = {
    every?: MarketingWorkflowWhereInput
    some?: MarketingWorkflowWhereInput
    none?: MarketingWorkflowWhereInput
  }

  export type SegmentIncentiveListRelationFilter = {
    every?: SegmentIncentiveWhereInput
    some?: SegmentIncentiveWhereInput
    none?: SegmentIncentiveWhereInput
  }

  export type MarketingTemplateListRelationFilter = {
    every?: MarketingTemplateWhereInput
    some?: MarketingTemplateWhereInput
    none?: MarketingTemplateWhereInput
  }

  export type PushNotificationListRelationFilter = {
    every?: PushNotificationWhereInput
    some?: PushNotificationWhereInput
    none?: PushNotificationWhereInput
  }

  export type PaymentProviderConfigListRelationFilter = {
    every?: PaymentProviderConfigWhereInput
    some?: PaymentProviderConfigWhereInput
    none?: PaymentProviderConfigWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerSegmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InAppMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketingWorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SegmentIncentiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketingTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentProviderConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumSubsidyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubsidyType | EnumSubsidyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubsidyTypeFilter<$PrismaModel> | $Enums.SubsidyType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CompanyEmployeeListRelationFilter = {
    every?: CompanyEmployeeWhereInput
    some?: CompanyEmployeeWhereInput
    none?: CompanyEmployeeWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CompanyInvoiceListRelationFilter = {
    every?: CompanyInvoiceWhereInput
    some?: CompanyInvoiceWhereInput
    none?: CompanyInvoiceWhereInput
  }

  export type CompanyEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractNumber?: SortOrder
    isActive?: SortOrder
    subsidyType?: SortOrder
    subsidyValue?: SortOrder
    subsidyMaxPerDay?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    subsidyValue?: SortOrder
    subsidyMaxPerDay?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractNumber?: SortOrder
    isActive?: SortOrder
    subsidyType?: SortOrder
    subsidyValue?: SortOrder
    subsidyMaxPerDay?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractNumber?: SortOrder
    isActive?: SortOrder
    subsidyType?: SortOrder
    subsidyValue?: SortOrder
    subsidyMaxPerDay?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    subsidyValue?: SortOrder
    subsidyMaxPerDay?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSubsidyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubsidyType | EnumSubsidyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubsidyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubsidyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubsidyTypeFilter<$PrismaModel>
    _max?: NestedEnumSubsidyTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyInvoiceItemListRelationFilter = {
    every?: CompanyInvoiceItemWhereInput
    some?: CompanyInvoiceItemWhereInput
    none?: CompanyInvoiceItemWhereInput
  }

  export type CompanyInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyInvoiceCompanyIdYearMonthCompoundUniqueInput = {
    companyId: string
    year: number
    month: number
  }

  export type CompanyInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    invoicedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvoiceAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    totalAmount?: SortOrder
  }

  export type CompanyInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    invoicedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    year?: SortOrder
    month?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    invoicedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyInvoiceSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    totalAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CompanyInvoiceRelationFilter = {
    is?: CompanyInvoiceWhereInput
    isNot?: CompanyInvoiceWhereInput
  }

  export type CompanyInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    companyInvoiceId?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    orderDate?: SortOrder
    employeeName?: SortOrder
    amount?: SortOrder
  }

  export type CompanyInvoiceItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CompanyInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    companyInvoiceId?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    orderDate?: SortOrder
    employeeName?: SortOrder
    amount?: SortOrder
  }

  export type CompanyInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    companyInvoiceId?: SortOrder
    orderId?: SortOrder
    orderNumber?: SortOrder
    orderDate?: SortOrder
    employeeName?: SortOrder
    amount?: SortOrder
  }

  export type CompanyInvoiceItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyEmployeeCompanyIdUserIdCompoundUniqueInput = {
    companyId: string
    userId: string
  }

  export type CompanyEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    employeeNumber?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    employeeNumber?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    userId?: SortOrder
    employeeNumber?: SortOrder
    department?: SortOrder
    isActive?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type MenuListRelationFilter = {
    every?: MenuWhereInput
    some?: MenuWhereInput
    none?: MenuWhereInput
  }

  export type UserLocationListRelationFilter = {
    every?: UserLocationWhereInput
    some?: UserLocationWhereInput
    none?: UserLocationWhereInput
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    openingHours?: SortOrder
    workingDays?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    workingDays?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    workingDays?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type CouponRedemptionListRelationFilter = {
    every?: CouponRedemptionWhereInput
    some?: CouponRedemptionWhereInput
    none?: CouponRedemptionWhereInput
  }

  export type IncentiveGrantListRelationFilter = {
    every?: IncentiveGrantWhereInput
    some?: IncentiveGrantWhereInput
    none?: IncentiveGrantWhereInput
  }

  export type WalletNullableRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type PushNotificationLogListRelationFilter = {
    every?: PushNotificationLogWhereInput
    some?: PushNotificationLogWhereInput
    none?: PushNotificationLogWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponRedemptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncentiveGrantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushNotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    image?: SortOrder
    organizationId?: SortOrder
    marketingEmailConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    image?: SortOrder
    organizationId?: SortOrder
    marketingEmailConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    image?: SortOrder
    organizationId?: SortOrder
    marketingEmailConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumWalletTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTransactionTypeFilter<$PrismaModel> | $Enums.WalletTransactionType
  }

  export type OrderNullableRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type IncentiveGrantNullableRelationFilter = {
    is?: IncentiveGrantWhereInput | null
    isNot?: IncentiveGrantWhereInput | null
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    performedById?: SortOrder
    incentiveGrantId?: SortOrder
    paymentProvider?: SortOrder
    externalPaymentId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    performedById?: SortOrder
    incentiveGrantId?: SortOrder
    paymentProvider?: SortOrder
    externalPaymentId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    orderId?: SortOrder
    performedById?: SortOrder
    incentiveGrantId?: SortOrder
    paymentProvider?: SortOrder
    externalPaymentId?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
  }

  export type LocationRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type UserLocationUserIdLocationIdCompoundUniqueInput = {
    userId: string
    locationId: string
  }

  export type UserLocationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserLocationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserLocationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type MenuPromotionBannerListRelationFilter = {
    every?: MenuPromotionBannerWhereInput
    some?: MenuPromotionBannerWhereInput
    none?: MenuPromotionBannerWhereInput
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuPromotionBannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuLocationIdWeekNumberYearCompoundUniqueInput = {
    locationId: string
    weekNumber: number
    year: number
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuAvgOrderByAggregateInput = {
    weekNumber?: SortOrder
    year?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    weekNumber?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isPublished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuSumOrderByAggregateInput = {
    weekNumber?: SortOrder
    year?: SortOrder
  }

  export type CouponNullableRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type MarketingTemplateNullableRelationFilter = {
    is?: MarketingTemplateWhereInput | null
    isNot?: MarketingTemplateWhereInput | null
  }

  export type PromotionBannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    imageUrl?: SortOrder
    couponId?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    templateSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    imageUrl?: SortOrder
    couponId?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionBannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    imageUrl?: SortOrder
    couponId?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type PromotionBannerRelationFilter = {
    is?: PromotionBannerWhereInput
    isNot?: PromotionBannerWhereInput
  }

  export type MenuPromotionBannerMenuIdPromotionBannerIdCompoundUniqueInput = {
    menuId: string
    promotionBannerId: string
  }

  export type MenuPromotionBannerCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    promotionBannerId?: SortOrder
    sortOrder?: SortOrder
  }

  export type MenuPromotionBannerAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type MenuPromotionBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    promotionBannerId?: SortOrder
    sortOrder?: SortOrder
  }

  export type MenuPromotionBannerMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    promotionBannerId?: SortOrder
    sortOrder?: SortOrder
  }

  export type MenuPromotionBannerSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type DishRelationFilter = {
    is?: DishWhereInput
    isNot?: DishWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    dishId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    maxOrders?: SortOrder
    currentOrders?: SortOrder
    isPromotion?: SortOrder
    promotionPrice?: SortOrder
    promotionLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    price?: SortOrder
    maxOrders?: SortOrder
    currentOrders?: SortOrder
    promotionPrice?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    dishId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    maxOrders?: SortOrder
    currentOrders?: SortOrder
    isPromotion?: SortOrder
    promotionPrice?: SortOrder
    promotionLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    dishId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    maxOrders?: SortOrder
    currentOrders?: SortOrder
    isPromotion?: SortOrder
    promotionPrice?: SortOrder
    promotionLabel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    price?: SortOrder
    maxOrders?: SortOrder
    currentOrders?: SortOrder
    promotionPrice?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DishCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fat?: SortOrder
    allergens?: SortOrder
    dietTags?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DishAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fat?: SortOrder
  }

  export type DishMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fat?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DishMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    category?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fat?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DishSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbs?: SortOrder
    fat?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type CompanyNullableRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    pickupCode?: SortOrder
    pickupDate?: SortOrder
    pickupTimeSlot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickedUpAt?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    employerSubsidyAmount?: SortOrder
    employerCompanyId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    employerSubsidyAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    pickupCode?: SortOrder
    pickupDate?: SortOrder
    pickupTimeSlot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickedUpAt?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    employerSubsidyAmount?: SortOrder
    employerCompanyId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    paymentIntentId?: SortOrder
    pickupCode?: SortOrder
    pickupDate?: SortOrder
    pickupTimeSlot?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pickedUpAt?: SortOrder
    couponCode?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    employerSubsidyAmount?: SortOrder
    employerCompanyId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    finalAmount?: SortOrder
    employerSubsidyAmount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType
  }

  export type LocationNullableRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type DishNullableRelationFilter = {
    is?: DishWhereInput | null
    isNot?: DishWhereInput | null
  }

  export type PromotionBannerListRelationFilter = {
    every?: PromotionBannerWhereInput
    some?: PromotionBannerWhereInput
    none?: PromotionBannerWhereInput
  }

  export type PromotionBannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    freeItemDishId?: SortOrder
    locationId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxUses?: SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    maxUses?: SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    freeItemDishId?: SortOrder
    locationId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxUses?: SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountValue?: SortOrder
    freeItemDishId?: SortOrder
    locationId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxUses?: SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    discountValue?: SortOrder
    maxUses?: SortOrder
    maxUsesPerUser?: SortOrder
    currentUses?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type EnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>
  }

  export type CouponRelationFilter = {
    is?: CouponWhereInput
    isNot?: CouponWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type CouponRedemptionCouponIdUserIdOrderIdCompoundUniqueInput = {
    couponId: string
    userId: string
    orderId: string
  }

  export type CouponRedemptionCountOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type CouponRedemptionMaxOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type CouponRedemptionMinOrderByAggregateInput = {
    id?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    redeemedAt?: SortOrder
  }

  export type MenuItemRelationFilter = {
    is?: MenuItemWhereInput
    isNot?: MenuItemWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    menuItemId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type EnumMetadataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataType | EnumMetadataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataTypeFilter<$PrismaModel> | $Enums.MetadataType
  }

  export type MetadataTypeNameCompoundUniqueInput = {
    type: $Enums.MetadataType
    name: string
  }

  export type MetadataCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetadataAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type MetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetadataMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetadataSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumMetadataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataType | EnumMetadataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetadataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetadataTypeFilter<$PrismaModel>
    _max?: NestedEnumMetadataTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CustomerSegmentOrganizationIdNameCompoundUniqueInput = {
    organizationId: string
    name: string
  }

  export type CustomerSegmentCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rulesCombination?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSegmentMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rulesCombination?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSegmentMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rulesCombination?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CustomerSegmentRelationFilter = {
    is?: CustomerSegmentWhereInput
    isNot?: CustomerSegmentWhereInput
  }

  export type InAppMessageReadListRelationFilter = {
    every?: InAppMessageReadWhereInput
    some?: InAppMessageReadWhereInput
    none?: InAppMessageReadWhereInput
  }

  export type InAppMessageReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InAppMessageCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    linkUrl?: SortOrder
    displayPlace?: SortOrder
    displayType?: SortOrder
    slotId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    templateSnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InAppMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    linkUrl?: SortOrder
    displayPlace?: SortOrder
    displayType?: SortOrder
    slotId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InAppMessageMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    title?: SortOrder
    body?: SortOrder
    linkUrl?: SortOrder
    displayPlace?: SortOrder
    displayType?: SortOrder
    slotId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    marketingTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InAppMessageRelationFilter = {
    is?: InAppMessageWhereInput
    isNot?: InAppMessageWhereInput
  }

  export type InAppMessageReadMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type InAppMessageReadCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type InAppMessageReadMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type InAppMessageReadMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type WorkflowExecutionLogListRelationFilter = {
    every?: WorkflowExecutionLogWhereInput
    some?: WorkflowExecutionLogWhereInput
    none?: WorkflowExecutionLogWhereInput
  }

  export type WorkflowExecutionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketingWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    triggerConfig?: SortOrder
    actionType?: SortOrder
    actionConfig?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    actionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    triggerType?: SortOrder
    actionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingWorkflowRelationFilter = {
    is?: MarketingWorkflowWhereInput
    isNot?: MarketingWorkflowWhereInput
  }

  export type WorkflowExecutionLogCountOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
    details?: SortOrder
  }

  export type WorkflowExecutionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
  }

  export type WorkflowExecutionLogMinOrderByAggregateInput = {
    id?: SortOrder
    workflowId?: SortOrder
    executedAt?: SortOrder
    status?: SortOrder
    message?: SortOrder
  }

  export type SegmentIncentiveCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    incentiveType?: SortOrder
    couponId?: SortOrder
    personaliseCoupon?: SortOrder
    walletAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxGrantsPerUser?: SortOrder
    displayChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentIncentiveAvgOrderByAggregateInput = {
    walletAmount?: SortOrder
    maxGrantsPerUser?: SortOrder
  }

  export type SegmentIncentiveMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    incentiveType?: SortOrder
    couponId?: SortOrder
    personaliseCoupon?: SortOrder
    walletAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxGrantsPerUser?: SortOrder
    displayChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentIncentiveMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    name?: SortOrder
    incentiveType?: SortOrder
    couponId?: SortOrder
    personaliseCoupon?: SortOrder
    walletAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    maxGrantsPerUser?: SortOrder
    displayChannel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SegmentIncentiveSumOrderByAggregateInput = {
    walletAmount?: SortOrder
    maxGrantsPerUser?: SortOrder
  }

  export type EnumMarketingTemplateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateType | EnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel> | $Enums.MarketingTemplateType
  }

  export type EnumMarketingTemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateStatus | EnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel> | $Enums.MarketingTemplateStatus
  }

  export type MarketingTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    isStarter?: SortOrder
    isFavorite?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isStarter?: SortOrder
    isFavorite?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    isStarter?: SortOrder
    isFavorite?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMarketingTemplateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateType | EnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketingTemplateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel>
  }

  export type EnumMarketingTemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateStatus | EnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketingTemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel>
  }

  export type EnumPushNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PushNotificationStatus | EnumPushNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushNotificationStatusFilter<$PrismaModel> | $Enums.PushNotificationStatus
  }

  export type PushNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    marketingTemplateId?: SortOrder
    templateSnapshot?: SortOrder
    pushTitle?: SortOrder
    pushBody?: SortOrder
    deepLink?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    totalRecipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushNotificationAvgOrderByAggregateInput = {
    totalRecipients?: SortOrder
  }

  export type PushNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    marketingTemplateId?: SortOrder
    pushTitle?: SortOrder
    pushBody?: SortOrder
    deepLink?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    totalRecipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    segmentId?: SortOrder
    marketingTemplateId?: SortOrder
    pushTitle?: SortOrder
    pushBody?: SortOrder
    deepLink?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    totalRecipients?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PushNotificationSumOrderByAggregateInput = {
    totalRecipients?: SortOrder
  }

  export type EnumPushNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PushNotificationStatus | EnumPushNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PushNotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPushNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumPushNotificationStatusFilter<$PrismaModel>
  }

  export type EnumPushDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PushDeliveryStatus | EnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushDeliveryStatusFilter<$PrismaModel> | $Enums.PushDeliveryStatus
  }

  export type PushNotificationRelationFilter = {
    is?: PushNotificationWhereInput
    isNot?: PushNotificationWhereInput
  }

  export type PushNotificationLogPushNotificationIdUserIdCompoundUniqueInput = {
    pushNotificationId: string
    userId: string
  }

  export type PushNotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    pushNotificationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type PushNotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    pushNotificationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type PushNotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    pushNotificationId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
  }

  export type EnumPushDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PushDeliveryStatus | EnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.PushDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPushDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumPushDeliveryStatusFilter<$PrismaModel>
  }

  export type PushSubscriptionUserIdEndpointCompoundUniqueInput = {
    userId: string
    endpoint: string
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dhKey?: SortOrder
    authKey?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dhKey?: SortOrder
    authKey?: SortOrder
    createdAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dhKey?: SortOrder
    authKey?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentProviderConfigOrganizationIdProviderCompoundUniqueInput = {
    organizationId: string
    provider: string
  }

  export type PaymentProviderConfigCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    isEnabled?: SortOrder
    configJson?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type PaymentProviderConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    isEnabled?: SortOrder
    configJson?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type PaymentProviderConfigMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    provider?: SortOrder
    isEnabled?: SortOrder
    configJson?: SortOrder
    updatedAt?: SortOrder
    updatedById?: SortOrder
  }

  export type SegmentIncentiveRelationFilter = {
    is?: SegmentIncentiveWhereInput
    isNot?: SegmentIncentiveWhereInput
  }

  export type WalletTransactionNullableRelationFilter = {
    is?: WalletTransactionWhereInput | null
    isNot?: WalletTransactionWhereInput | null
  }

  export type IncentiveGrantSegmentIncentiveIdUserIdCompoundUniqueInput = {
    segmentIncentiveId: string
    userId: string
  }

  export type IncentiveGrantCountOrderByAggregateInput = {
    id?: SortOrder
    segmentIncentiveId?: SortOrder
    userId?: SortOrder
    grantedAt?: SortOrder
    couponCode?: SortOrder
    couponId?: SortOrder
    walletTransactionId?: SortOrder
    redeemedAt?: SortOrder
    redeemedOrderId?: SortOrder
  }

  export type IncentiveGrantMaxOrderByAggregateInput = {
    id?: SortOrder
    segmentIncentiveId?: SortOrder
    userId?: SortOrder
    grantedAt?: SortOrder
    couponCode?: SortOrder
    couponId?: SortOrder
    walletTransactionId?: SortOrder
    redeemedAt?: SortOrder
    redeemedOrderId?: SortOrder
  }

  export type IncentiveGrantMinOrderByAggregateInput = {
    id?: SortOrder
    segmentIncentiveId?: SortOrder
    userId?: SortOrder
    grantedAt?: SortOrder
    couponCode?: SortOrder
    couponId?: SortOrder
    walletTransactionId?: SortOrder
    redeemedAt?: SortOrder
    redeemedOrderId?: SortOrder
  }

  export type LocationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerSegmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput> | CustomerSegmentCreateWithoutOrganizationInput[] | CustomerSegmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutOrganizationInput | CustomerSegmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomerSegmentCreateManyOrganizationInputEnvelope
    connect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
  }

  export type InAppMessageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput> | InAppMessageCreateWithoutOrganizationInput[] | InAppMessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutOrganizationInput | InAppMessageCreateOrConnectWithoutOrganizationInput[]
    createMany?: InAppMessageCreateManyOrganizationInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type MarketingWorkflowCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput> | MarketingWorkflowCreateWithoutOrganizationInput[] | MarketingWorkflowUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutOrganizationInput | MarketingWorkflowCreateOrConnectWithoutOrganizationInput[]
    createMany?: MarketingWorkflowCreateManyOrganizationInputEnvelope
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
  }

  export type SegmentIncentiveCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput> | SegmentIncentiveCreateWithoutOrganizationInput[] | SegmentIncentiveUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutOrganizationInput | SegmentIncentiveCreateOrConnectWithoutOrganizationInput[]
    createMany?: SegmentIncentiveCreateManyOrganizationInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type MarketingTemplateCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput> | MarketingTemplateCreateWithoutOrganizationInput[] | MarketingTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutOrganizationInput | MarketingTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: MarketingTemplateCreateManyOrganizationInputEnvelope
    connect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
  }

  export type PushNotificationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput> | PushNotificationCreateWithoutOrganizationInput[] | PushNotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutOrganizationInput | PushNotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: PushNotificationCreateManyOrganizationInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type PaymentProviderConfigCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput> | PaymentProviderConfigCreateWithoutOrganizationInput[] | PaymentProviderConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutOrganizationInput | PaymentProviderConfigCreateOrConnectWithoutOrganizationInput[]
    createMany?: PaymentProviderConfigCreateManyOrganizationInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput> | CustomerSegmentCreateWithoutOrganizationInput[] | CustomerSegmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutOrganizationInput | CustomerSegmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: CustomerSegmentCreateManyOrganizationInputEnvelope
    connect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
  }

  export type InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput> | InAppMessageCreateWithoutOrganizationInput[] | InAppMessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutOrganizationInput | InAppMessageCreateOrConnectWithoutOrganizationInput[]
    createMany?: InAppMessageCreateManyOrganizationInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput> | MarketingWorkflowCreateWithoutOrganizationInput[] | MarketingWorkflowUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutOrganizationInput | MarketingWorkflowCreateOrConnectWithoutOrganizationInput[]
    createMany?: MarketingWorkflowCreateManyOrganizationInputEnvelope
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
  }

  export type SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput> | SegmentIncentiveCreateWithoutOrganizationInput[] | SegmentIncentiveUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutOrganizationInput | SegmentIncentiveCreateOrConnectWithoutOrganizationInput[]
    createMany?: SegmentIncentiveCreateManyOrganizationInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput> | MarketingTemplateCreateWithoutOrganizationInput[] | MarketingTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutOrganizationInput | MarketingTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: MarketingTemplateCreateManyOrganizationInputEnvelope
    connect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput> | PushNotificationCreateWithoutOrganizationInput[] | PushNotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutOrganizationInput | PushNotificationCreateOrConnectWithoutOrganizationInput[]
    createMany?: PushNotificationCreateManyOrganizationInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput> | PaymentProviderConfigCreateWithoutOrganizationInput[] | PaymentProviderConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutOrganizationInput | PaymentProviderConfigCreateOrConnectWithoutOrganizationInput[]
    createMany?: PaymentProviderConfigCreateManyOrganizationInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LocationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerSegmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput> | CustomerSegmentCreateWithoutOrganizationInput[] | CustomerSegmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutOrganizationInput | CustomerSegmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomerSegmentUpsertWithWhereUniqueWithoutOrganizationInput | CustomerSegmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomerSegmentCreateManyOrganizationInputEnvelope
    set?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    disconnect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    delete?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    connect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    update?: CustomerSegmentUpdateWithWhereUniqueWithoutOrganizationInput | CustomerSegmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomerSegmentUpdateManyWithWhereWithoutOrganizationInput | CustomerSegmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomerSegmentScalarWhereInput | CustomerSegmentScalarWhereInput[]
  }

  export type InAppMessageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput> | InAppMessageCreateWithoutOrganizationInput[] | InAppMessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutOrganizationInput | InAppMessageCreateOrConnectWithoutOrganizationInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutOrganizationInput | InAppMessageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InAppMessageCreateManyOrganizationInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutOrganizationInput | InAppMessageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutOrganizationInput | InAppMessageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type MarketingWorkflowUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput> | MarketingWorkflowCreateWithoutOrganizationInput[] | MarketingWorkflowUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutOrganizationInput | MarketingWorkflowCreateOrConnectWithoutOrganizationInput[]
    upsert?: MarketingWorkflowUpsertWithWhereUniqueWithoutOrganizationInput | MarketingWorkflowUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MarketingWorkflowCreateManyOrganizationInputEnvelope
    set?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    disconnect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    delete?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    update?: MarketingWorkflowUpdateWithWhereUniqueWithoutOrganizationInput | MarketingWorkflowUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MarketingWorkflowUpdateManyWithWhereWithoutOrganizationInput | MarketingWorkflowUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
  }

  export type SegmentIncentiveUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput> | SegmentIncentiveCreateWithoutOrganizationInput[] | SegmentIncentiveUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutOrganizationInput | SegmentIncentiveCreateOrConnectWithoutOrganizationInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutOrganizationInput | SegmentIncentiveUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SegmentIncentiveCreateManyOrganizationInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutOrganizationInput | SegmentIncentiveUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutOrganizationInput | SegmentIncentiveUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type MarketingTemplateUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput> | MarketingTemplateCreateWithoutOrganizationInput[] | MarketingTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutOrganizationInput | MarketingTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: MarketingTemplateUpsertWithWhereUniqueWithoutOrganizationInput | MarketingTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MarketingTemplateCreateManyOrganizationInputEnvelope
    set?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    disconnect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    delete?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    connect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    update?: MarketingTemplateUpdateWithWhereUniqueWithoutOrganizationInput | MarketingTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MarketingTemplateUpdateManyWithWhereWithoutOrganizationInput | MarketingTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MarketingTemplateScalarWhereInput | MarketingTemplateScalarWhereInput[]
  }

  export type PushNotificationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput> | PushNotificationCreateWithoutOrganizationInput[] | PushNotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutOrganizationInput | PushNotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutOrganizationInput | PushNotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PushNotificationCreateManyOrganizationInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutOrganizationInput | PushNotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutOrganizationInput | PushNotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput> | PaymentProviderConfigCreateWithoutOrganizationInput[] | PaymentProviderConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutOrganizationInput | PaymentProviderConfigCreateOrConnectWithoutOrganizationInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutOrganizationInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PaymentProviderConfigCreateManyOrganizationInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutOrganizationInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutOrganizationInput | PaymentProviderConfigUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput> | LocationCreateWithoutOrganizationInput[] | LocationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutOrganizationInput | LocationCreateOrConnectWithoutOrganizationInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutOrganizationInput | LocationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: LocationCreateManyOrganizationInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutOrganizationInput | LocationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutOrganizationInput | LocationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput> | CustomerSegmentCreateWithoutOrganizationInput[] | CustomerSegmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutOrganizationInput | CustomerSegmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: CustomerSegmentUpsertWithWhereUniqueWithoutOrganizationInput | CustomerSegmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: CustomerSegmentCreateManyOrganizationInputEnvelope
    set?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    disconnect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    delete?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    connect?: CustomerSegmentWhereUniqueInput | CustomerSegmentWhereUniqueInput[]
    update?: CustomerSegmentUpdateWithWhereUniqueWithoutOrganizationInput | CustomerSegmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: CustomerSegmentUpdateManyWithWhereWithoutOrganizationInput | CustomerSegmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: CustomerSegmentScalarWhereInput | CustomerSegmentScalarWhereInput[]
  }

  export type InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput> | InAppMessageCreateWithoutOrganizationInput[] | InAppMessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutOrganizationInput | InAppMessageCreateOrConnectWithoutOrganizationInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutOrganizationInput | InAppMessageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: InAppMessageCreateManyOrganizationInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutOrganizationInput | InAppMessageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutOrganizationInput | InAppMessageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput> | MarketingWorkflowCreateWithoutOrganizationInput[] | MarketingWorkflowUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutOrganizationInput | MarketingWorkflowCreateOrConnectWithoutOrganizationInput[]
    upsert?: MarketingWorkflowUpsertWithWhereUniqueWithoutOrganizationInput | MarketingWorkflowUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MarketingWorkflowCreateManyOrganizationInputEnvelope
    set?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    disconnect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    delete?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    update?: MarketingWorkflowUpdateWithWhereUniqueWithoutOrganizationInput | MarketingWorkflowUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MarketingWorkflowUpdateManyWithWhereWithoutOrganizationInput | MarketingWorkflowUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput> | SegmentIncentiveCreateWithoutOrganizationInput[] | SegmentIncentiveUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutOrganizationInput | SegmentIncentiveCreateOrConnectWithoutOrganizationInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutOrganizationInput | SegmentIncentiveUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: SegmentIncentiveCreateManyOrganizationInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutOrganizationInput | SegmentIncentiveUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutOrganizationInput | SegmentIncentiveUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput> | MarketingTemplateCreateWithoutOrganizationInput[] | MarketingTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutOrganizationInput | MarketingTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: MarketingTemplateUpsertWithWhereUniqueWithoutOrganizationInput | MarketingTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MarketingTemplateCreateManyOrganizationInputEnvelope
    set?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    disconnect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    delete?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    connect?: MarketingTemplateWhereUniqueInput | MarketingTemplateWhereUniqueInput[]
    update?: MarketingTemplateUpdateWithWhereUniqueWithoutOrganizationInput | MarketingTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MarketingTemplateUpdateManyWithWhereWithoutOrganizationInput | MarketingTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MarketingTemplateScalarWhereInput | MarketingTemplateScalarWhereInput[]
  }

  export type PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput> | PushNotificationCreateWithoutOrganizationInput[] | PushNotificationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutOrganizationInput | PushNotificationCreateOrConnectWithoutOrganizationInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutOrganizationInput | PushNotificationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PushNotificationCreateManyOrganizationInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutOrganizationInput | PushNotificationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutOrganizationInput | PushNotificationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput> | PaymentProviderConfigCreateWithoutOrganizationInput[] | PaymentProviderConfigUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutOrganizationInput | PaymentProviderConfigCreateOrConnectWithoutOrganizationInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutOrganizationInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: PaymentProviderConfigCreateManyOrganizationInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutOrganizationInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutOrganizationInput | PaymentProviderConfigUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type CompanyEmployeeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutEmployerCompanyInput = {
    create?: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput> | OrderCreateWithoutEmployerCompanyInput[] | OrderUncheckedCreateWithoutEmployerCompanyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEmployerCompanyInput | OrderCreateOrConnectWithoutEmployerCompanyInput[]
    createMany?: OrderCreateManyEmployerCompanyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CompanyInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput> | CompanyInvoiceCreateWithoutCompanyInput[] | CompanyInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutCompanyInput | CompanyInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvoiceCreateManyCompanyInputEnvelope
    connect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
  }

  export type CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutEmployerCompanyInput = {
    create?: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput> | OrderCreateWithoutEmployerCompanyInput[] | OrderUncheckedCreateWithoutEmployerCompanyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEmployerCompanyInput | OrderCreateOrConnectWithoutEmployerCompanyInput[]
    createMany?: OrderCreateManyEmployerCompanyInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CompanyInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput> | CompanyInvoiceCreateWithoutCompanyInput[] | CompanyInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutCompanyInput | CompanyInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyInvoiceCreateManyCompanyInputEnvelope
    connect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumSubsidyTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubsidyType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CompanyEmployeeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput | CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutEmployerCompanyNestedInput = {
    create?: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput> | OrderCreateWithoutEmployerCompanyInput[] | OrderUncheckedCreateWithoutEmployerCompanyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEmployerCompanyInput | OrderCreateOrConnectWithoutEmployerCompanyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEmployerCompanyInput | OrderUpsertWithWhereUniqueWithoutEmployerCompanyInput[]
    createMany?: OrderCreateManyEmployerCompanyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEmployerCompanyInput | OrderUpdateWithWhereUniqueWithoutEmployerCompanyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEmployerCompanyInput | OrderUpdateManyWithWhereWithoutEmployerCompanyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CompanyInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput> | CompanyInvoiceCreateWithoutCompanyInput[] | CompanyInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutCompanyInput | CompanyInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvoiceUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvoiceCreateManyCompanyInputEnvelope
    set?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    disconnect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    delete?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    connect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    update?: CompanyInvoiceUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvoiceUpdateManyWithWhereWithoutCompanyInput | CompanyInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvoiceScalarWhereInput | CompanyInvoiceScalarWhereInput[]
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput> | CompanyEmployeeCreateWithoutCompanyInput[] | CompanyEmployeeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutCompanyInput | CompanyEmployeeCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyEmployeeCreateManyCompanyInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput | CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput | CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutEmployerCompanyNestedInput = {
    create?: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput> | OrderCreateWithoutEmployerCompanyInput[] | OrderUncheckedCreateWithoutEmployerCompanyInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutEmployerCompanyInput | OrderCreateOrConnectWithoutEmployerCompanyInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutEmployerCompanyInput | OrderUpsertWithWhereUniqueWithoutEmployerCompanyInput[]
    createMany?: OrderCreateManyEmployerCompanyInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutEmployerCompanyInput | OrderUpdateWithWhereUniqueWithoutEmployerCompanyInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutEmployerCompanyInput | OrderUpdateManyWithWhereWithoutEmployerCompanyInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CompanyInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput> | CompanyInvoiceCreateWithoutCompanyInput[] | CompanyInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutCompanyInput | CompanyInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyInvoiceUpsertWithWhereUniqueWithoutCompanyInput | CompanyInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyInvoiceCreateManyCompanyInputEnvelope
    set?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    disconnect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    delete?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    connect?: CompanyInvoiceWhereUniqueInput | CompanyInvoiceWhereUniqueInput[]
    update?: CompanyInvoiceUpdateWithWhereUniqueWithoutCompanyInput | CompanyInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyInvoiceUpdateManyWithWhereWithoutCompanyInput | CompanyInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyInvoiceScalarWhereInput | CompanyInvoiceScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyInvoiceItemCreateNestedManyWithoutCompanyInvoiceInput = {
    create?: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput> | CompanyInvoiceItemCreateWithoutCompanyInvoiceInput[] | CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput[]
    connectOrCreate?: CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput | CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput[]
    createMany?: CompanyInvoiceItemCreateManyCompanyInvoiceInputEnvelope
    connect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
  }

  export type CompanyInvoiceItemUncheckedCreateNestedManyWithoutCompanyInvoiceInput = {
    create?: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput> | CompanyInvoiceItemCreateWithoutCompanyInvoiceInput[] | CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput[]
    connectOrCreate?: CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput | CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput[]
    createMany?: CompanyInvoiceItemCreateManyCompanyInvoiceInputEnvelope
    connect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CompanyUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutInvoicesInput
    upsert?: CompanyUpsertWithoutInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutInvoicesInput, CompanyUpdateWithoutInvoicesInput>, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyInvoiceItemUpdateManyWithoutCompanyInvoiceNestedInput = {
    create?: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput> | CompanyInvoiceItemCreateWithoutCompanyInvoiceInput[] | CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput[]
    connectOrCreate?: CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput | CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput[]
    upsert?: CompanyInvoiceItemUpsertWithWhereUniqueWithoutCompanyInvoiceInput | CompanyInvoiceItemUpsertWithWhereUniqueWithoutCompanyInvoiceInput[]
    createMany?: CompanyInvoiceItemCreateManyCompanyInvoiceInputEnvelope
    set?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    disconnect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    delete?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    connect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    update?: CompanyInvoiceItemUpdateWithWhereUniqueWithoutCompanyInvoiceInput | CompanyInvoiceItemUpdateWithWhereUniqueWithoutCompanyInvoiceInput[]
    updateMany?: CompanyInvoiceItemUpdateManyWithWhereWithoutCompanyInvoiceInput | CompanyInvoiceItemUpdateManyWithWhereWithoutCompanyInvoiceInput[]
    deleteMany?: CompanyInvoiceItemScalarWhereInput | CompanyInvoiceItemScalarWhereInput[]
  }

  export type CompanyInvoiceItemUncheckedUpdateManyWithoutCompanyInvoiceNestedInput = {
    create?: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput> | CompanyInvoiceItemCreateWithoutCompanyInvoiceInput[] | CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput[]
    connectOrCreate?: CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput | CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput[]
    upsert?: CompanyInvoiceItemUpsertWithWhereUniqueWithoutCompanyInvoiceInput | CompanyInvoiceItemUpsertWithWhereUniqueWithoutCompanyInvoiceInput[]
    createMany?: CompanyInvoiceItemCreateManyCompanyInvoiceInputEnvelope
    set?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    disconnect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    delete?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    connect?: CompanyInvoiceItemWhereUniqueInput | CompanyInvoiceItemWhereUniqueInput[]
    update?: CompanyInvoiceItemUpdateWithWhereUniqueWithoutCompanyInvoiceInput | CompanyInvoiceItemUpdateWithWhereUniqueWithoutCompanyInvoiceInput[]
    updateMany?: CompanyInvoiceItemUpdateManyWithWhereWithoutCompanyInvoiceInput | CompanyInvoiceItemUpdateManyWithWhereWithoutCompanyInvoiceInput[]
    deleteMany?: CompanyInvoiceItemScalarWhereInput | CompanyInvoiceItemScalarWhereInput[]
  }

  export type CompanyInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<CompanyInvoiceCreateWithoutItemsInput, CompanyInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutItemsInput
    connect?: CompanyInvoiceWhereUniqueInput
  }

  export type CompanyInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CompanyInvoiceCreateWithoutItemsInput, CompanyInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CompanyInvoiceCreateOrConnectWithoutItemsInput
    upsert?: CompanyInvoiceUpsertWithoutItemsInput
    connect?: CompanyInvoiceWhereUniqueInput
    update?: XOR<XOR<CompanyInvoiceUpdateToOneWithWhereWithoutItemsInput, CompanyInvoiceUpdateWithoutItemsInput>, CompanyInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompanyEmployeesInput = {
    create?: XOR<UserCreateWithoutCompanyEmployeesInput, UserUncheckedCreateWithoutCompanyEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyEmployeesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEmployeesInput
    upsert?: CompanyUpsertWithoutEmployeesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEmployeesInput, CompanyUpdateWithoutEmployeesInput>, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneRequiredWithoutCompanyEmployeesNestedInput = {
    create?: XOR<UserCreateWithoutCompanyEmployeesInput, UserUncheckedCreateWithoutCompanyEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyEmployeesInput
    upsert?: UserUpsertWithoutCompanyEmployeesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompanyEmployeesInput, UserUpdateWithoutCompanyEmployeesInput>, UserUncheckedUpdateWithoutCompanyEmployeesInput>
  }

  export type LocationCreateworkingDaysInput = {
    set: number[]
  }

  export type OrganizationCreateNestedOneWithoutLocationsInput = {
    create?: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type MenuCreateNestedManyWithoutLocationInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type UserLocationCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput> | UserLocationCreateWithoutLocationInput[] | UserLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutLocationInput | UserLocationCreateOrConnectWithoutLocationInput[]
    createMany?: UserLocationCreateManyLocationInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutLocationInput = {
    create?: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput> | CouponCreateWithoutLocationInput[] | CouponUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutLocationInput | CouponCreateOrConnectWithoutLocationInput[]
    createMany?: CouponCreateManyLocationInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type MenuUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type UserLocationUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput> | UserLocationCreateWithoutLocationInput[] | UserLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutLocationInput | UserLocationCreateOrConnectWithoutLocationInput[]
    createMany?: UserLocationCreateManyLocationInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput> | CouponCreateWithoutLocationInput[] | CouponUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutLocationInput | CouponCreateOrConnectWithoutLocationInput[]
    createMany?: CouponCreateManyLocationInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type LocationUpdateworkingDaysInput = {
    set?: number[]
    push?: number | number[]
  }

  export type OrganizationUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutLocationsInput
    upsert?: OrganizationUpsertWithoutLocationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutLocationsInput, OrganizationUpdateWithoutLocationsInput>, OrganizationUncheckedUpdateWithoutLocationsInput>
  }

  export type MenuUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutLocationInput | MenuUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutLocationInput | MenuUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutLocationInput | MenuUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserLocationUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput> | UserLocationCreateWithoutLocationInput[] | UserLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutLocationInput | UserLocationCreateOrConnectWithoutLocationInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutLocationInput | UserLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserLocationCreateManyLocationInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutLocationInput | UserLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutLocationInput | UserLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput> | CouponCreateWithoutLocationInput[] | CouponUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutLocationInput | CouponCreateOrConnectWithoutLocationInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutLocationInput | CouponUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CouponCreateManyLocationInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutLocationInput | CouponUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutLocationInput | CouponUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type MenuUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput> | MenuCreateWithoutLocationInput[] | MenuUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MenuCreateOrConnectWithoutLocationInput | MenuCreateOrConnectWithoutLocationInput[]
    upsert?: MenuUpsertWithWhereUniqueWithoutLocationInput | MenuUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MenuCreateManyLocationInputEnvelope
    set?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    disconnect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    delete?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    connect?: MenuWhereUniqueInput | MenuWhereUniqueInput[]
    update?: MenuUpdateWithWhereUniqueWithoutLocationInput | MenuUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MenuUpdateManyWithWhereWithoutLocationInput | MenuUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MenuScalarWhereInput | MenuScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput> | OrderCreateWithoutLocationInput[] | OrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutLocationInput | OrderCreateOrConnectWithoutLocationInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutLocationInput | OrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: OrderCreateManyLocationInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutLocationInput | OrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutLocationInput | OrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserLocationUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput> | UserLocationCreateWithoutLocationInput[] | UserLocationUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutLocationInput | UserLocationCreateOrConnectWithoutLocationInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutLocationInput | UserLocationUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: UserLocationCreateManyLocationInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutLocationInput | UserLocationUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutLocationInput | UserLocationUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput> | CouponCreateWithoutLocationInput[] | CouponUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutLocationInput | CouponCreateOrConnectWithoutLocationInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutLocationInput | CouponUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: CouponCreateManyLocationInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutLocationInput | CouponUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutLocationInput | CouponUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserLocationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type CompanyEmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput> | CompanyEmployeeCreateWithoutUserInput[] | CompanyEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutUserInput | CompanyEmployeeCreateOrConnectWithoutUserInput[]
    createMany?: CompanyEmployeeCreateManyUserInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CouponRedemptionCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type IncentiveGrantCreateNestedManyWithoutUserInput = {
    create?: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput> | IncentiveGrantCreateWithoutUserInput[] | IncentiveGrantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutUserInput | IncentiveGrantCreateOrConnectWithoutUserInput[]
    createMany?: IncentiveGrantCreateManyUserInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput> | WalletTransactionCreateWithoutUserInput[] | WalletTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutUserInput | WalletTransactionCreateOrConnectWithoutUserInput[]
    createMany?: WalletTransactionCreateManyUserInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput> | WalletTransactionCreateWithoutPerformedByInput[] | WalletTransactionUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPerformedByInput | WalletTransactionCreateOrConnectWithoutPerformedByInput[]
    createMany?: WalletTransactionCreateManyPerformedByInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type PushNotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput> | PushNotificationLogCreateWithoutUserInput[] | PushNotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutUserInput | PushNotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: PushNotificationLogCreateManyUserInputEnvelope
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput> | PaymentProviderConfigCreateWithoutUpdatedByInput[] | PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput | PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PaymentProviderConfigCreateManyUpdatedByInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type UserLocationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
  }

  export type CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput> | CompanyEmployeeCreateWithoutUserInput[] | CompanyEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutUserInput | CompanyEmployeeCreateOrConnectWithoutUserInput[]
    createMany?: CompanyEmployeeCreateManyUserInputEnvelope
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type IncentiveGrantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput> | IncentiveGrantCreateWithoutUserInput[] | IncentiveGrantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutUserInput | IncentiveGrantCreateOrConnectWithoutUserInput[]
    createMany?: IncentiveGrantCreateManyUserInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput> | WalletTransactionCreateWithoutUserInput[] | WalletTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutUserInput | WalletTransactionCreateOrConnectWithoutUserInput[]
    createMany?: WalletTransactionCreateManyUserInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput = {
    create?: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput> | WalletTransactionCreateWithoutPerformedByInput[] | WalletTransactionUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPerformedByInput | WalletTransactionCreateOrConnectWithoutPerformedByInput[]
    createMany?: WalletTransactionCreateManyPerformedByInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type PushNotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput> | PushNotificationLogCreateWithoutUserInput[] | PushNotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutUserInput | PushNotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: PushNotificationLogCreateManyUserInputEnvelope
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput> | PaymentProviderConfigCreateWithoutUpdatedByInput[] | PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput | PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PaymentProviderConfigCreateManyUpdatedByInputEnvelope
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserLocationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutUserInput | UserLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutUserInput | UserLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutUserInput | UserLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type CompanyEmployeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput> | CompanyEmployeeCreateWithoutUserInput[] | CompanyEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutUserInput | CompanyEmployeeCreateOrConnectWithoutUserInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutUserInput | CompanyEmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyEmployeeCreateManyUserInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutUserInput | CompanyEmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutUserInput | CompanyEmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CouponRedemptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutUserInput | CouponRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutUserInput | CouponRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutUserInput | CouponRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type IncentiveGrantUpdateManyWithoutUserNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput> | IncentiveGrantCreateWithoutUserInput[] | IncentiveGrantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutUserInput | IncentiveGrantCreateOrConnectWithoutUserInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutUserInput | IncentiveGrantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IncentiveGrantCreateManyUserInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutUserInput | IncentiveGrantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutUserInput | IncentiveGrantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput> | WalletTransactionCreateWithoutUserInput[] | WalletTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutUserInput | WalletTransactionCreateOrConnectWithoutUserInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutUserInput | WalletTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletTransactionCreateManyUserInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutUserInput | WalletTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutUserInput | WalletTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletTransactionUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput> | WalletTransactionCreateWithoutPerformedByInput[] | WalletTransactionUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPerformedByInput | WalletTransactionCreateOrConnectWithoutPerformedByInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutPerformedByInput | WalletTransactionUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: WalletTransactionCreateManyPerformedByInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutPerformedByInput | WalletTransactionUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutPerformedByInput | WalletTransactionUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type PushNotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput> | PushNotificationLogCreateWithoutUserInput[] | PushNotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutUserInput | PushNotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: PushNotificationLogUpsertWithWhereUniqueWithoutUserInput | PushNotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushNotificationLogCreateManyUserInputEnvelope
    set?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    disconnect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    delete?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    update?: PushNotificationLogUpdateWithWhereUniqueWithoutUserInput | PushNotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushNotificationLogUpdateManyWithWhereWithoutUserInput | PushNotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput> | PaymentProviderConfigCreateWithoutUpdatedByInput[] | PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput | PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutUpdatedByInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PaymentProviderConfigCreateManyUpdatedByInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutUpdatedByInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutUpdatedByInput | PaymentProviderConfigUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type UserLocationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput> | UserLocationCreateWithoutUserInput[] | UserLocationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLocationCreateOrConnectWithoutUserInput | UserLocationCreateOrConnectWithoutUserInput[]
    upsert?: UserLocationUpsertWithWhereUniqueWithoutUserInput | UserLocationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLocationCreateManyUserInputEnvelope
    set?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    disconnect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    delete?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    connect?: UserLocationWhereUniqueInput | UserLocationWhereUniqueInput[]
    update?: UserLocationUpdateWithWhereUniqueWithoutUserInput | UserLocationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLocationUpdateManyWithWhereWithoutUserInput | UserLocationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput> | CompanyEmployeeCreateWithoutUserInput[] | CompanyEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyEmployeeCreateOrConnectWithoutUserInput | CompanyEmployeeCreateOrConnectWithoutUserInput[]
    upsert?: CompanyEmployeeUpsertWithWhereUniqueWithoutUserInput | CompanyEmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyEmployeeCreateManyUserInputEnvelope
    set?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    disconnect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    delete?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    connect?: CompanyEmployeeWhereUniqueInput | CompanyEmployeeWhereUniqueInput[]
    update?: CompanyEmployeeUpdateWithWhereUniqueWithoutUserInput | CompanyEmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyEmployeeUpdateManyWithWhereWithoutUserInput | CompanyEmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput> | CouponRedemptionCreateWithoutUserInput[] | CouponRedemptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutUserInput | CouponRedemptionCreateOrConnectWithoutUserInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutUserInput | CouponRedemptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CouponRedemptionCreateManyUserInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutUserInput | CouponRedemptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutUserInput | CouponRedemptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput> | IncentiveGrantCreateWithoutUserInput[] | IncentiveGrantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutUserInput | IncentiveGrantCreateOrConnectWithoutUserInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutUserInput | IncentiveGrantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IncentiveGrantCreateManyUserInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutUserInput | IncentiveGrantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutUserInput | IncentiveGrantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput> | WalletTransactionCreateWithoutUserInput[] | WalletTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutUserInput | WalletTransactionCreateOrConnectWithoutUserInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutUserInput | WalletTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletTransactionCreateManyUserInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutUserInput | WalletTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutUserInput | WalletTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput> | WalletTransactionCreateWithoutPerformedByInput[] | WalletTransactionUncheckedCreateWithoutPerformedByInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutPerformedByInput | WalletTransactionCreateOrConnectWithoutPerformedByInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutPerformedByInput | WalletTransactionUpsertWithWhereUniqueWithoutPerformedByInput[]
    createMany?: WalletTransactionCreateManyPerformedByInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutPerformedByInput | WalletTransactionUpdateWithWhereUniqueWithoutPerformedByInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutPerformedByInput | WalletTransactionUpdateManyWithWhereWithoutPerformedByInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput> | PushNotificationLogCreateWithoutUserInput[] | PushNotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutUserInput | PushNotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: PushNotificationLogUpsertWithWhereUniqueWithoutUserInput | PushNotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushNotificationLogCreateManyUserInputEnvelope
    set?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    disconnect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    delete?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    update?: PushNotificationLogUpdateWithWhereUniqueWithoutUserInput | PushNotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushNotificationLogUpdateManyWithWhereWithoutUserInput | PushNotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput> | PaymentProviderConfigCreateWithoutUpdatedByInput[] | PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput | PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PaymentProviderConfigUpsertWithWhereUniqueWithoutUpdatedByInput | PaymentProviderConfigUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PaymentProviderConfigCreateManyUpdatedByInputEnvelope
    set?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    disconnect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    delete?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    connect?: PaymentProviderConfigWhereUniqueInput | PaymentProviderConfigWhereUniqueInput[]
    update?: PaymentProviderConfigUpdateWithWhereUniqueWithoutUpdatedByInput | PaymentProviderConfigUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PaymentProviderConfigUpdateManyWithWhereWithoutUpdatedByInput | PaymentProviderConfigUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserCreateNestedOneWithoutWalletTransactionsInput = {
    create?: XOR<UserCreateWithoutWalletTransactionsInput, UserUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutWalletTransactionsInput = {
    create?: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutWalletTransactionsInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPerformedWalletActionsInput = {
    create?: XOR<UserCreateWithoutPerformedWalletActionsInput, UserUncheckedCreateWithoutPerformedWalletActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformedWalletActionsInput
    connect?: UserWhereUniqueInput
  }

  export type IncentiveGrantCreateNestedOneWithoutWalletTransactionInput = {
    create?: XOR<IncentiveGrantCreateWithoutWalletTransactionInput, IncentiveGrantUncheckedCreateWithoutWalletTransactionInput>
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutWalletTransactionInput
    connect?: IncentiveGrantWhereUniqueInput
  }

  export type EnumWalletTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.WalletTransactionType
  }

  export type UserUpdateOneRequiredWithoutWalletTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutWalletTransactionsInput, UserUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletTransactionsInput
    upsert?: UserUpsertWithoutWalletTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletTransactionsInput, UserUpdateWithoutWalletTransactionsInput>, UserUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type OrderUpdateOneWithoutWalletTransactionsNestedInput = {
    create?: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutWalletTransactionsInput
    upsert?: OrderUpsertWithoutWalletTransactionsInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutWalletTransactionsInput, OrderUpdateWithoutWalletTransactionsInput>, OrderUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type UserUpdateOneWithoutPerformedWalletActionsNestedInput = {
    create?: XOR<UserCreateWithoutPerformedWalletActionsInput, UserUncheckedCreateWithoutPerformedWalletActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPerformedWalletActionsInput
    upsert?: UserUpsertWithoutPerformedWalletActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPerformedWalletActionsInput, UserUpdateWithoutPerformedWalletActionsInput>, UserUncheckedUpdateWithoutPerformedWalletActionsInput>
  }

  export type IncentiveGrantUpdateOneWithoutWalletTransactionNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutWalletTransactionInput, IncentiveGrantUncheckedCreateWithoutWalletTransactionInput>
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutWalletTransactionInput
    upsert?: IncentiveGrantUpsertWithoutWalletTransactionInput
    disconnect?: IncentiveGrantWhereInput | boolean
    delete?: IncentiveGrantWhereInput | boolean
    connect?: IncentiveGrantWhereUniqueInput
    update?: XOR<XOR<IncentiveGrantUpdateToOneWithWhereWithoutWalletTransactionInput, IncentiveGrantUpdateWithoutWalletTransactionInput>, IncentiveGrantUncheckedUpdateWithoutWalletTransactionInput>
  }

  export type UserCreateNestedOneWithoutLocationsInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutUsersInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput
    connect?: LocationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLocationsInput
    upsert?: UserUpsertWithoutLocationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLocationsInput, UserUpdateWithoutLocationsInput>, UserUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutUsersInput
    upsert?: LocationUpsertWithoutUsersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutUsersInput, LocationUpdateWithoutUsersInput>, LocationUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type LocationCreateNestedOneWithoutMenusInput = {
    create?: XOR<LocationCreateWithoutMenusInput, LocationUncheckedCreateWithoutMenusInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMenusInput
    connect?: LocationWhereUniqueInput
  }

  export type MenuItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuPromotionBannerCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput> | MenuPromotionBannerCreateWithoutMenuInput[] | MenuPromotionBannerUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutMenuInput | MenuPromotionBannerCreateOrConnectWithoutMenuInput[]
    createMany?: MenuPromotionBannerCreateManyMenuInputEnvelope
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuPromotionBannerUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput> | MenuPromotionBannerCreateWithoutMenuInput[] | MenuPromotionBannerUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutMenuInput | MenuPromotionBannerCreateOrConnectWithoutMenuInput[]
    createMany?: MenuPromotionBannerCreateManyMenuInputEnvelope
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutMenusNestedInput = {
    create?: XOR<LocationCreateWithoutMenusInput, LocationUncheckedCreateWithoutMenusInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMenusInput
    upsert?: LocationUpsertWithoutMenusInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutMenusInput, LocationUpdateWithoutMenusInput>, LocationUncheckedUpdateWithoutMenusInput>
  }

  export type MenuItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMenuInput | MenuItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMenuInput | MenuItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMenuInput | MenuItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuPromotionBannerUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput> | MenuPromotionBannerCreateWithoutMenuInput[] | MenuPromotionBannerUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutMenuInput | MenuPromotionBannerCreateOrConnectWithoutMenuInput[]
    upsert?: MenuPromotionBannerUpsertWithWhereUniqueWithoutMenuInput | MenuPromotionBannerUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuPromotionBannerCreateManyMenuInputEnvelope
    set?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    disconnect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    delete?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    update?: MenuPromotionBannerUpdateWithWhereUniqueWithoutMenuInput | MenuPromotionBannerUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuPromotionBannerUpdateManyWithWhereWithoutMenuInput | MenuPromotionBannerUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMenuInput | MenuItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMenuInput | MenuItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMenuInput | MenuItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuPromotionBannerUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput> | MenuPromotionBannerCreateWithoutMenuInput[] | MenuPromotionBannerUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutMenuInput | MenuPromotionBannerCreateOrConnectWithoutMenuInput[]
    upsert?: MenuPromotionBannerUpsertWithWhereUniqueWithoutMenuInput | MenuPromotionBannerUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuPromotionBannerCreateManyMenuInputEnvelope
    set?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    disconnect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    delete?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    update?: MenuPromotionBannerUpdateWithWhereUniqueWithoutMenuInput | MenuPromotionBannerUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuPromotionBannerUpdateManyWithWhereWithoutMenuInput | MenuPromotionBannerUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
  }

  export type CouponCreateNestedOneWithoutPromotionBannersInput = {
    create?: XOR<CouponCreateWithoutPromotionBannersInput, CouponUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: CouponCreateOrConnectWithoutPromotionBannersInput
    connect?: CouponWhereUniqueInput
  }

  export type MarketingTemplateCreateNestedOneWithoutPromotionBannersInput = {
    create?: XOR<MarketingTemplateCreateWithoutPromotionBannersInput, MarketingTemplateUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutPromotionBannersInput
    connect?: MarketingTemplateWhereUniqueInput
  }

  export type MenuPromotionBannerCreateNestedManyWithoutPromotionBannerInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput> | MenuPromotionBannerCreateWithoutPromotionBannerInput[] | MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput | MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput[]
    createMany?: MenuPromotionBannerCreateManyPromotionBannerInputEnvelope
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
  }

  export type MenuPromotionBannerUncheckedCreateNestedManyWithoutPromotionBannerInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput> | MenuPromotionBannerCreateWithoutPromotionBannerInput[] | MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput | MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput[]
    createMany?: MenuPromotionBannerCreateManyPromotionBannerInputEnvelope
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
  }

  export type CouponUpdateOneWithoutPromotionBannersNestedInput = {
    create?: XOR<CouponCreateWithoutPromotionBannersInput, CouponUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: CouponCreateOrConnectWithoutPromotionBannersInput
    upsert?: CouponUpsertWithoutPromotionBannersInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutPromotionBannersInput, CouponUpdateWithoutPromotionBannersInput>, CouponUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type MarketingTemplateUpdateOneWithoutPromotionBannersNestedInput = {
    create?: XOR<MarketingTemplateCreateWithoutPromotionBannersInput, MarketingTemplateUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutPromotionBannersInput
    upsert?: MarketingTemplateUpsertWithoutPromotionBannersInput
    disconnect?: MarketingTemplateWhereInput | boolean
    delete?: MarketingTemplateWhereInput | boolean
    connect?: MarketingTemplateWhereUniqueInput
    update?: XOR<XOR<MarketingTemplateUpdateToOneWithWhereWithoutPromotionBannersInput, MarketingTemplateUpdateWithoutPromotionBannersInput>, MarketingTemplateUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type MenuPromotionBannerUpdateManyWithoutPromotionBannerNestedInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput> | MenuPromotionBannerCreateWithoutPromotionBannerInput[] | MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput | MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput[]
    upsert?: MenuPromotionBannerUpsertWithWhereUniqueWithoutPromotionBannerInput | MenuPromotionBannerUpsertWithWhereUniqueWithoutPromotionBannerInput[]
    createMany?: MenuPromotionBannerCreateManyPromotionBannerInputEnvelope
    set?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    disconnect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    delete?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    update?: MenuPromotionBannerUpdateWithWhereUniqueWithoutPromotionBannerInput | MenuPromotionBannerUpdateWithWhereUniqueWithoutPromotionBannerInput[]
    updateMany?: MenuPromotionBannerUpdateManyWithWhereWithoutPromotionBannerInput | MenuPromotionBannerUpdateManyWithWhereWithoutPromotionBannerInput[]
    deleteMany?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
  }

  export type MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerNestedInput = {
    create?: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput> | MenuPromotionBannerCreateWithoutPromotionBannerInput[] | MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput[]
    connectOrCreate?: MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput | MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput[]
    upsert?: MenuPromotionBannerUpsertWithWhereUniqueWithoutPromotionBannerInput | MenuPromotionBannerUpsertWithWhereUniqueWithoutPromotionBannerInput[]
    createMany?: MenuPromotionBannerCreateManyPromotionBannerInputEnvelope
    set?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    disconnect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    delete?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    connect?: MenuPromotionBannerWhereUniqueInput | MenuPromotionBannerWhereUniqueInput[]
    update?: MenuPromotionBannerUpdateWithWhereUniqueWithoutPromotionBannerInput | MenuPromotionBannerUpdateWithWhereUniqueWithoutPromotionBannerInput[]
    updateMany?: MenuPromotionBannerUpdateManyWithWhereWithoutPromotionBannerInput | MenuPromotionBannerUpdateManyWithWhereWithoutPromotionBannerInput[]
    deleteMany?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutPromotionBannersInput = {
    create?: XOR<MenuCreateWithoutPromotionBannersInput, MenuUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: MenuCreateOrConnectWithoutPromotionBannersInput
    connect?: MenuWhereUniqueInput
  }

  export type PromotionBannerCreateNestedOneWithoutMenuAssignmentsInput = {
    create?: XOR<PromotionBannerCreateWithoutMenuAssignmentsInput, PromotionBannerUncheckedCreateWithoutMenuAssignmentsInput>
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMenuAssignmentsInput
    connect?: PromotionBannerWhereUniqueInput
  }

  export type MenuUpdateOneRequiredWithoutPromotionBannersNestedInput = {
    create?: XOR<MenuCreateWithoutPromotionBannersInput, MenuUncheckedCreateWithoutPromotionBannersInput>
    connectOrCreate?: MenuCreateOrConnectWithoutPromotionBannersInput
    upsert?: MenuUpsertWithoutPromotionBannersInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutPromotionBannersInput, MenuUpdateWithoutPromotionBannersInput>, MenuUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type PromotionBannerUpdateOneRequiredWithoutMenuAssignmentsNestedInput = {
    create?: XOR<PromotionBannerCreateWithoutMenuAssignmentsInput, PromotionBannerUncheckedCreateWithoutMenuAssignmentsInput>
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMenuAssignmentsInput
    upsert?: PromotionBannerUpsertWithoutMenuAssignmentsInput
    connect?: PromotionBannerWhereUniqueInput
    update?: XOR<XOR<PromotionBannerUpdateToOneWithWhereWithoutMenuAssignmentsInput, PromotionBannerUpdateWithoutMenuAssignmentsInput>, PromotionBannerUncheckedUpdateWithoutMenuAssignmentsInput>
  }

  export type MenuCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<MenuCreateWithoutMenuItemsInput, MenuUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutMenuItemsInput
    connect?: MenuWhereUniqueInput
  }

  export type DishCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<DishCreateWithoutMenuItemsInput, DishUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: DishCreateOrConnectWithoutMenuItemsInput
    connect?: DishWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput> | OrderItemCreateWithoutMenuItemInput[] | OrderItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutMenuItemInput | OrderItemCreateOrConnectWithoutMenuItemInput[]
    createMany?: OrderItemCreateManyMenuItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutMenuItemInput = {
    create?: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput> | OrderItemCreateWithoutMenuItemInput[] | OrderItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutMenuItemInput | OrderItemCreateOrConnectWithoutMenuItemInput[]
    createMany?: OrderItemCreateManyMenuItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type MenuUpdateOneRequiredWithoutMenuItemsNestedInput = {
    create?: XOR<MenuCreateWithoutMenuItemsInput, MenuUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutMenuItemsInput
    upsert?: MenuUpsertWithoutMenuItemsInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutMenuItemsInput, MenuUpdateWithoutMenuItemsInput>, MenuUncheckedUpdateWithoutMenuItemsInput>
  }

  export type DishUpdateOneRequiredWithoutMenuItemsNestedInput = {
    create?: XOR<DishCreateWithoutMenuItemsInput, DishUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: DishCreateOrConnectWithoutMenuItemsInput
    upsert?: DishUpsertWithoutMenuItemsInput
    connect?: DishWhereUniqueInput
    update?: XOR<XOR<DishUpdateToOneWithWhereWithoutMenuItemsInput, DishUpdateWithoutMenuItemsInput>, DishUncheckedUpdateWithoutMenuItemsInput>
  }

  export type OrderItemUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput> | OrderItemCreateWithoutMenuItemInput[] | OrderItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutMenuItemInput | OrderItemCreateOrConnectWithoutMenuItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutMenuItemInput | OrderItemUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: OrderItemCreateManyMenuItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutMenuItemInput | OrderItemUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutMenuItemInput | OrderItemUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutMenuItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput> | OrderItemCreateWithoutMenuItemInput[] | OrderItemUncheckedCreateWithoutMenuItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutMenuItemInput | OrderItemCreateOrConnectWithoutMenuItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutMenuItemInput | OrderItemUpsertWithWhereUniqueWithoutMenuItemInput[]
    createMany?: OrderItemCreateManyMenuItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutMenuItemInput | OrderItemUpdateWithWhereUniqueWithoutMenuItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutMenuItemInput | OrderItemUpdateManyWithWhereWithoutMenuItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DishCreateallergensInput = {
    set: string[]
  }

  export type DishCreatedietTagsInput = {
    set: string[]
  }

  export type MenuItemCreateNestedManyWithoutDishInput = {
    create?: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput> | MenuItemCreateWithoutDishInput[] | MenuItemUncheckedCreateWithoutDishInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutDishInput | MenuItemCreateOrConnectWithoutDishInput[]
    createMany?: MenuItemCreateManyDishInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutFreeItemDishInput = {
    create?: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput> | CouponCreateWithoutFreeItemDishInput[] | CouponUncheckedCreateWithoutFreeItemDishInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutFreeItemDishInput | CouponCreateOrConnectWithoutFreeItemDishInput[]
    createMany?: CouponCreateManyFreeItemDishInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutDishInput = {
    create?: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput> | MenuItemCreateWithoutDishInput[] | MenuItemUncheckedCreateWithoutDishInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutDishInput | MenuItemCreateOrConnectWithoutDishInput[]
    createMany?: MenuItemCreateManyDishInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutFreeItemDishInput = {
    create?: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput> | CouponCreateWithoutFreeItemDishInput[] | CouponUncheckedCreateWithoutFreeItemDishInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutFreeItemDishInput | CouponCreateOrConnectWithoutFreeItemDishInput[]
    createMany?: CouponCreateManyFreeItemDishInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type DishUpdateallergensInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DishUpdatedietTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MenuItemUpdateManyWithoutDishNestedInput = {
    create?: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput> | MenuItemCreateWithoutDishInput[] | MenuItemUncheckedCreateWithoutDishInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutDishInput | MenuItemCreateOrConnectWithoutDishInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutDishInput | MenuItemUpsertWithWhereUniqueWithoutDishInput[]
    createMany?: MenuItemCreateManyDishInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutDishInput | MenuItemUpdateWithWhereUniqueWithoutDishInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutDishInput | MenuItemUpdateManyWithWhereWithoutDishInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutFreeItemDishNestedInput = {
    create?: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput> | CouponCreateWithoutFreeItemDishInput[] | CouponUncheckedCreateWithoutFreeItemDishInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutFreeItemDishInput | CouponCreateOrConnectWithoutFreeItemDishInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutFreeItemDishInput | CouponUpsertWithWhereUniqueWithoutFreeItemDishInput[]
    createMany?: CouponCreateManyFreeItemDishInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutFreeItemDishInput | CouponUpdateWithWhereUniqueWithoutFreeItemDishInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutFreeItemDishInput | CouponUpdateManyWithWhereWithoutFreeItemDishInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutDishNestedInput = {
    create?: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput> | MenuItemCreateWithoutDishInput[] | MenuItemUncheckedCreateWithoutDishInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutDishInput | MenuItemCreateOrConnectWithoutDishInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutDishInput | MenuItemUpsertWithWhereUniqueWithoutDishInput[]
    createMany?: MenuItemCreateManyDishInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutDishInput | MenuItemUpdateWithWhereUniqueWithoutDishInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutDishInput | MenuItemUpdateManyWithWhereWithoutDishInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutFreeItemDishNestedInput = {
    create?: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput> | CouponCreateWithoutFreeItemDishInput[] | CouponUncheckedCreateWithoutFreeItemDishInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutFreeItemDishInput | CouponCreateOrConnectWithoutFreeItemDishInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutFreeItemDishInput | CouponUpsertWithWhereUniqueWithoutFreeItemDishInput[]
    createMany?: CouponCreateManyFreeItemDishInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutFreeItemDishInput | CouponUpdateWithWhereUniqueWithoutFreeItemDishInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutFreeItemDishInput | CouponUpdateManyWithWhereWithoutFreeItemDishInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutOrdersInput = {
    create?: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrdersInput
    connect?: LocationWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CouponRedemptionCreateNestedManyWithoutOrderInput = {
    create?: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput> | CouponRedemptionCreateWithoutOrderInput[] | CouponRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutOrderInput | CouponRedemptionCreateOrConnectWithoutOrderInput[]
    createMany?: CouponRedemptionCreateManyOrderInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CompanyCreateWithoutOrdersInput, CompanyUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutOrderInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput> | CouponRedemptionCreateWithoutOrderInput[] | CouponRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutOrderInput | CouponRedemptionCreateOrConnectWithoutOrderInput[]
    createMany?: CouponRedemptionCreateManyOrderInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type LocationUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutOrdersInput
    upsert?: LocationUpsertWithoutOrdersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutOrdersInput, LocationUpdateWithoutOrdersInput>, LocationUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CouponRedemptionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput> | CouponRedemptionCreateWithoutOrderInput[] | CouponRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutOrderInput | CouponRedemptionCreateOrConnectWithoutOrderInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutOrderInput | CouponRedemptionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CouponRedemptionCreateManyOrderInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutOrderInput | CouponRedemptionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutOrderInput | CouponRedemptionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutOrdersInput, CompanyUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutOrdersInput
    upsert?: CompanyUpsertWithoutOrdersInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutOrdersInput, CompanyUpdateWithoutOrdersInput>, CompanyUncheckedUpdateWithoutOrdersInput>
  }

  export type WalletTransactionUpdateManyWithoutOrderNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutOrderInput | WalletTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutOrderInput | WalletTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutOrderInput | WalletTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput> | CouponRedemptionCreateWithoutOrderInput[] | CouponRedemptionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutOrderInput | CouponRedemptionCreateOrConnectWithoutOrderInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutOrderInput | CouponRedemptionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: CouponRedemptionCreateManyOrderInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutOrderInput | CouponRedemptionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutOrderInput | CouponRedemptionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput> | WalletTransactionCreateWithoutOrderInput[] | WalletTransactionUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutOrderInput | WalletTransactionCreateOrConnectWithoutOrderInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutOrderInput | WalletTransactionUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: WalletTransactionCreateManyOrderInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutOrderInput | WalletTransactionUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutOrderInput | WalletTransactionUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutCouponsInput = {
    create?: XOR<LocationCreateWithoutCouponsInput, LocationUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCouponsInput
    connect?: LocationWhereUniqueInput
  }

  export type DishCreateNestedOneWithoutCouponsInput = {
    create?: XOR<DishCreateWithoutCouponsInput, DishUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: DishCreateOrConnectWithoutCouponsInput
    connect?: DishWhereUniqueInput
  }

  export type CouponRedemptionCreateNestedManyWithoutCouponInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type IncentiveGrantCreateNestedManyWithoutCouponInput = {
    create?: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput> | IncentiveGrantCreateWithoutCouponInput[] | IncentiveGrantUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutCouponInput | IncentiveGrantCreateOrConnectWithoutCouponInput[]
    createMany?: IncentiveGrantCreateManyCouponInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type SegmentIncentiveCreateNestedManyWithoutCouponInput = {
    create?: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput> | SegmentIncentiveCreateWithoutCouponInput[] | SegmentIncentiveUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutCouponInput | SegmentIncentiveCreateOrConnectWithoutCouponInput[]
    createMany?: SegmentIncentiveCreateManyCouponInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type PromotionBannerCreateNestedManyWithoutCouponInput = {
    create?: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput> | PromotionBannerCreateWithoutCouponInput[] | PromotionBannerUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutCouponInput | PromotionBannerCreateOrConnectWithoutCouponInput[]
    createMany?: PromotionBannerCreateManyCouponInputEnvelope
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
  }

  export type CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
  }

  export type IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput> | IncentiveGrantCreateWithoutCouponInput[] | IncentiveGrantUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutCouponInput | IncentiveGrantCreateOrConnectWithoutCouponInput[]
    createMany?: IncentiveGrantCreateManyCouponInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput> | SegmentIncentiveCreateWithoutCouponInput[] | SegmentIncentiveUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutCouponInput | SegmentIncentiveCreateOrConnectWithoutCouponInput[]
    createMany?: SegmentIncentiveCreateManyCouponInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type PromotionBannerUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput> | PromotionBannerCreateWithoutCouponInput[] | PromotionBannerUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutCouponInput | PromotionBannerCreateOrConnectWithoutCouponInput[]
    createMany?: PromotionBannerCreateManyCouponInputEnvelope
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
  }

  export type EnumCouponTypeFieldUpdateOperationsInput = {
    set?: $Enums.CouponType
  }

  export type LocationUpdateOneWithoutCouponsNestedInput = {
    create?: XOR<LocationCreateWithoutCouponsInput, LocationUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutCouponsInput
    upsert?: LocationUpsertWithoutCouponsInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutCouponsInput, LocationUpdateWithoutCouponsInput>, LocationUncheckedUpdateWithoutCouponsInput>
  }

  export type DishUpdateOneWithoutCouponsNestedInput = {
    create?: XOR<DishCreateWithoutCouponsInput, DishUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: DishCreateOrConnectWithoutCouponsInput
    upsert?: DishUpsertWithoutCouponsInput
    disconnect?: DishWhereInput | boolean
    delete?: DishWhereInput | boolean
    connect?: DishWhereUniqueInput
    update?: XOR<XOR<DishUpdateToOneWithWhereWithoutCouponsInput, DishUpdateWithoutCouponsInput>, DishUncheckedUpdateWithoutCouponsInput>
  }

  export type CouponRedemptionUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput | CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput | CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutCouponInput | CouponRedemptionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type IncentiveGrantUpdateManyWithoutCouponNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput> | IncentiveGrantCreateWithoutCouponInput[] | IncentiveGrantUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutCouponInput | IncentiveGrantCreateOrConnectWithoutCouponInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutCouponInput | IncentiveGrantUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: IncentiveGrantCreateManyCouponInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutCouponInput | IncentiveGrantUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutCouponInput | IncentiveGrantUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type SegmentIncentiveUpdateManyWithoutCouponNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput> | SegmentIncentiveCreateWithoutCouponInput[] | SegmentIncentiveUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutCouponInput | SegmentIncentiveCreateOrConnectWithoutCouponInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutCouponInput | SegmentIncentiveUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: SegmentIncentiveCreateManyCouponInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutCouponInput | SegmentIncentiveUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutCouponInput | SegmentIncentiveUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type PromotionBannerUpdateManyWithoutCouponNestedInput = {
    create?: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput> | PromotionBannerCreateWithoutCouponInput[] | PromotionBannerUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutCouponInput | PromotionBannerCreateOrConnectWithoutCouponInput[]
    upsert?: PromotionBannerUpsertWithWhereUniqueWithoutCouponInput | PromotionBannerUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: PromotionBannerCreateManyCouponInputEnvelope
    set?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    disconnect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    delete?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    update?: PromotionBannerUpdateWithWhereUniqueWithoutCouponInput | PromotionBannerUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: PromotionBannerUpdateManyWithWhereWithoutCouponInput | PromotionBannerUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput> | CouponRedemptionCreateWithoutCouponInput[] | CouponRedemptionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: CouponRedemptionCreateOrConnectWithoutCouponInput | CouponRedemptionCreateOrConnectWithoutCouponInput[]
    upsert?: CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput | CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: CouponRedemptionCreateManyCouponInputEnvelope
    set?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    disconnect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    delete?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    connect?: CouponRedemptionWhereUniqueInput | CouponRedemptionWhereUniqueInput[]
    update?: CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput | CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: CouponRedemptionUpdateManyWithWhereWithoutCouponInput | CouponRedemptionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput> | IncentiveGrantCreateWithoutCouponInput[] | IncentiveGrantUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutCouponInput | IncentiveGrantCreateOrConnectWithoutCouponInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutCouponInput | IncentiveGrantUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: IncentiveGrantCreateManyCouponInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutCouponInput | IncentiveGrantUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutCouponInput | IncentiveGrantUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput> | SegmentIncentiveCreateWithoutCouponInput[] | SegmentIncentiveUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutCouponInput | SegmentIncentiveCreateOrConnectWithoutCouponInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutCouponInput | SegmentIncentiveUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: SegmentIncentiveCreateManyCouponInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutCouponInput | SegmentIncentiveUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutCouponInput | SegmentIncentiveUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput> | PromotionBannerCreateWithoutCouponInput[] | PromotionBannerUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutCouponInput | PromotionBannerCreateOrConnectWithoutCouponInput[]
    upsert?: PromotionBannerUpsertWithWhereUniqueWithoutCouponInput | PromotionBannerUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: PromotionBannerCreateManyCouponInputEnvelope
    set?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    disconnect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    delete?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    update?: PromotionBannerUpdateWithWhereUniqueWithoutCouponInput | PromotionBannerUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: PromotionBannerUpdateManyWithWhereWithoutCouponInput | PromotionBannerUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
  }

  export type CouponCreateNestedOneWithoutRedemptionsInput = {
    create?: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutRedemptionsInput
    connect?: CouponWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCouponRedemptionsInput = {
    create?: XOR<UserCreateWithoutCouponRedemptionsInput, UserUncheckedCreateWithoutCouponRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCouponRedemptionsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutCouponRedemptionsInput = {
    create?: XOR<OrderCreateWithoutCouponRedemptionsInput, OrderUncheckedCreateWithoutCouponRedemptionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCouponRedemptionsInput
    connect?: OrderWhereUniqueInput
  }

  export type CouponUpdateOneRequiredWithoutRedemptionsNestedInput = {
    create?: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutRedemptionsInput
    upsert?: CouponUpsertWithoutRedemptionsInput
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutRedemptionsInput, CouponUpdateWithoutRedemptionsInput>, CouponUncheckedUpdateWithoutRedemptionsInput>
  }

  export type UserUpdateOneRequiredWithoutCouponRedemptionsNestedInput = {
    create?: XOR<UserCreateWithoutCouponRedemptionsInput, UserUncheckedCreateWithoutCouponRedemptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCouponRedemptionsInput
    upsert?: UserUpsertWithoutCouponRedemptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCouponRedemptionsInput, UserUpdateWithoutCouponRedemptionsInput>, UserUncheckedUpdateWithoutCouponRedemptionsInput>
  }

  export type OrderUpdateOneRequiredWithoutCouponRedemptionsNestedInput = {
    create?: XOR<OrderCreateWithoutCouponRedemptionsInput, OrderUncheckedCreateWithoutCouponRedemptionsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutCouponRedemptionsInput
    upsert?: OrderUpsertWithoutCouponRedemptionsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutCouponRedemptionsInput, OrderUpdateWithoutCouponRedemptionsInput>, OrderUncheckedUpdateWithoutCouponRedemptionsInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type MenuItemCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MenuItemCreateWithoutOrderItemsInput, MenuItemUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutOrderItemsInput
    connect?: MenuItemWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type MenuItemUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MenuItemCreateWithoutOrderItemsInput, MenuItemUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutOrderItemsInput
    upsert?: MenuItemUpsertWithoutOrderItemsInput
    connect?: MenuItemWhereUniqueInput
    update?: XOR<XOR<MenuItemUpdateToOneWithWhereWithoutOrderItemsInput, MenuItemUpdateWithoutOrderItemsInput>, MenuItemUncheckedUpdateWithoutOrderItemsInput>
  }

  export type EnumMetadataTypeFieldUpdateOperationsInput = {
    set?: $Enums.MetadataType
  }

  export type OrganizationCreateNestedOneWithoutSegmentsInput = {
    create?: XOR<OrganizationCreateWithoutSegmentsInput, OrganizationUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSegmentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InAppMessageCreateNestedManyWithoutSegmentInput = {
    create?: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput> | InAppMessageCreateWithoutSegmentInput[] | InAppMessageUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutSegmentInput | InAppMessageCreateOrConnectWithoutSegmentInput[]
    createMany?: InAppMessageCreateManySegmentInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type MarketingWorkflowCreateNestedManyWithoutSegmentInput = {
    create?: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput> | MarketingWorkflowCreateWithoutSegmentInput[] | MarketingWorkflowUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutSegmentInput | MarketingWorkflowCreateOrConnectWithoutSegmentInput[]
    createMany?: MarketingWorkflowCreateManySegmentInputEnvelope
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
  }

  export type SegmentIncentiveCreateNestedManyWithoutSegmentInput = {
    create?: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput> | SegmentIncentiveCreateWithoutSegmentInput[] | SegmentIncentiveUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutSegmentInput | SegmentIncentiveCreateOrConnectWithoutSegmentInput[]
    createMany?: SegmentIncentiveCreateManySegmentInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type PushNotificationCreateNestedManyWithoutSegmentInput = {
    create?: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput> | PushNotificationCreateWithoutSegmentInput[] | PushNotificationUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutSegmentInput | PushNotificationCreateOrConnectWithoutSegmentInput[]
    createMany?: PushNotificationCreateManySegmentInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type InAppMessageUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput> | InAppMessageCreateWithoutSegmentInput[] | InAppMessageUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutSegmentInput | InAppMessageCreateOrConnectWithoutSegmentInput[]
    createMany?: InAppMessageCreateManySegmentInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput> | MarketingWorkflowCreateWithoutSegmentInput[] | MarketingWorkflowUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutSegmentInput | MarketingWorkflowCreateOrConnectWithoutSegmentInput[]
    createMany?: MarketingWorkflowCreateManySegmentInputEnvelope
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
  }

  export type SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput> | SegmentIncentiveCreateWithoutSegmentInput[] | SegmentIncentiveUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutSegmentInput | SegmentIncentiveCreateOrConnectWithoutSegmentInput[]
    createMany?: SegmentIncentiveCreateManySegmentInputEnvelope
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutSegmentInput = {
    create?: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput> | PushNotificationCreateWithoutSegmentInput[] | PushNotificationUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutSegmentInput | PushNotificationCreateOrConnectWithoutSegmentInput[]
    createMany?: PushNotificationCreateManySegmentInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutSegmentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSegmentsInput, OrganizationUncheckedCreateWithoutSegmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSegmentsInput
    upsert?: OrganizationUpsertWithoutSegmentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSegmentsInput, OrganizationUpdateWithoutSegmentsInput>, OrganizationUncheckedUpdateWithoutSegmentsInput>
  }

  export type InAppMessageUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput> | InAppMessageCreateWithoutSegmentInput[] | InAppMessageUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutSegmentInput | InAppMessageCreateOrConnectWithoutSegmentInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutSegmentInput | InAppMessageUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: InAppMessageCreateManySegmentInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutSegmentInput | InAppMessageUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutSegmentInput | InAppMessageUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type MarketingWorkflowUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput> | MarketingWorkflowCreateWithoutSegmentInput[] | MarketingWorkflowUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutSegmentInput | MarketingWorkflowCreateOrConnectWithoutSegmentInput[]
    upsert?: MarketingWorkflowUpsertWithWhereUniqueWithoutSegmentInput | MarketingWorkflowUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: MarketingWorkflowCreateManySegmentInputEnvelope
    set?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    disconnect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    delete?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    update?: MarketingWorkflowUpdateWithWhereUniqueWithoutSegmentInput | MarketingWorkflowUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: MarketingWorkflowUpdateManyWithWhereWithoutSegmentInput | MarketingWorkflowUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
  }

  export type SegmentIncentiveUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput> | SegmentIncentiveCreateWithoutSegmentInput[] | SegmentIncentiveUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutSegmentInput | SegmentIncentiveCreateOrConnectWithoutSegmentInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutSegmentInput | SegmentIncentiveUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: SegmentIncentiveCreateManySegmentInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutSegmentInput | SegmentIncentiveUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutSegmentInput | SegmentIncentiveUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type PushNotificationUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput> | PushNotificationCreateWithoutSegmentInput[] | PushNotificationUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutSegmentInput | PushNotificationCreateOrConnectWithoutSegmentInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutSegmentInput | PushNotificationUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: PushNotificationCreateManySegmentInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutSegmentInput | PushNotificationUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutSegmentInput | PushNotificationUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput> | InAppMessageCreateWithoutSegmentInput[] | InAppMessageUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutSegmentInput | InAppMessageCreateOrConnectWithoutSegmentInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutSegmentInput | InAppMessageUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: InAppMessageCreateManySegmentInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutSegmentInput | InAppMessageUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutSegmentInput | InAppMessageUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput> | MarketingWorkflowCreateWithoutSegmentInput[] | MarketingWorkflowUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutSegmentInput | MarketingWorkflowCreateOrConnectWithoutSegmentInput[]
    upsert?: MarketingWorkflowUpsertWithWhereUniqueWithoutSegmentInput | MarketingWorkflowUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: MarketingWorkflowCreateManySegmentInputEnvelope
    set?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    disconnect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    delete?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    connect?: MarketingWorkflowWhereUniqueInput | MarketingWorkflowWhereUniqueInput[]
    update?: MarketingWorkflowUpdateWithWhereUniqueWithoutSegmentInput | MarketingWorkflowUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: MarketingWorkflowUpdateManyWithWhereWithoutSegmentInput | MarketingWorkflowUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput> | SegmentIncentiveCreateWithoutSegmentInput[] | SegmentIncentiveUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutSegmentInput | SegmentIncentiveCreateOrConnectWithoutSegmentInput[]
    upsert?: SegmentIncentiveUpsertWithWhereUniqueWithoutSegmentInput | SegmentIncentiveUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: SegmentIncentiveCreateManySegmentInputEnvelope
    set?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    disconnect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    delete?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    connect?: SegmentIncentiveWhereUniqueInput | SegmentIncentiveWhereUniqueInput[]
    update?: SegmentIncentiveUpdateWithWhereUniqueWithoutSegmentInput | SegmentIncentiveUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: SegmentIncentiveUpdateManyWithWhereWithoutSegmentInput | SegmentIncentiveUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
  }

  export type PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput = {
    create?: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput> | PushNotificationCreateWithoutSegmentInput[] | PushNotificationUncheckedCreateWithoutSegmentInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutSegmentInput | PushNotificationCreateOrConnectWithoutSegmentInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutSegmentInput | PushNotificationUpsertWithWhereUniqueWithoutSegmentInput[]
    createMany?: PushNotificationCreateManySegmentInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutSegmentInput | PushNotificationUpdateWithWhereUniqueWithoutSegmentInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutSegmentInput | PushNotificationUpdateManyWithWhereWithoutSegmentInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutInAppMessagesInput = {
    create?: XOR<OrganizationCreateWithoutInAppMessagesInput, OrganizationUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInAppMessagesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerSegmentCreateNestedOneWithoutInAppMessagesInput = {
    create?: XOR<CustomerSegmentCreateWithoutInAppMessagesInput, CustomerSegmentUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutInAppMessagesInput
    connect?: CustomerSegmentWhereUniqueInput
  }

  export type MarketingTemplateCreateNestedOneWithoutInAppMessagesInput = {
    create?: XOR<MarketingTemplateCreateWithoutInAppMessagesInput, MarketingTemplateUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutInAppMessagesInput
    connect?: MarketingTemplateWhereUniqueInput
  }

  export type InAppMessageReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput> | InAppMessageReadCreateWithoutMessageInput[] | InAppMessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: InAppMessageReadCreateOrConnectWithoutMessageInput | InAppMessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: InAppMessageReadCreateManyMessageInputEnvelope
    connect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
  }

  export type InAppMessageReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput> | InAppMessageReadCreateWithoutMessageInput[] | InAppMessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: InAppMessageReadCreateOrConnectWithoutMessageInput | InAppMessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: InAppMessageReadCreateManyMessageInputEnvelope
    connect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutInAppMessagesNestedInput = {
    create?: XOR<OrganizationCreateWithoutInAppMessagesInput, OrganizationUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutInAppMessagesInput
    upsert?: OrganizationUpsertWithoutInAppMessagesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutInAppMessagesInput, OrganizationUpdateWithoutInAppMessagesInput>, OrganizationUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type CustomerSegmentUpdateOneRequiredWithoutInAppMessagesNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutInAppMessagesInput, CustomerSegmentUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutInAppMessagesInput
    upsert?: CustomerSegmentUpsertWithoutInAppMessagesInput
    connect?: CustomerSegmentWhereUniqueInput
    update?: XOR<XOR<CustomerSegmentUpdateToOneWithWhereWithoutInAppMessagesInput, CustomerSegmentUpdateWithoutInAppMessagesInput>, CustomerSegmentUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type MarketingTemplateUpdateOneWithoutInAppMessagesNestedInput = {
    create?: XOR<MarketingTemplateCreateWithoutInAppMessagesInput, MarketingTemplateUncheckedCreateWithoutInAppMessagesInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutInAppMessagesInput
    upsert?: MarketingTemplateUpsertWithoutInAppMessagesInput
    disconnect?: MarketingTemplateWhereInput | boolean
    delete?: MarketingTemplateWhereInput | boolean
    connect?: MarketingTemplateWhereUniqueInput
    update?: XOR<XOR<MarketingTemplateUpdateToOneWithWhereWithoutInAppMessagesInput, MarketingTemplateUpdateWithoutInAppMessagesInput>, MarketingTemplateUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type InAppMessageReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput> | InAppMessageReadCreateWithoutMessageInput[] | InAppMessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: InAppMessageReadCreateOrConnectWithoutMessageInput | InAppMessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: InAppMessageReadUpsertWithWhereUniqueWithoutMessageInput | InAppMessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: InAppMessageReadCreateManyMessageInputEnvelope
    set?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    disconnect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    delete?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    connect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    update?: InAppMessageReadUpdateWithWhereUniqueWithoutMessageInput | InAppMessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: InAppMessageReadUpdateManyWithWhereWithoutMessageInput | InAppMessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: InAppMessageReadScalarWhereInput | InAppMessageReadScalarWhereInput[]
  }

  export type InAppMessageReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput> | InAppMessageReadCreateWithoutMessageInput[] | InAppMessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: InAppMessageReadCreateOrConnectWithoutMessageInput | InAppMessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: InAppMessageReadUpsertWithWhereUniqueWithoutMessageInput | InAppMessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: InAppMessageReadCreateManyMessageInputEnvelope
    set?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    disconnect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    delete?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    connect?: InAppMessageReadWhereUniqueInput | InAppMessageReadWhereUniqueInput[]
    update?: InAppMessageReadUpdateWithWhereUniqueWithoutMessageInput | InAppMessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: InAppMessageReadUpdateManyWithWhereWithoutMessageInput | InAppMessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: InAppMessageReadScalarWhereInput | InAppMessageReadScalarWhereInput[]
  }

  export type InAppMessageCreateNestedOneWithoutReadByInput = {
    create?: XOR<InAppMessageCreateWithoutReadByInput, InAppMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: InAppMessageCreateOrConnectWithoutReadByInput
    connect?: InAppMessageWhereUniqueInput
  }

  export type InAppMessageUpdateOneRequiredWithoutReadByNestedInput = {
    create?: XOR<InAppMessageCreateWithoutReadByInput, InAppMessageUncheckedCreateWithoutReadByInput>
    connectOrCreate?: InAppMessageCreateOrConnectWithoutReadByInput
    upsert?: InAppMessageUpsertWithoutReadByInput
    connect?: InAppMessageWhereUniqueInput
    update?: XOR<XOR<InAppMessageUpdateToOneWithWhereWithoutReadByInput, InAppMessageUpdateWithoutReadByInput>, InAppMessageUncheckedUpdateWithoutReadByInput>
  }

  export type OrganizationCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<OrganizationCreateWithoutWorkflowsInput, OrganizationUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWorkflowsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerSegmentCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<CustomerSegmentCreateWithoutWorkflowsInput, CustomerSegmentUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutWorkflowsInput
    connect?: CustomerSegmentWhereUniqueInput
  }

  export type WorkflowExecutionLogCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionLogCreateWithoutWorkflowInput[] | WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput | WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowExecutionLogCreateManyWorkflowInputEnvelope
    connect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
  }

  export type WorkflowExecutionLogUncheckedCreateNestedManyWithoutWorkflowInput = {
    create?: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionLogCreateWithoutWorkflowInput[] | WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput | WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput[]
    createMany?: WorkflowExecutionLogCreateManyWorkflowInputEnvelope
    connect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<OrganizationCreateWithoutWorkflowsInput, OrganizationUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutWorkflowsInput
    upsert?: OrganizationUpsertWithoutWorkflowsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutWorkflowsInput, OrganizationUpdateWithoutWorkflowsInput>, OrganizationUncheckedUpdateWithoutWorkflowsInput>
  }

  export type CustomerSegmentUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutWorkflowsInput, CustomerSegmentUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutWorkflowsInput
    upsert?: CustomerSegmentUpsertWithoutWorkflowsInput
    connect?: CustomerSegmentWhereUniqueInput
    update?: XOR<XOR<CustomerSegmentUpdateToOneWithWhereWithoutWorkflowsInput, CustomerSegmentUpdateWithoutWorkflowsInput>, CustomerSegmentUncheckedUpdateWithoutWorkflowsInput>
  }

  export type WorkflowExecutionLogUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionLogCreateWithoutWorkflowInput[] | WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput | WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowExecutionLogUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionLogUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowExecutionLogCreateManyWorkflowInputEnvelope
    set?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    disconnect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    delete?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    connect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    update?: WorkflowExecutionLogUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionLogUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowExecutionLogUpdateManyWithWhereWithoutWorkflowInput | WorkflowExecutionLogUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowExecutionLogScalarWhereInput | WorkflowExecutionLogScalarWhereInput[]
  }

  export type WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowNestedInput = {
    create?: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput> | WorkflowExecutionLogCreateWithoutWorkflowInput[] | WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput[]
    connectOrCreate?: WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput | WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput[]
    upsert?: WorkflowExecutionLogUpsertWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionLogUpsertWithWhereUniqueWithoutWorkflowInput[]
    createMany?: WorkflowExecutionLogCreateManyWorkflowInputEnvelope
    set?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    disconnect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    delete?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    connect?: WorkflowExecutionLogWhereUniqueInput | WorkflowExecutionLogWhereUniqueInput[]
    update?: WorkflowExecutionLogUpdateWithWhereUniqueWithoutWorkflowInput | WorkflowExecutionLogUpdateWithWhereUniqueWithoutWorkflowInput[]
    updateMany?: WorkflowExecutionLogUpdateManyWithWhereWithoutWorkflowInput | WorkflowExecutionLogUpdateManyWithWhereWithoutWorkflowInput[]
    deleteMany?: WorkflowExecutionLogScalarWhereInput | WorkflowExecutionLogScalarWhereInput[]
  }

  export type MarketingWorkflowCreateNestedOneWithoutExecutionLogsInput = {
    create?: XOR<MarketingWorkflowCreateWithoutExecutionLogsInput, MarketingWorkflowUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutExecutionLogsInput
    connect?: MarketingWorkflowWhereUniqueInput
  }

  export type MarketingWorkflowUpdateOneRequiredWithoutExecutionLogsNestedInput = {
    create?: XOR<MarketingWorkflowCreateWithoutExecutionLogsInput, MarketingWorkflowUncheckedCreateWithoutExecutionLogsInput>
    connectOrCreate?: MarketingWorkflowCreateOrConnectWithoutExecutionLogsInput
    upsert?: MarketingWorkflowUpsertWithoutExecutionLogsInput
    connect?: MarketingWorkflowWhereUniqueInput
    update?: XOR<XOR<MarketingWorkflowUpdateToOneWithWhereWithoutExecutionLogsInput, MarketingWorkflowUpdateWithoutExecutionLogsInput>, MarketingWorkflowUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type OrganizationCreateNestedOneWithoutSegmentIncentivesInput = {
    create?: XOR<OrganizationCreateWithoutSegmentIncentivesInput, OrganizationUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSegmentIncentivesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerSegmentCreateNestedOneWithoutSegmentIncentivesInput = {
    create?: XOR<CustomerSegmentCreateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutSegmentIncentivesInput
    connect?: CustomerSegmentWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutSegmentIncentivesInput = {
    create?: XOR<CouponCreateWithoutSegmentIncentivesInput, CouponUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: CouponCreateOrConnectWithoutSegmentIncentivesInput
    connect?: CouponWhereUniqueInput
  }

  export type IncentiveGrantCreateNestedManyWithoutSegmentIncentiveInput = {
    create?: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput> | IncentiveGrantCreateWithoutSegmentIncentiveInput[] | IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput | IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput[]
    createMany?: IncentiveGrantCreateManySegmentIncentiveInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type IncentiveGrantUncheckedCreateNestedManyWithoutSegmentIncentiveInput = {
    create?: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput> | IncentiveGrantCreateWithoutSegmentIncentiveInput[] | IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput | IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput[]
    createMany?: IncentiveGrantCreateManySegmentIncentiveInputEnvelope
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutSegmentIncentivesNestedInput = {
    create?: XOR<OrganizationCreateWithoutSegmentIncentivesInput, OrganizationUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSegmentIncentivesInput
    upsert?: OrganizationUpsertWithoutSegmentIncentivesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutSegmentIncentivesInput, OrganizationUpdateWithoutSegmentIncentivesInput>, OrganizationUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type CustomerSegmentUpdateOneRequiredWithoutSegmentIncentivesNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutSegmentIncentivesInput
    upsert?: CustomerSegmentUpsertWithoutSegmentIncentivesInput
    connect?: CustomerSegmentWhereUniqueInput
    update?: XOR<XOR<CustomerSegmentUpdateToOneWithWhereWithoutSegmentIncentivesInput, CustomerSegmentUpdateWithoutSegmentIncentivesInput>, CustomerSegmentUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type CouponUpdateOneWithoutSegmentIncentivesNestedInput = {
    create?: XOR<CouponCreateWithoutSegmentIncentivesInput, CouponUncheckedCreateWithoutSegmentIncentivesInput>
    connectOrCreate?: CouponCreateOrConnectWithoutSegmentIncentivesInput
    upsert?: CouponUpsertWithoutSegmentIncentivesInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutSegmentIncentivesInput, CouponUpdateWithoutSegmentIncentivesInput>, CouponUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type IncentiveGrantUpdateManyWithoutSegmentIncentiveNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput> | IncentiveGrantCreateWithoutSegmentIncentiveInput[] | IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput | IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutSegmentIncentiveInput | IncentiveGrantUpsertWithWhereUniqueWithoutSegmentIncentiveInput[]
    createMany?: IncentiveGrantCreateManySegmentIncentiveInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutSegmentIncentiveInput | IncentiveGrantUpdateWithWhereUniqueWithoutSegmentIncentiveInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutSegmentIncentiveInput | IncentiveGrantUpdateManyWithWhereWithoutSegmentIncentiveInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveNestedInput = {
    create?: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput> | IncentiveGrantCreateWithoutSegmentIncentiveInput[] | IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput[]
    connectOrCreate?: IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput | IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput[]
    upsert?: IncentiveGrantUpsertWithWhereUniqueWithoutSegmentIncentiveInput | IncentiveGrantUpsertWithWhereUniqueWithoutSegmentIncentiveInput[]
    createMany?: IncentiveGrantCreateManySegmentIncentiveInputEnvelope
    set?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    disconnect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    delete?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    connect?: IncentiveGrantWhereUniqueInput | IncentiveGrantWhereUniqueInput[]
    update?: IncentiveGrantUpdateWithWhereUniqueWithoutSegmentIncentiveInput | IncentiveGrantUpdateWithWhereUniqueWithoutSegmentIncentiveInput[]
    updateMany?: IncentiveGrantUpdateManyWithWhereWithoutSegmentIncentiveInput | IncentiveGrantUpdateManyWithWhereWithoutSegmentIncentiveInput[]
    deleteMany?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMarketingTemplatesInput = {
    create?: XOR<OrganizationCreateWithoutMarketingTemplatesInput, OrganizationUncheckedCreateWithoutMarketingTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMarketingTemplatesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type InAppMessageCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput> | InAppMessageCreateWithoutMarketingTemplateInput[] | InAppMessageUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutMarketingTemplateInput | InAppMessageCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: InAppMessageCreateManyMarketingTemplateInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type PromotionBannerCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput> | PromotionBannerCreateWithoutMarketingTemplateInput[] | PromotionBannerUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMarketingTemplateInput | PromotionBannerCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: PromotionBannerCreateManyMarketingTemplateInputEnvelope
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
  }

  export type PushNotificationCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput> | PushNotificationCreateWithoutMarketingTemplateInput[] | PushNotificationUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutMarketingTemplateInput | PushNotificationCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: PushNotificationCreateManyMarketingTemplateInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type InAppMessageUncheckedCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput> | InAppMessageCreateWithoutMarketingTemplateInput[] | InAppMessageUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutMarketingTemplateInput | InAppMessageCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: InAppMessageCreateManyMarketingTemplateInputEnvelope
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
  }

  export type PromotionBannerUncheckedCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput> | PromotionBannerCreateWithoutMarketingTemplateInput[] | PromotionBannerUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMarketingTemplateInput | PromotionBannerCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: PromotionBannerCreateManyMarketingTemplateInputEnvelope
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
  }

  export type PushNotificationUncheckedCreateNestedManyWithoutMarketingTemplateInput = {
    create?: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput> | PushNotificationCreateWithoutMarketingTemplateInput[] | PushNotificationUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutMarketingTemplateInput | PushNotificationCreateOrConnectWithoutMarketingTemplateInput[]
    createMany?: PushNotificationCreateManyMarketingTemplateInputEnvelope
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
  }

  export type EnumMarketingTemplateTypeFieldUpdateOperationsInput = {
    set?: $Enums.MarketingTemplateType
  }

  export type EnumMarketingTemplateStatusFieldUpdateOperationsInput = {
    set?: $Enums.MarketingTemplateStatus
  }

  export type OrganizationUpdateOneWithoutMarketingTemplatesNestedInput = {
    create?: XOR<OrganizationCreateWithoutMarketingTemplatesInput, OrganizationUncheckedCreateWithoutMarketingTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMarketingTemplatesInput
    upsert?: OrganizationUpsertWithoutMarketingTemplatesInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMarketingTemplatesInput, OrganizationUpdateWithoutMarketingTemplatesInput>, OrganizationUncheckedUpdateWithoutMarketingTemplatesInput>
  }

  export type InAppMessageUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput> | InAppMessageCreateWithoutMarketingTemplateInput[] | InAppMessageUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutMarketingTemplateInput | InAppMessageCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutMarketingTemplateInput | InAppMessageUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: InAppMessageCreateManyMarketingTemplateInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutMarketingTemplateInput | InAppMessageUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutMarketingTemplateInput | InAppMessageUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type PromotionBannerUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput> | PromotionBannerCreateWithoutMarketingTemplateInput[] | PromotionBannerUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMarketingTemplateInput | PromotionBannerCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: PromotionBannerUpsertWithWhereUniqueWithoutMarketingTemplateInput | PromotionBannerUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: PromotionBannerCreateManyMarketingTemplateInputEnvelope
    set?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    disconnect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    delete?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    update?: PromotionBannerUpdateWithWhereUniqueWithoutMarketingTemplateInput | PromotionBannerUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: PromotionBannerUpdateManyWithWhereWithoutMarketingTemplateInput | PromotionBannerUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
  }

  export type PushNotificationUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput> | PushNotificationCreateWithoutMarketingTemplateInput[] | PushNotificationUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutMarketingTemplateInput | PushNotificationCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutMarketingTemplateInput | PushNotificationUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: PushNotificationCreateManyMarketingTemplateInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutMarketingTemplateInput | PushNotificationUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutMarketingTemplateInput | PushNotificationUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type InAppMessageUncheckedUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput> | InAppMessageCreateWithoutMarketingTemplateInput[] | InAppMessageUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: InAppMessageCreateOrConnectWithoutMarketingTemplateInput | InAppMessageCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: InAppMessageUpsertWithWhereUniqueWithoutMarketingTemplateInput | InAppMessageUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: InAppMessageCreateManyMarketingTemplateInputEnvelope
    set?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    disconnect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    delete?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    connect?: InAppMessageWhereUniqueInput | InAppMessageWhereUniqueInput[]
    update?: InAppMessageUpdateWithWhereUniqueWithoutMarketingTemplateInput | InAppMessageUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: InAppMessageUpdateManyWithWhereWithoutMarketingTemplateInput | InAppMessageUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
  }

  export type PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput> | PromotionBannerCreateWithoutMarketingTemplateInput[] | PromotionBannerUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PromotionBannerCreateOrConnectWithoutMarketingTemplateInput | PromotionBannerCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: PromotionBannerUpsertWithWhereUniqueWithoutMarketingTemplateInput | PromotionBannerUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: PromotionBannerCreateManyMarketingTemplateInputEnvelope
    set?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    disconnect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    delete?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    connect?: PromotionBannerWhereUniqueInput | PromotionBannerWhereUniqueInput[]
    update?: PromotionBannerUpdateWithWhereUniqueWithoutMarketingTemplateInput | PromotionBannerUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: PromotionBannerUpdateManyWithWhereWithoutMarketingTemplateInput | PromotionBannerUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
  }

  export type PushNotificationUncheckedUpdateManyWithoutMarketingTemplateNestedInput = {
    create?: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput> | PushNotificationCreateWithoutMarketingTemplateInput[] | PushNotificationUncheckedCreateWithoutMarketingTemplateInput[]
    connectOrCreate?: PushNotificationCreateOrConnectWithoutMarketingTemplateInput | PushNotificationCreateOrConnectWithoutMarketingTemplateInput[]
    upsert?: PushNotificationUpsertWithWhereUniqueWithoutMarketingTemplateInput | PushNotificationUpsertWithWhereUniqueWithoutMarketingTemplateInput[]
    createMany?: PushNotificationCreateManyMarketingTemplateInputEnvelope
    set?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    disconnect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    delete?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    connect?: PushNotificationWhereUniqueInput | PushNotificationWhereUniqueInput[]
    update?: PushNotificationUpdateWithWhereUniqueWithoutMarketingTemplateInput | PushNotificationUpdateWithWhereUniqueWithoutMarketingTemplateInput[]
    updateMany?: PushNotificationUpdateManyWithWhereWithoutMarketingTemplateInput | PushNotificationUpdateManyWithWhereWithoutMarketingTemplateInput[]
    deleteMany?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutPushNotificationsInput = {
    create?: XOR<OrganizationCreateWithoutPushNotificationsInput, OrganizationUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPushNotificationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CustomerSegmentCreateNestedOneWithoutPushNotificationsInput = {
    create?: XOR<CustomerSegmentCreateWithoutPushNotificationsInput, CustomerSegmentUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutPushNotificationsInput
    connect?: CustomerSegmentWhereUniqueInput
  }

  export type MarketingTemplateCreateNestedOneWithoutPushNotificationsInput = {
    create?: XOR<MarketingTemplateCreateWithoutPushNotificationsInput, MarketingTemplateUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutPushNotificationsInput
    connect?: MarketingTemplateWhereUniqueInput
  }

  export type PushNotificationLogCreateNestedManyWithoutPushNotificationInput = {
    create?: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput> | PushNotificationLogCreateWithoutPushNotificationInput[] | PushNotificationLogUncheckedCreateWithoutPushNotificationInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutPushNotificationInput | PushNotificationLogCreateOrConnectWithoutPushNotificationInput[]
    createMany?: PushNotificationLogCreateManyPushNotificationInputEnvelope
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
  }

  export type PushNotificationLogUncheckedCreateNestedManyWithoutPushNotificationInput = {
    create?: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput> | PushNotificationLogCreateWithoutPushNotificationInput[] | PushNotificationLogUncheckedCreateWithoutPushNotificationInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutPushNotificationInput | PushNotificationLogCreateOrConnectWithoutPushNotificationInput[]
    createMany?: PushNotificationLogCreateManyPushNotificationInputEnvelope
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
  }

  export type EnumPushNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.PushNotificationStatus
  }

  export type OrganizationUpdateOneRequiredWithoutPushNotificationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutPushNotificationsInput, OrganizationUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPushNotificationsInput
    upsert?: OrganizationUpsertWithoutPushNotificationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPushNotificationsInput, OrganizationUpdateWithoutPushNotificationsInput>, OrganizationUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type CustomerSegmentUpdateOneRequiredWithoutPushNotificationsNestedInput = {
    create?: XOR<CustomerSegmentCreateWithoutPushNotificationsInput, CustomerSegmentUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: CustomerSegmentCreateOrConnectWithoutPushNotificationsInput
    upsert?: CustomerSegmentUpsertWithoutPushNotificationsInput
    connect?: CustomerSegmentWhereUniqueInput
    update?: XOR<XOR<CustomerSegmentUpdateToOneWithWhereWithoutPushNotificationsInput, CustomerSegmentUpdateWithoutPushNotificationsInput>, CustomerSegmentUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type MarketingTemplateUpdateOneWithoutPushNotificationsNestedInput = {
    create?: XOR<MarketingTemplateCreateWithoutPushNotificationsInput, MarketingTemplateUncheckedCreateWithoutPushNotificationsInput>
    connectOrCreate?: MarketingTemplateCreateOrConnectWithoutPushNotificationsInput
    upsert?: MarketingTemplateUpsertWithoutPushNotificationsInput
    disconnect?: MarketingTemplateWhereInput | boolean
    delete?: MarketingTemplateWhereInput | boolean
    connect?: MarketingTemplateWhereUniqueInput
    update?: XOR<XOR<MarketingTemplateUpdateToOneWithWhereWithoutPushNotificationsInput, MarketingTemplateUpdateWithoutPushNotificationsInput>, MarketingTemplateUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type PushNotificationLogUpdateManyWithoutPushNotificationNestedInput = {
    create?: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput> | PushNotificationLogCreateWithoutPushNotificationInput[] | PushNotificationLogUncheckedCreateWithoutPushNotificationInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutPushNotificationInput | PushNotificationLogCreateOrConnectWithoutPushNotificationInput[]
    upsert?: PushNotificationLogUpsertWithWhereUniqueWithoutPushNotificationInput | PushNotificationLogUpsertWithWhereUniqueWithoutPushNotificationInput[]
    createMany?: PushNotificationLogCreateManyPushNotificationInputEnvelope
    set?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    disconnect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    delete?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    update?: PushNotificationLogUpdateWithWhereUniqueWithoutPushNotificationInput | PushNotificationLogUpdateWithWhereUniqueWithoutPushNotificationInput[]
    updateMany?: PushNotificationLogUpdateManyWithWhereWithoutPushNotificationInput | PushNotificationLogUpdateManyWithWhereWithoutPushNotificationInput[]
    deleteMany?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
  }

  export type PushNotificationLogUncheckedUpdateManyWithoutPushNotificationNestedInput = {
    create?: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput> | PushNotificationLogCreateWithoutPushNotificationInput[] | PushNotificationLogUncheckedCreateWithoutPushNotificationInput[]
    connectOrCreate?: PushNotificationLogCreateOrConnectWithoutPushNotificationInput | PushNotificationLogCreateOrConnectWithoutPushNotificationInput[]
    upsert?: PushNotificationLogUpsertWithWhereUniqueWithoutPushNotificationInput | PushNotificationLogUpsertWithWhereUniqueWithoutPushNotificationInput[]
    createMany?: PushNotificationLogCreateManyPushNotificationInputEnvelope
    set?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    disconnect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    delete?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    connect?: PushNotificationLogWhereUniqueInput | PushNotificationLogWhereUniqueInput[]
    update?: PushNotificationLogUpdateWithWhereUniqueWithoutPushNotificationInput | PushNotificationLogUpdateWithWhereUniqueWithoutPushNotificationInput[]
    updateMany?: PushNotificationLogUpdateManyWithWhereWithoutPushNotificationInput | PushNotificationLogUpdateManyWithWhereWithoutPushNotificationInput[]
    deleteMany?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
  }

  export type PushNotificationCreateNestedOneWithoutLogsInput = {
    create?: XOR<PushNotificationCreateWithoutLogsInput, PushNotificationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: PushNotificationCreateOrConnectWithoutLogsInput
    connect?: PushNotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPushNotificationLogsInput = {
    create?: XOR<UserCreateWithoutPushNotificationLogsInput, UserUncheckedCreateWithoutPushNotificationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushNotificationLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPushDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.PushDeliveryStatus
  }

  export type PushNotificationUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<PushNotificationCreateWithoutLogsInput, PushNotificationUncheckedCreateWithoutLogsInput>
    connectOrCreate?: PushNotificationCreateOrConnectWithoutLogsInput
    upsert?: PushNotificationUpsertWithoutLogsInput
    connect?: PushNotificationWhereUniqueInput
    update?: XOR<XOR<PushNotificationUpdateToOneWithWhereWithoutLogsInput, PushNotificationUpdateWithoutLogsInput>, PushNotificationUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneRequiredWithoutPushNotificationLogsNestedInput = {
    create?: XOR<UserCreateWithoutPushNotificationLogsInput, UserUncheckedCreateWithoutPushNotificationLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushNotificationLogsInput
    upsert?: UserUpsertWithoutPushNotificationLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushNotificationLogsInput, UserUpdateWithoutPushNotificationLogsInput>, UserUncheckedUpdateWithoutPushNotificationLogsInput>
  }

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput
    upsert?: UserUpsertWithoutPushSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionsInput, UserUpdateWithoutPushSubscriptionsInput>, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type OrganizationCreateNestedOneWithoutPaymentConfigsInput = {
    create?: XOR<OrganizationCreateWithoutPaymentConfigsInput, OrganizationUncheckedCreateWithoutPaymentConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPaymentConfigsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentConfigChangesInput = {
    create?: XOR<UserCreateWithoutPaymentConfigChangesInput, UserUncheckedCreateWithoutPaymentConfigChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentConfigChangesInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutPaymentConfigsNestedInput = {
    create?: XOR<OrganizationCreateWithoutPaymentConfigsInput, OrganizationUncheckedCreateWithoutPaymentConfigsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutPaymentConfigsInput
    upsert?: OrganizationUpsertWithoutPaymentConfigsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutPaymentConfigsInput, OrganizationUpdateWithoutPaymentConfigsInput>, OrganizationUncheckedUpdateWithoutPaymentConfigsInput>
  }

  export type UserUpdateOneWithoutPaymentConfigChangesNestedInput = {
    create?: XOR<UserCreateWithoutPaymentConfigChangesInput, UserUncheckedCreateWithoutPaymentConfigChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentConfigChangesInput
    upsert?: UserUpsertWithoutPaymentConfigChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentConfigChangesInput, UserUpdateWithoutPaymentConfigChangesInput>, UserUncheckedUpdateWithoutPaymentConfigChangesInput>
  }

  export type SegmentIncentiveCreateNestedOneWithoutGrantsInput = {
    create?: XOR<SegmentIncentiveCreateWithoutGrantsInput, SegmentIncentiveUncheckedCreateWithoutGrantsInput>
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutGrantsInput
    connect?: SegmentIncentiveWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIncentiveGrantsInput = {
    create?: XOR<UserCreateWithoutIncentiveGrantsInput, UserUncheckedCreateWithoutIncentiveGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentiveGrantsInput
    connect?: UserWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutIncentiveGrantsInput = {
    create?: XOR<CouponCreateWithoutIncentiveGrantsInput, CouponUncheckedCreateWithoutIncentiveGrantsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutIncentiveGrantsInput
    connect?: CouponWhereUniqueInput
  }

  export type WalletTransactionCreateNestedOneWithoutIncentiveGrantInput = {
    create?: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutIncentiveGrantInput
    connect?: WalletTransactionWhereUniqueInput
  }

  export type WalletTransactionUncheckedCreateNestedOneWithoutIncentiveGrantInput = {
    create?: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutIncentiveGrantInput
    connect?: WalletTransactionWhereUniqueInput
  }

  export type SegmentIncentiveUpdateOneRequiredWithoutGrantsNestedInput = {
    create?: XOR<SegmentIncentiveCreateWithoutGrantsInput, SegmentIncentiveUncheckedCreateWithoutGrantsInput>
    connectOrCreate?: SegmentIncentiveCreateOrConnectWithoutGrantsInput
    upsert?: SegmentIncentiveUpsertWithoutGrantsInput
    connect?: SegmentIncentiveWhereUniqueInput
    update?: XOR<XOR<SegmentIncentiveUpdateToOneWithWhereWithoutGrantsInput, SegmentIncentiveUpdateWithoutGrantsInput>, SegmentIncentiveUncheckedUpdateWithoutGrantsInput>
  }

  export type UserUpdateOneRequiredWithoutIncentiveGrantsNestedInput = {
    create?: XOR<UserCreateWithoutIncentiveGrantsInput, UserUncheckedCreateWithoutIncentiveGrantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentiveGrantsInput
    upsert?: UserUpsertWithoutIncentiveGrantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncentiveGrantsInput, UserUpdateWithoutIncentiveGrantsInput>, UserUncheckedUpdateWithoutIncentiveGrantsInput>
  }

  export type CouponUpdateOneWithoutIncentiveGrantsNestedInput = {
    create?: XOR<CouponCreateWithoutIncentiveGrantsInput, CouponUncheckedCreateWithoutIncentiveGrantsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutIncentiveGrantsInput
    upsert?: CouponUpsertWithoutIncentiveGrantsInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutIncentiveGrantsInput, CouponUpdateWithoutIncentiveGrantsInput>, CouponUncheckedUpdateWithoutIncentiveGrantsInput>
  }

  export type WalletTransactionUpdateOneWithoutIncentiveGrantNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutIncentiveGrantInput
    upsert?: WalletTransactionUpsertWithoutIncentiveGrantInput
    disconnect?: WalletTransactionWhereInput | boolean
    delete?: WalletTransactionWhereInput | boolean
    connect?: WalletTransactionWhereUniqueInput
    update?: XOR<XOR<WalletTransactionUpdateToOneWithWhereWithoutIncentiveGrantInput, WalletTransactionUpdateWithoutIncentiveGrantInput>, WalletTransactionUncheckedUpdateWithoutIncentiveGrantInput>
  }

  export type WalletTransactionUncheckedUpdateOneWithoutIncentiveGrantNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutIncentiveGrantInput
    upsert?: WalletTransactionUpsertWithoutIncentiveGrantInput
    disconnect?: WalletTransactionWhereInput | boolean
    delete?: WalletTransactionWhereInput | boolean
    connect?: WalletTransactionWhereUniqueInput
    update?: XOR<XOR<WalletTransactionUpdateToOneWithWhereWithoutIncentiveGrantInput, WalletTransactionUpdateWithoutIncentiveGrantInput>, WalletTransactionUncheckedUpdateWithoutIncentiveGrantInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSubsidyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubsidyType | EnumSubsidyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubsidyTypeFilter<$PrismaModel> | $Enums.SubsidyType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSubsidyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubsidyType | EnumSubsidyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubsidyType[] | ListEnumSubsidyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSubsidyTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubsidyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubsidyTypeFilter<$PrismaModel>
    _max?: NestedEnumSubsidyTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumWalletTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTransactionTypeFilter<$PrismaModel> | $Enums.WalletTransactionType
  }

  export type NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletTransactionType | EnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletTransactionType[] | ListEnumWalletTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.WalletTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumWalletTransactionTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumCouponTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeFilter<$PrismaModel> | $Enums.CouponType
  }

  export type NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponType | EnumCouponTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponType[] | ListEnumCouponTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponTypeWithAggregatesFilter<$PrismaModel> | $Enums.CouponType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponTypeFilter<$PrismaModel>
    _max?: NestedEnumCouponTypeFilter<$PrismaModel>
  }

  export type NestedEnumMetadataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataType | EnumMetadataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataTypeFilter<$PrismaModel> | $Enums.MetadataType
  }

  export type NestedEnumMetadataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataType | EnumMetadataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataType[] | ListEnumMetadataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataTypeWithAggregatesFilter<$PrismaModel> | $Enums.MetadataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetadataTypeFilter<$PrismaModel>
    _max?: NestedEnumMetadataTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMarketingTemplateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateType | EnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel> | $Enums.MarketingTemplateType
  }

  export type NestedEnumMarketingTemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateStatus | EnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel> | $Enums.MarketingTemplateStatus
  }

  export type NestedEnumMarketingTemplateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateType | EnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateType[] | ListEnumMarketingTemplateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateTypeWithAggregatesFilter<$PrismaModel> | $Enums.MarketingTemplateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel>
    _max?: NestedEnumMarketingTemplateTypeFilter<$PrismaModel>
  }

  export type NestedEnumMarketingTemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MarketingTemplateStatus | EnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MarketingTemplateStatus[] | ListEnumMarketingTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMarketingTemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.MarketingTemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumMarketingTemplateStatusFilter<$PrismaModel>
  }

  export type NestedEnumPushNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PushNotificationStatus | EnumPushNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushNotificationStatusFilter<$PrismaModel> | $Enums.PushNotificationStatus
  }

  export type NestedEnumPushNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PushNotificationStatus | EnumPushNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushNotificationStatus[] | ListEnumPushNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.PushNotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPushNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumPushNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPushDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PushDeliveryStatus | EnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushDeliveryStatusFilter<$PrismaModel> | $Enums.PushDeliveryStatus
  }

  export type NestedEnumPushDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PushDeliveryStatus | EnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PushDeliveryStatus[] | ListEnumPushDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPushDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.PushDeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPushDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumPushDeliveryStatusFilter<$PrismaModel>
  }

  export type LocationCreateWithoutOrganizationInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    users?: UserLocationCreateNestedManyWithoutLocationInput
    coupons?: CouponCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    users?: UserLocationUncheckedCreateNestedManyWithoutLocationInput
    coupons?: CouponUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationCreateManyOrganizationInputEnvelope = {
    data: LocationCreateManyOrganizationInput | LocationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerSegmentCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentCreateOrConnectWithoutOrganizationInput = {
    where: CustomerSegmentWhereUniqueInput
    create: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomerSegmentCreateManyOrganizationInputEnvelope = {
    data: CustomerSegmentCreateManyOrganizationInput | CustomerSegmentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type InAppMessageCreateWithoutOrganizationInput = {
    id?: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    segment: CustomerSegmentCreateNestedOneWithoutInAppMessagesInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutInAppMessagesInput
    readBy?: InAppMessageReadCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageUncheckedCreateWithoutOrganizationInput = {
    id?: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    readBy?: InAppMessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageCreateOrConnectWithoutOrganizationInput = {
    where: InAppMessageWhereUniqueInput
    create: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput>
  }

  export type InAppMessageCreateManyOrganizationInputEnvelope = {
    data: InAppMessageCreateManyOrganizationInput | InAppMessageCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MarketingWorkflowCreateWithoutOrganizationInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    segment: CustomerSegmentCreateNestedOneWithoutWorkflowsInput
    executionLogs?: WorkflowExecutionLogCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowUncheckedCreateWithoutOrganizationInput = {
    id?: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    executionLogs?: WorkflowExecutionLogUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowCreateOrConnectWithoutOrganizationInput = {
    where: MarketingWorkflowWhereUniqueInput
    create: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput>
  }

  export type MarketingWorkflowCreateManyOrganizationInputEnvelope = {
    data: MarketingWorkflowCreateManyOrganizationInput | MarketingWorkflowCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type SegmentIncentiveCreateWithoutOrganizationInput = {
    id?: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    segment: CustomerSegmentCreateNestedOneWithoutSegmentIncentivesInput
    coupon?: CouponCreateNestedOneWithoutSegmentIncentivesInput
    grants?: IncentiveGrantCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveUncheckedCreateWithoutOrganizationInput = {
    id?: string
    segmentId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grants?: IncentiveGrantUncheckedCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveCreateOrConnectWithoutOrganizationInput = {
    where: SegmentIncentiveWhereUniqueInput
    create: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput>
  }

  export type SegmentIncentiveCreateManyOrganizationInputEnvelope = {
    data: SegmentIncentiveCreateManyOrganizationInput | SegmentIncentiveCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type MarketingTemplateCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateCreateOrConnectWithoutOrganizationInput = {
    where: MarketingTemplateWhereUniqueInput
    create: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type MarketingTemplateCreateManyOrganizationInputEnvelope = {
    data: MarketingTemplateCreateManyOrganizationInput | MarketingTemplateCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutOrganizationInput = {
    id?: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    segment: CustomerSegmentCreateNestedOneWithoutPushNotificationsInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPushNotificationsInput
    logs?: PushNotificationLogCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    segmentId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: PushNotificationLogUncheckedCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationCreateOrConnectWithoutOrganizationInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type PushNotificationCreateManyOrganizationInputEnvelope = {
    data: PushNotificationCreateManyOrganizationInput | PushNotificationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type PaymentProviderConfigCreateWithoutOrganizationInput = {
    id?: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutPaymentConfigChangesInput
  }

  export type PaymentProviderConfigUncheckedCreateWithoutOrganizationInput = {
    id?: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type PaymentProviderConfigCreateOrConnectWithoutOrganizationInput = {
    where: PaymentProviderConfigWhereUniqueInput
    create: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput>
  }

  export type PaymentProviderConfigCreateManyOrganizationInputEnvelope = {
    data: PaymentProviderConfigCreateManyOrganizationInput | PaymentProviderConfigCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<LocationCreateWithoutOrganizationInput, LocationUncheckedCreateWithoutOrganizationInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutOrganizationInput, LocationUncheckedUpdateWithoutOrganizationInput>
  }

  export type LocationUpdateManyWithWhereWithoutOrganizationInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    organizationId?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    email?: StringNullableFilter<"Location"> | string | null
    openingHours?: JsonNullableFilter<"Location">
    workingDays?: IntNullableListFilter<"Location">
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    image?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    marketingEmailConsent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CustomerSegmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: CustomerSegmentWhereUniqueInput
    update: XOR<CustomerSegmentUpdateWithoutOrganizationInput, CustomerSegmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<CustomerSegmentCreateWithoutOrganizationInput, CustomerSegmentUncheckedCreateWithoutOrganizationInput>
  }

  export type CustomerSegmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: CustomerSegmentWhereUniqueInput
    data: XOR<CustomerSegmentUpdateWithoutOrganizationInput, CustomerSegmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type CustomerSegmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: CustomerSegmentScalarWhereInput
    data: XOR<CustomerSegmentUpdateManyMutationInput, CustomerSegmentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type CustomerSegmentScalarWhereInput = {
    AND?: CustomerSegmentScalarWhereInput | CustomerSegmentScalarWhereInput[]
    OR?: CustomerSegmentScalarWhereInput[]
    NOT?: CustomerSegmentScalarWhereInput | CustomerSegmentScalarWhereInput[]
    id?: StringFilter<"CustomerSegment"> | string
    organizationId?: StringFilter<"CustomerSegment"> | string
    name?: StringFilter<"CustomerSegment"> | string
    description?: StringNullableFilter<"CustomerSegment"> | string | null
    rulesCombination?: StringFilter<"CustomerSegment"> | string
    rules?: JsonFilter<"CustomerSegment">
    createdAt?: DateTimeFilter<"CustomerSegment"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerSegment"> | Date | string
  }

  export type InAppMessageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: InAppMessageWhereUniqueInput
    update: XOR<InAppMessageUpdateWithoutOrganizationInput, InAppMessageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<InAppMessageCreateWithoutOrganizationInput, InAppMessageUncheckedCreateWithoutOrganizationInput>
  }

  export type InAppMessageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: InAppMessageWhereUniqueInput
    data: XOR<InAppMessageUpdateWithoutOrganizationInput, InAppMessageUncheckedUpdateWithoutOrganizationInput>
  }

  export type InAppMessageUpdateManyWithWhereWithoutOrganizationInput = {
    where: InAppMessageScalarWhereInput
    data: XOR<InAppMessageUpdateManyMutationInput, InAppMessageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type InAppMessageScalarWhereInput = {
    AND?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
    OR?: InAppMessageScalarWhereInput[]
    NOT?: InAppMessageScalarWhereInput | InAppMessageScalarWhereInput[]
    id?: StringFilter<"InAppMessage"> | string
    organizationId?: StringFilter<"InAppMessage"> | string
    segmentId?: StringFilter<"InAppMessage"> | string
    title?: StringNullableFilter<"InAppMessage"> | string | null
    body?: StringFilter<"InAppMessage"> | string
    linkUrl?: StringNullableFilter<"InAppMessage"> | string | null
    displayPlace?: StringFilter<"InAppMessage"> | string
    displayType?: StringFilter<"InAppMessage"> | string
    slotId?: StringNullableFilter<"InAppMessage"> | string | null
    startDate?: DateTimeFilter<"InAppMessage"> | Date | string
    endDate?: DateTimeNullableFilter<"InAppMessage"> | Date | string | null
    isActive?: BoolFilter<"InAppMessage"> | boolean
    marketingTemplateId?: StringNullableFilter<"InAppMessage"> | string | null
    templateSnapshot?: JsonNullableFilter<"InAppMessage">
    createdAt?: DateTimeFilter<"InAppMessage"> | Date | string
    updatedAt?: DateTimeFilter<"InAppMessage"> | Date | string
  }

  export type MarketingWorkflowUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MarketingWorkflowWhereUniqueInput
    update: XOR<MarketingWorkflowUpdateWithoutOrganizationInput, MarketingWorkflowUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MarketingWorkflowCreateWithoutOrganizationInput, MarketingWorkflowUncheckedCreateWithoutOrganizationInput>
  }

  export type MarketingWorkflowUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MarketingWorkflowWhereUniqueInput
    data: XOR<MarketingWorkflowUpdateWithoutOrganizationInput, MarketingWorkflowUncheckedUpdateWithoutOrganizationInput>
  }

  export type MarketingWorkflowUpdateManyWithWhereWithoutOrganizationInput = {
    where: MarketingWorkflowScalarWhereInput
    data: XOR<MarketingWorkflowUpdateManyMutationInput, MarketingWorkflowUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MarketingWorkflowScalarWhereInput = {
    AND?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
    OR?: MarketingWorkflowScalarWhereInput[]
    NOT?: MarketingWorkflowScalarWhereInput | MarketingWorkflowScalarWhereInput[]
    id?: StringFilter<"MarketingWorkflow"> | string
    organizationId?: StringFilter<"MarketingWorkflow"> | string
    segmentId?: StringFilter<"MarketingWorkflow"> | string
    name?: StringFilter<"MarketingWorkflow"> | string
    triggerType?: StringFilter<"MarketingWorkflow"> | string
    triggerConfig?: JsonFilter<"MarketingWorkflow">
    actionType?: StringFilter<"MarketingWorkflow"> | string
    actionConfig?: JsonFilter<"MarketingWorkflow">
    isActive?: BoolFilter<"MarketingWorkflow"> | boolean
    createdAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingWorkflow"> | Date | string
  }

  export type SegmentIncentiveUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: SegmentIncentiveWhereUniqueInput
    update: XOR<SegmentIncentiveUpdateWithoutOrganizationInput, SegmentIncentiveUncheckedUpdateWithoutOrganizationInput>
    create: XOR<SegmentIncentiveCreateWithoutOrganizationInput, SegmentIncentiveUncheckedCreateWithoutOrganizationInput>
  }

  export type SegmentIncentiveUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: SegmentIncentiveWhereUniqueInput
    data: XOR<SegmentIncentiveUpdateWithoutOrganizationInput, SegmentIncentiveUncheckedUpdateWithoutOrganizationInput>
  }

  export type SegmentIncentiveUpdateManyWithWhereWithoutOrganizationInput = {
    where: SegmentIncentiveScalarWhereInput
    data: XOR<SegmentIncentiveUpdateManyMutationInput, SegmentIncentiveUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type SegmentIncentiveScalarWhereInput = {
    AND?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
    OR?: SegmentIncentiveScalarWhereInput[]
    NOT?: SegmentIncentiveScalarWhereInput | SegmentIncentiveScalarWhereInput[]
    id?: StringFilter<"SegmentIncentive"> | string
    organizationId?: StringFilter<"SegmentIncentive"> | string
    segmentId?: StringFilter<"SegmentIncentive"> | string
    name?: StringNullableFilter<"SegmentIncentive"> | string | null
    incentiveType?: StringFilter<"SegmentIncentive"> | string
    couponId?: StringNullableFilter<"SegmentIncentive"> | string | null
    personaliseCoupon?: BoolFilter<"SegmentIncentive"> | boolean
    walletAmount?: DecimalNullableFilter<"SegmentIncentive"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFilter<"SegmentIncentive"> | Date | string
    endDate?: DateTimeNullableFilter<"SegmentIncentive"> | Date | string | null
    maxGrantsPerUser?: IntFilter<"SegmentIncentive"> | number
    displayChannel?: StringFilter<"SegmentIncentive"> | string
    isActive?: BoolFilter<"SegmentIncentive"> | boolean
    createdAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
    updatedAt?: DateTimeFilter<"SegmentIncentive"> | Date | string
  }

  export type MarketingTemplateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MarketingTemplateWhereUniqueInput
    update: XOR<MarketingTemplateUpdateWithoutOrganizationInput, MarketingTemplateUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MarketingTemplateCreateWithoutOrganizationInput, MarketingTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type MarketingTemplateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MarketingTemplateWhereUniqueInput
    data: XOR<MarketingTemplateUpdateWithoutOrganizationInput, MarketingTemplateUncheckedUpdateWithoutOrganizationInput>
  }

  export type MarketingTemplateUpdateManyWithWhereWithoutOrganizationInput = {
    where: MarketingTemplateScalarWhereInput
    data: XOR<MarketingTemplateUpdateManyMutationInput, MarketingTemplateUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MarketingTemplateScalarWhereInput = {
    AND?: MarketingTemplateScalarWhereInput | MarketingTemplateScalarWhereInput[]
    OR?: MarketingTemplateScalarWhereInput[]
    NOT?: MarketingTemplateScalarWhereInput | MarketingTemplateScalarWhereInput[]
    id?: StringFilter<"MarketingTemplate"> | string
    organizationId?: StringNullableFilter<"MarketingTemplate"> | string | null
    name?: StringFilter<"MarketingTemplate"> | string
    type?: EnumMarketingTemplateTypeFilter<"MarketingTemplate"> | $Enums.MarketingTemplateType
    content?: JsonFilter<"MarketingTemplate">
    status?: EnumMarketingTemplateStatusFilter<"MarketingTemplate"> | $Enums.MarketingTemplateStatus
    isStarter?: BoolFilter<"MarketingTemplate"> | boolean
    isFavorite?: BoolFilter<"MarketingTemplate"> | boolean
    thumbnailUrl?: StringNullableFilter<"MarketingTemplate"> | string | null
    createdAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTemplate"> | Date | string
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutOrganizationInput, PushNotificationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PushNotificationCreateWithoutOrganizationInput, PushNotificationUncheckedCreateWithoutOrganizationInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutOrganizationInput, PushNotificationUncheckedUpdateWithoutOrganizationInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutOrganizationInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PushNotificationScalarWhereInput = {
    AND?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
    OR?: PushNotificationScalarWhereInput[]
    NOT?: PushNotificationScalarWhereInput | PushNotificationScalarWhereInput[]
    id?: StringFilter<"PushNotification"> | string
    organizationId?: StringFilter<"PushNotification"> | string
    segmentId?: StringFilter<"PushNotification"> | string
    marketingTemplateId?: StringNullableFilter<"PushNotification"> | string | null
    templateSnapshot?: JsonNullableFilter<"PushNotification">
    pushTitle?: StringFilter<"PushNotification"> | string
    pushBody?: StringFilter<"PushNotification"> | string
    deepLink?: StringNullableFilter<"PushNotification"> | string | null
    status?: EnumPushNotificationStatusFilter<"PushNotification"> | $Enums.PushNotificationStatus
    scheduledAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"PushNotification"> | Date | string | null
    totalRecipients?: IntFilter<"PushNotification"> | number
    createdAt?: DateTimeFilter<"PushNotification"> | Date | string
    updatedAt?: DateTimeFilter<"PushNotification"> | Date | string
  }

  export type PaymentProviderConfigUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: PaymentProviderConfigWhereUniqueInput
    update: XOR<PaymentProviderConfigUpdateWithoutOrganizationInput, PaymentProviderConfigUncheckedUpdateWithoutOrganizationInput>
    create: XOR<PaymentProviderConfigCreateWithoutOrganizationInput, PaymentProviderConfigUncheckedCreateWithoutOrganizationInput>
  }

  export type PaymentProviderConfigUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: PaymentProviderConfigWhereUniqueInput
    data: XOR<PaymentProviderConfigUpdateWithoutOrganizationInput, PaymentProviderConfigUncheckedUpdateWithoutOrganizationInput>
  }

  export type PaymentProviderConfigUpdateManyWithWhereWithoutOrganizationInput = {
    where: PaymentProviderConfigScalarWhereInput
    data: XOR<PaymentProviderConfigUpdateManyMutationInput, PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type PaymentProviderConfigScalarWhereInput = {
    AND?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
    OR?: PaymentProviderConfigScalarWhereInput[]
    NOT?: PaymentProviderConfigScalarWhereInput | PaymentProviderConfigScalarWhereInput[]
    id?: StringFilter<"PaymentProviderConfig"> | string
    organizationId?: StringFilter<"PaymentProviderConfig"> | string
    provider?: StringFilter<"PaymentProviderConfig"> | string
    isEnabled?: BoolFilter<"PaymentProviderConfig"> | boolean
    configJson?: StringFilter<"PaymentProviderConfig"> | string
    updatedAt?: DateTimeFilter<"PaymentProviderConfig"> | Date | string
    updatedById?: StringNullableFilter<"PaymentProviderConfig"> | string | null
  }

  export type CompanyEmployeeCreateWithoutCompanyInput = {
    id?: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompanyEmployeesInput
  }

  export type CompanyEmployeeUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type CompanyEmployeeCreateOrConnectWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    create: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyEmployeeCreateManyCompanyInputEnvelope = {
    data: CompanyEmployeeCreateManyCompanyInput | CompanyEmployeeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutEmployerCompanyInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutEmployerCompanyInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutEmployerCompanyInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput>
  }

  export type OrderCreateManyEmployerCompanyInputEnvelope = {
    data: OrderCreateManyEmployerCompanyInput | OrderCreateManyEmployerCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyInvoiceCreateWithoutCompanyInput = {
    id?: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CompanyInvoiceItemCreateNestedManyWithoutCompanyInvoiceInput
  }

  export type CompanyInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CompanyInvoiceItemUncheckedCreateNestedManyWithoutCompanyInvoiceInput
  }

  export type CompanyInvoiceCreateOrConnectWithoutCompanyInput = {
    where: CompanyInvoiceWhereUniqueInput
    create: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvoiceCreateManyCompanyInputEnvelope = {
    data: CompanyInvoiceCreateManyCompanyInput | CompanyInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyEmployeeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    update: XOR<CompanyEmployeeUpdateWithoutCompanyInput, CompanyEmployeeUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyEmployeeCreateWithoutCompanyInput, CompanyEmployeeUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyEmployeeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyEmployeeWhereUniqueInput
    data: XOR<CompanyEmployeeUpdateWithoutCompanyInput, CompanyEmployeeUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyEmployeeUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyEmployeeScalarWhereInput
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyEmployeeScalarWhereInput = {
    AND?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
    OR?: CompanyEmployeeScalarWhereInput[]
    NOT?: CompanyEmployeeScalarWhereInput | CompanyEmployeeScalarWhereInput[]
    id?: StringFilter<"CompanyEmployee"> | string
    companyId?: StringFilter<"CompanyEmployee"> | string
    userId?: StringFilter<"CompanyEmployee"> | string
    employeeNumber?: StringNullableFilter<"CompanyEmployee"> | string | null
    department?: StringNullableFilter<"CompanyEmployee"> | string | null
    isActive?: BoolFilter<"CompanyEmployee"> | boolean
    validFrom?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"CompanyEmployee"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyEmployee"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutEmployerCompanyInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutEmployerCompanyInput, OrderUncheckedUpdateWithoutEmployerCompanyInput>
    create: XOR<OrderCreateWithoutEmployerCompanyInput, OrderUncheckedCreateWithoutEmployerCompanyInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutEmployerCompanyInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutEmployerCompanyInput, OrderUncheckedUpdateWithoutEmployerCompanyInput>
  }

  export type OrderUpdateManyWithWhereWithoutEmployerCompanyInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutEmployerCompanyInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    locationId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFilter<"Order"> | $Enums.PaymentStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentIntentId?: StringNullableFilter<"Order"> | string | null
    pickupCode?: StringFilter<"Order"> | string
    pickupDate?: DateTimeFilter<"Order"> | Date | string
    pickupTimeSlot?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    pickedUpAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    couponCode?: StringNullableFilter<"Order"> | string | null
    discountAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    finalAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: DecimalNullableFilter<"Order"> | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: StringNullableFilter<"Order"> | string | null
  }

  export type CompanyInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvoiceWhereUniqueInput
    update: XOR<CompanyInvoiceUpdateWithoutCompanyInput, CompanyInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyInvoiceCreateWithoutCompanyInput, CompanyInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyInvoiceWhereUniqueInput
    data: XOR<CompanyInvoiceUpdateWithoutCompanyInput, CompanyInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyInvoiceScalarWhereInput
    data: XOR<CompanyInvoiceUpdateManyMutationInput, CompanyInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyInvoiceScalarWhereInput = {
    AND?: CompanyInvoiceScalarWhereInput | CompanyInvoiceScalarWhereInput[]
    OR?: CompanyInvoiceScalarWhereInput[]
    NOT?: CompanyInvoiceScalarWhereInput | CompanyInvoiceScalarWhereInput[]
    id?: StringFilter<"CompanyInvoice"> | string
    companyId?: StringFilter<"CompanyInvoice"> | string
    year?: IntFilter<"CompanyInvoice"> | number
    month?: IntFilter<"CompanyInvoice"> | number
    status?: StringFilter<"CompanyInvoice"> | string
    totalAmount?: DecimalFilter<"CompanyInvoice"> | Decimal | DecimalJsLike | number | string
    invoicedAt?: DateTimeNullableFilter<"CompanyInvoice"> | Date | string | null
    createdAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyInvoice"> | Date | string
  }

  export type CompanyCreateWithoutInvoicesInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    orders?: OrderCreateNestedManyWithoutEmployerCompanyInput
  }

  export type CompanyUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    orders?: OrderUncheckedCreateNestedManyWithoutEmployerCompanyInput
  }

  export type CompanyCreateOrConnectWithoutInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
  }

  export type CompanyInvoiceItemCreateWithoutCompanyInvoiceInput = {
    id?: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput = {
    id?: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemCreateOrConnectWithoutCompanyInvoiceInput = {
    where: CompanyInvoiceItemWhereUniqueInput
    create: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput>
  }

  export type CompanyInvoiceItemCreateManyCompanyInvoiceInputEnvelope = {
    data: CompanyInvoiceItemCreateManyCompanyInvoiceInput | CompanyInvoiceItemCreateManyCompanyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutInvoicesInput = {
    update: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
    create: XOR<CompanyCreateWithoutInvoicesInput, CompanyUncheckedCreateWithoutInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutInvoicesInput, CompanyUncheckedUpdateWithoutInvoicesInput>
  }

  export type CompanyUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    orders?: OrderUpdateManyWithoutEmployerCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    orders?: OrderUncheckedUpdateManyWithoutEmployerCompanyNestedInput
  }

  export type CompanyInvoiceItemUpsertWithWhereUniqueWithoutCompanyInvoiceInput = {
    where: CompanyInvoiceItemWhereUniqueInput
    update: XOR<CompanyInvoiceItemUpdateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedUpdateWithoutCompanyInvoiceInput>
    create: XOR<CompanyInvoiceItemCreateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedCreateWithoutCompanyInvoiceInput>
  }

  export type CompanyInvoiceItemUpdateWithWhereUniqueWithoutCompanyInvoiceInput = {
    where: CompanyInvoiceItemWhereUniqueInput
    data: XOR<CompanyInvoiceItemUpdateWithoutCompanyInvoiceInput, CompanyInvoiceItemUncheckedUpdateWithoutCompanyInvoiceInput>
  }

  export type CompanyInvoiceItemUpdateManyWithWhereWithoutCompanyInvoiceInput = {
    where: CompanyInvoiceItemScalarWhereInput
    data: XOR<CompanyInvoiceItemUpdateManyMutationInput, CompanyInvoiceItemUncheckedUpdateManyWithoutCompanyInvoiceInput>
  }

  export type CompanyInvoiceItemScalarWhereInput = {
    AND?: CompanyInvoiceItemScalarWhereInput | CompanyInvoiceItemScalarWhereInput[]
    OR?: CompanyInvoiceItemScalarWhereInput[]
    NOT?: CompanyInvoiceItemScalarWhereInput | CompanyInvoiceItemScalarWhereInput[]
    id?: StringFilter<"CompanyInvoiceItem"> | string
    companyInvoiceId?: StringFilter<"CompanyInvoiceItem"> | string
    orderId?: StringFilter<"CompanyInvoiceItem"> | string
    orderNumber?: StringFilter<"CompanyInvoiceItem"> | string
    orderDate?: DateTimeFilter<"CompanyInvoiceItem"> | Date | string
    employeeName?: StringFilter<"CompanyInvoiceItem"> | string
    amount?: DecimalFilter<"CompanyInvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceCreateWithoutItemsInput = {
    id?: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutInvoicesInput
  }

  export type CompanyInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    companyId: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyInvoiceCreateOrConnectWithoutItemsInput = {
    where: CompanyInvoiceWhereUniqueInput
    create: XOR<CompanyInvoiceCreateWithoutItemsInput, CompanyInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type CompanyInvoiceUpsertWithoutItemsInput = {
    update: XOR<CompanyInvoiceUpdateWithoutItemsInput, CompanyInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<CompanyInvoiceCreateWithoutItemsInput, CompanyInvoiceUncheckedCreateWithoutItemsInput>
    where?: CompanyInvoiceWhereInput
  }

  export type CompanyInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: CompanyInvoiceWhereInput
    data: XOR<CompanyInvoiceUpdateWithoutItemsInput, CompanyInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type CompanyInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutEmployeesInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutEmployerCompanyInput
    invoices?: CompanyInvoiceCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutEmployerCompanyInput
    invoices?: CompanyInvoiceUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEmployeesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutCompanyEmployeesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCompanyEmployeesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCompanyEmployeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyEmployeesInput, UserUncheckedCreateWithoutCompanyEmployeesInput>
  }

  export type CompanyUpsertWithoutEmployeesInput = {
    update: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
    create: XOR<CompanyCreateWithoutEmployeesInput, CompanyUncheckedCreateWithoutEmployeesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEmployeesInput, CompanyUncheckedUpdateWithoutEmployeesInput>
  }

  export type CompanyUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutEmployerCompanyNestedInput
    invoices?: CompanyInvoiceUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutEmployerCompanyNestedInput
    invoices?: CompanyInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserUpsertWithoutCompanyEmployeesInput = {
    update: XOR<UserUpdateWithoutCompanyEmployeesInput, UserUncheckedUpdateWithoutCompanyEmployeesInput>
    create: XOR<UserCreateWithoutCompanyEmployeesInput, UserUncheckedCreateWithoutCompanyEmployeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompanyEmployeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompanyEmployeesInput, UserUncheckedUpdateWithoutCompanyEmployeesInput>
  }

  export type UserUpdateWithoutCompanyEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type OrganizationCreateWithoutLocationsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutLocationsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutLocationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
  }

  export type MenuCreateWithoutLocationInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemCreateNestedManyWithoutMenuInput
    promotionBanners?: MenuPromotionBannerCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutLocationInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutMenuInput
    promotionBanners?: MenuPromotionBannerUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutLocationInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput>
  }

  export type MenuCreateManyLocationInputEnvelope = {
    data: MenuCreateManyLocationInput | MenuCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutLocationInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutLocationInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutLocationInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderCreateManyLocationInputEnvelope = {
    data: OrderCreateManyLocationInput | OrderCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type UserLocationCreateWithoutLocationInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLocationsInput
  }

  export type UserLocationUncheckedCreateWithoutLocationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserLocationCreateOrConnectWithoutLocationInput = {
    where: UserLocationWhereUniqueInput
    create: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput>
  }

  export type UserLocationCreateManyLocationInputEnvelope = {
    data: UserLocationCreateManyLocationInput | UserLocationCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutLocationInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutLocationInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutLocationInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput>
  }

  export type CouponCreateManyLocationInputEnvelope = {
    data: CouponCreateManyLocationInput | CouponCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutLocationsInput = {
    update: XOR<OrganizationUpdateWithoutLocationsInput, OrganizationUncheckedUpdateWithoutLocationsInput>
    create: XOR<OrganizationCreateWithoutLocationsInput, OrganizationUncheckedCreateWithoutLocationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutLocationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutLocationsInput, OrganizationUncheckedUpdateWithoutLocationsInput>
  }

  export type OrganizationUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type MenuUpsertWithWhereUniqueWithoutLocationInput = {
    where: MenuWhereUniqueInput
    update: XOR<MenuUpdateWithoutLocationInput, MenuUncheckedUpdateWithoutLocationInput>
    create: XOR<MenuCreateWithoutLocationInput, MenuUncheckedCreateWithoutLocationInput>
  }

  export type MenuUpdateWithWhereUniqueWithoutLocationInput = {
    where: MenuWhereUniqueInput
    data: XOR<MenuUpdateWithoutLocationInput, MenuUncheckedUpdateWithoutLocationInput>
  }

  export type MenuUpdateManyWithWhereWithoutLocationInput = {
    where: MenuScalarWhereInput
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyWithoutLocationInput>
  }

  export type MenuScalarWhereInput = {
    AND?: MenuScalarWhereInput | MenuScalarWhereInput[]
    OR?: MenuScalarWhereInput[]
    NOT?: MenuScalarWhereInput | MenuScalarWhereInput[]
    id?: StringFilter<"Menu"> | string
    locationId?: StringFilter<"Menu"> | string
    weekNumber?: IntFilter<"Menu"> | number
    year?: IntFilter<"Menu"> | number
    startDate?: DateTimeFilter<"Menu"> | Date | string
    endDate?: DateTimeFilter<"Menu"> | Date | string
    isPublished?: BoolFilter<"Menu"> | boolean
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
    create: XOR<OrderCreateWithoutLocationInput, OrderUncheckedCreateWithoutLocationInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutLocationInput, OrderUncheckedUpdateWithoutLocationInput>
  }

  export type OrderUpdateManyWithWhereWithoutLocationInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserLocationUpsertWithWhereUniqueWithoutLocationInput = {
    where: UserLocationWhereUniqueInput
    update: XOR<UserLocationUpdateWithoutLocationInput, UserLocationUncheckedUpdateWithoutLocationInput>
    create: XOR<UserLocationCreateWithoutLocationInput, UserLocationUncheckedCreateWithoutLocationInput>
  }

  export type UserLocationUpdateWithWhereUniqueWithoutLocationInput = {
    where: UserLocationWhereUniqueInput
    data: XOR<UserLocationUpdateWithoutLocationInput, UserLocationUncheckedUpdateWithoutLocationInput>
  }

  export type UserLocationUpdateManyWithWhereWithoutLocationInput = {
    where: UserLocationScalarWhereInput
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyWithoutLocationInput>
  }

  export type UserLocationScalarWhereInput = {
    AND?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
    OR?: UserLocationScalarWhereInput[]
    NOT?: UserLocationScalarWhereInput | UserLocationScalarWhereInput[]
    id?: StringFilter<"UserLocation"> | string
    userId?: StringFilter<"UserLocation"> | string
    locationId?: StringFilter<"UserLocation"> | string
    createdAt?: DateTimeFilter<"UserLocation"> | Date | string
  }

  export type CouponUpsertWithWhereUniqueWithoutLocationInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutLocationInput, CouponUncheckedUpdateWithoutLocationInput>
    create: XOR<CouponCreateWithoutLocationInput, CouponUncheckedCreateWithoutLocationInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutLocationInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutLocationInput, CouponUncheckedUpdateWithoutLocationInput>
  }

  export type CouponUpdateManyWithWhereWithoutLocationInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutLocationInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    name?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    type?: EnumCouponTypeFilter<"Coupon"> | $Enums.CouponType
    discountValue?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: StringNullableFilter<"Coupon"> | string | null
    locationId?: StringNullableFilter<"Coupon"> | string | null
    startDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Coupon"> | Date | string | null
    maxUses?: IntNullableFilter<"Coupon"> | number | null
    maxUsesPerUser?: IntFilter<"Coupon"> | number
    currentUses?: IntFilter<"Coupon"> | number
    minOrderAmount?: DecimalNullableFilter<"Coupon"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Coupon"> | boolean
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserLocationCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutUsersInput
  }

  export type UserLocationUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    createdAt?: Date | string
  }

  export type UserLocationCreateOrConnectWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationCreateManyUserInputEnvelope = {
    data: UserLocationCreateManyUserInput | UserLocationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyEmployeeCreateWithoutUserInput = {
    id?: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutEmployeesInput
  }

  export type CompanyEmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type CompanyEmployeeCreateOrConnectWithoutUserInput = {
    where: CompanyEmployeeWhereUniqueInput
    create: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput>
  }

  export type CompanyEmployeeCreateManyUserInputEnvelope = {
    data: CompanyEmployeeCreateManyUserInput | CompanyEmployeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CouponRedemptionCreateWithoutUserInput = {
    id?: string
    redeemedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutRedemptionsInput
    order: OrderCreateNestedOneWithoutCouponRedemptionsInput
  }

  export type CouponRedemptionUncheckedCreateWithoutUserInput = {
    id?: string
    couponId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput>
  }

  export type CouponRedemptionCreateManyUserInputEnvelope = {
    data: CouponRedemptionCreateManyUserInput | CouponRedemptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IncentiveGrantCreateWithoutUserInput = {
    id?: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    segmentIncentive: SegmentIncentiveCreateNestedOneWithoutGrantsInput
    coupon?: CouponCreateNestedOneWithoutIncentiveGrantsInput
    walletTransaction?: WalletTransactionCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantUncheckedCreateWithoutUserInput = {
    id?: string
    segmentIncentiveId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    walletTransaction?: WalletTransactionUncheckedCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantCreateOrConnectWithoutUserInput = {
    where: IncentiveGrantWhereUniqueInput
    create: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput>
  }

  export type IncentiveGrantCreateManyUserInputEnvelope = {
    data: IncentiveGrantCreateManyUserInput | IncentiveGrantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletTransactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
    performedBy?: UserCreateNestedOneWithoutPerformedWalletActionsInput
    incentiveGrant?: IncentiveGrantCreateNestedOneWithoutWalletTransactionInput
  }

  export type WalletTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutUserInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput>
  }

  export type WalletTransactionCreateManyUserInputEnvelope = {
    data: WalletTransactionCreateManyUserInput | WalletTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WalletTransactionCreateWithoutPerformedByInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
    incentiveGrant?: IncentiveGrantCreateNestedOneWithoutWalletTransactionInput
  }

  export type WalletTransactionUncheckedCreateWithoutPerformedByInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutPerformedByInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput>
  }

  export type WalletTransactionCreateManyPerformedByInputEnvelope = {
    data: WalletTransactionCreateManyPerformedByInput | WalletTransactionCreateManyPerformedByInput[]
    skipDuplicates?: boolean
  }

  export type PushNotificationLogCreateWithoutUserInput = {
    id?: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
    pushNotification: PushNotificationCreateNestedOneWithoutLogsInput
  }

  export type PushNotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    pushNotificationId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushNotificationLogCreateOrConnectWithoutUserInput = {
    where: PushNotificationLogWhereUniqueInput
    create: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput>
  }

  export type PushNotificationLogCreateManyUserInputEnvelope = {
    data: PushNotificationLogCreateManyUserInput | PushNotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentProviderConfigCreateWithoutUpdatedByInput = {
    id?: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPaymentConfigsInput
  }

  export type PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    organizationId: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigCreateOrConnectWithoutUpdatedByInput = {
    where: PaymentProviderConfigWhereUniqueInput
    create: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput>
  }

  export type PaymentProviderConfigCreateManyUpdatedByInputEnvelope = {
    data: PaymentProviderConfigCreateManyUpdatedByInput | PaymentProviderConfigCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserLocationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    update: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
    create: XOR<UserLocationCreateWithoutUserInput, UserLocationUncheckedCreateWithoutUserInput>
  }

  export type UserLocationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLocationWhereUniqueInput
    data: XOR<UserLocationUpdateWithoutUserInput, UserLocationUncheckedUpdateWithoutUserInput>
  }

  export type UserLocationUpdateManyWithWhereWithoutUserInput = {
    where: UserLocationScalarWhereInput
    data: XOR<UserLocationUpdateManyMutationInput, UserLocationUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyEmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyEmployeeWhereUniqueInput
    update: XOR<CompanyEmployeeUpdateWithoutUserInput, CompanyEmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyEmployeeCreateWithoutUserInput, CompanyEmployeeUncheckedCreateWithoutUserInput>
  }

  export type CompanyEmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyEmployeeWhereUniqueInput
    data: XOR<CompanyEmployeeUpdateWithoutUserInput, CompanyEmployeeUncheckedUpdateWithoutUserInput>
  }

  export type CompanyEmployeeUpdateManyWithWhereWithoutUserInput = {
    where: CompanyEmployeeScalarWhereInput
    data: XOR<CompanyEmployeeUpdateManyMutationInput, CompanyEmployeeUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutUserInput, CouponRedemptionUncheckedUpdateWithoutUserInput>
    create: XOR<CouponRedemptionCreateWithoutUserInput, CouponRedemptionUncheckedCreateWithoutUserInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutUserInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutUserInput, CouponRedemptionUncheckedUpdateWithoutUserInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutUserInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutUserInput>
  }

  export type CouponRedemptionScalarWhereInput = {
    AND?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    OR?: CouponRedemptionScalarWhereInput[]
    NOT?: CouponRedemptionScalarWhereInput | CouponRedemptionScalarWhereInput[]
    id?: StringFilter<"CouponRedemption"> | string
    couponId?: StringFilter<"CouponRedemption"> | string
    userId?: StringFilter<"CouponRedemption"> | string
    orderId?: StringFilter<"CouponRedemption"> | string
    redeemedAt?: DateTimeFilter<"CouponRedemption"> | Date | string
  }

  export type IncentiveGrantUpsertWithWhereUniqueWithoutUserInput = {
    where: IncentiveGrantWhereUniqueInput
    update: XOR<IncentiveGrantUpdateWithoutUserInput, IncentiveGrantUncheckedUpdateWithoutUserInput>
    create: XOR<IncentiveGrantCreateWithoutUserInput, IncentiveGrantUncheckedCreateWithoutUserInput>
  }

  export type IncentiveGrantUpdateWithWhereUniqueWithoutUserInput = {
    where: IncentiveGrantWhereUniqueInput
    data: XOR<IncentiveGrantUpdateWithoutUserInput, IncentiveGrantUncheckedUpdateWithoutUserInput>
  }

  export type IncentiveGrantUpdateManyWithWhereWithoutUserInput = {
    where: IncentiveGrantScalarWhereInput
    data: XOR<IncentiveGrantUpdateManyMutationInput, IncentiveGrantUncheckedUpdateManyWithoutUserInput>
  }

  export type IncentiveGrantScalarWhereInput = {
    AND?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
    OR?: IncentiveGrantScalarWhereInput[]
    NOT?: IncentiveGrantScalarWhereInput | IncentiveGrantScalarWhereInput[]
    id?: StringFilter<"IncentiveGrant"> | string
    segmentIncentiveId?: StringFilter<"IncentiveGrant"> | string
    userId?: StringFilter<"IncentiveGrant"> | string
    grantedAt?: DateTimeFilter<"IncentiveGrant"> | Date | string
    couponCode?: StringNullableFilter<"IncentiveGrant"> | string | null
    couponId?: StringNullableFilter<"IncentiveGrant"> | string | null
    walletTransactionId?: StringNullableFilter<"IncentiveGrant"> | string | null
    redeemedAt?: DateTimeNullableFilter<"IncentiveGrant"> | Date | string | null
    redeemedOrderId?: StringNullableFilter<"IncentiveGrant"> | string | null
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutUserInput, WalletTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<WalletTransactionCreateWithoutUserInput, WalletTransactionUncheckedCreateWithoutUserInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutUserInput, WalletTransactionUncheckedUpdateWithoutUserInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutUserInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    userId?: StringFilter<"WalletTransaction"> | string
    type?: EnumWalletTransactionTypeFilter<"WalletTransaction"> | $Enums.WalletTransactionType
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    orderId?: StringNullableFilter<"WalletTransaction"> | string | null
    performedById?: StringNullableFilter<"WalletTransaction"> | string | null
    incentiveGrantId?: StringNullableFilter<"WalletTransaction"> | string | null
    paymentProvider?: StringNullableFilter<"WalletTransaction"> | string | null
    externalPaymentId?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutPerformedByInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutPerformedByInput, WalletTransactionUncheckedUpdateWithoutPerformedByInput>
    create: XOR<WalletTransactionCreateWithoutPerformedByInput, WalletTransactionUncheckedCreateWithoutPerformedByInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutPerformedByInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutPerformedByInput, WalletTransactionUncheckedUpdateWithoutPerformedByInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutPerformedByInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutPerformedByInput>
  }

  export type PushNotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: PushNotificationLogWhereUniqueInput
    update: XOR<PushNotificationLogUpdateWithoutUserInput, PushNotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<PushNotificationLogCreateWithoutUserInput, PushNotificationLogUncheckedCreateWithoutUserInput>
  }

  export type PushNotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: PushNotificationLogWhereUniqueInput
    data: XOR<PushNotificationLogUpdateWithoutUserInput, PushNotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type PushNotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: PushNotificationLogScalarWhereInput
    data: XOR<PushNotificationLogUpdateManyMutationInput, PushNotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type PushNotificationLogScalarWhereInput = {
    AND?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
    OR?: PushNotificationLogScalarWhereInput[]
    NOT?: PushNotificationLogScalarWhereInput | PushNotificationLogScalarWhereInput[]
    id?: StringFilter<"PushNotificationLog"> | string
    pushNotificationId?: StringFilter<"PushNotificationLog"> | string
    userId?: StringFilter<"PushNotificationLog"> | string
    status?: EnumPushDeliveryStatusFilter<"PushNotificationLog"> | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFilter<"PushNotificationLog"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dhKey?: StringFilter<"PushSubscription"> | string
    authKey?: StringFilter<"PushSubscription"> | string
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type PaymentProviderConfigUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: PaymentProviderConfigWhereUniqueInput
    update: XOR<PaymentProviderConfigUpdateWithoutUpdatedByInput, PaymentProviderConfigUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<PaymentProviderConfigCreateWithoutUpdatedByInput, PaymentProviderConfigUncheckedCreateWithoutUpdatedByInput>
  }

  export type PaymentProviderConfigUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: PaymentProviderConfigWhereUniqueInput
    data: XOR<PaymentProviderConfigUpdateWithoutUpdatedByInput, PaymentProviderConfigUncheckedUpdateWithoutUpdatedByInput>
  }

  export type PaymentProviderConfigUpdateManyWithWhereWithoutUpdatedByInput = {
    where: PaymentProviderConfigScalarWhereInput
    data: XOR<PaymentProviderConfigUpdateManyMutationInput, PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutWalletTransactionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutWalletTransactionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutWalletTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletTransactionsInput, UserUncheckedCreateWithoutWalletTransactionsInput>
  }

  export type OrderCreateWithoutWalletTransactionsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutWalletTransactionsInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutWalletTransactionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
  }

  export type UserCreateWithoutPerformedWalletActionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutPerformedWalletActionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPerformedWalletActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPerformedWalletActionsInput, UserUncheckedCreateWithoutPerformedWalletActionsInput>
  }

  export type IncentiveGrantCreateWithoutWalletTransactionInput = {
    id?: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    segmentIncentive: SegmentIncentiveCreateNestedOneWithoutGrantsInput
    user: UserCreateNestedOneWithoutIncentiveGrantsInput
    coupon?: CouponCreateNestedOneWithoutIncentiveGrantsInput
  }

  export type IncentiveGrantUncheckedCreateWithoutWalletTransactionInput = {
    id?: string
    segmentIncentiveId: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
  }

  export type IncentiveGrantCreateOrConnectWithoutWalletTransactionInput = {
    where: IncentiveGrantWhereUniqueInput
    create: XOR<IncentiveGrantCreateWithoutWalletTransactionInput, IncentiveGrantUncheckedCreateWithoutWalletTransactionInput>
  }

  export type UserUpsertWithoutWalletTransactionsInput = {
    update: XOR<UserUpdateWithoutWalletTransactionsInput, UserUncheckedUpdateWithoutWalletTransactionsInput>
    create: XOR<UserCreateWithoutWalletTransactionsInput, UserUncheckedCreateWithoutWalletTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletTransactionsInput, UserUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type UserUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type OrderUpsertWithoutWalletTransactionsInput = {
    update: XOR<OrderUpdateWithoutWalletTransactionsInput, OrderUncheckedUpdateWithoutWalletTransactionsInput>
    create: XOR<OrderCreateWithoutWalletTransactionsInput, OrderUncheckedCreateWithoutWalletTransactionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutWalletTransactionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutWalletTransactionsInput, OrderUncheckedUpdateWithoutWalletTransactionsInput>
  }

  export type OrderUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutWalletTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserUpsertWithoutPerformedWalletActionsInput = {
    update: XOR<UserUpdateWithoutPerformedWalletActionsInput, UserUncheckedUpdateWithoutPerformedWalletActionsInput>
    create: XOR<UserCreateWithoutPerformedWalletActionsInput, UserUncheckedCreateWithoutPerformedWalletActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPerformedWalletActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPerformedWalletActionsInput, UserUncheckedUpdateWithoutPerformedWalletActionsInput>
  }

  export type UserUpdateWithoutPerformedWalletActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPerformedWalletActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type IncentiveGrantUpsertWithoutWalletTransactionInput = {
    update: XOR<IncentiveGrantUpdateWithoutWalletTransactionInput, IncentiveGrantUncheckedUpdateWithoutWalletTransactionInput>
    create: XOR<IncentiveGrantCreateWithoutWalletTransactionInput, IncentiveGrantUncheckedCreateWithoutWalletTransactionInput>
    where?: IncentiveGrantWhereInput
  }

  export type IncentiveGrantUpdateToOneWithWhereWithoutWalletTransactionInput = {
    where?: IncentiveGrantWhereInput
    data: XOR<IncentiveGrantUpdateWithoutWalletTransactionInput, IncentiveGrantUncheckedUpdateWithoutWalletTransactionInput>
  }

  export type IncentiveGrantUpdateWithoutWalletTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    segmentIncentive?: SegmentIncentiveUpdateOneRequiredWithoutGrantsNestedInput
    user?: UserUpdateOneRequiredWithoutIncentiveGrantsNestedInput
    coupon?: CouponUpdateOneWithoutIncentiveGrantsNestedInput
  }

  export type IncentiveGrantUncheckedUpdateWithoutWalletTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutLocationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutLocationsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutLocationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
  }

  export type LocationCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    menus?: MenuCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    coupons?: CouponCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutUsersInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    coupons?: CouponUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutUsersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutLocationsInput = {
    update: XOR<UserUpdateWithoutLocationsInput, UserUncheckedUpdateWithoutLocationsInput>
    create: XOR<UserCreateWithoutLocationsInput, UserUncheckedCreateWithoutLocationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLocationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLocationsInput, UserUncheckedUpdateWithoutLocationsInput>
  }

  export type UserUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type LocationUpsertWithoutUsersInput = {
    update: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
    create: XOR<LocationCreateWithoutUsersInput, LocationUncheckedCreateWithoutUsersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutUsersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutUsersInput, LocationUncheckedUpdateWithoutUsersInput>
  }

  export type LocationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    menus?: MenuUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    coupons?: CouponUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type LocationCreateWithoutMenusInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    users?: UserLocationCreateNestedManyWithoutLocationInput
    coupons?: CouponCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutMenusInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    users?: UserLocationUncheckedCreateNestedManyWithoutLocationInput
    coupons?: CouponUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutMenusInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMenusInput, LocationUncheckedCreateWithoutMenusInput>
  }

  export type MenuItemCreateWithoutMenuInput = {
    id?: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dish: DishCreateNestedOneWithoutMenuItemsInput
    orderItems?: OrderItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutMenuInput = {
    id?: string
    dishId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemCreateManyMenuInputEnvelope = {
    data: MenuItemCreateManyMenuInput | MenuItemCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type MenuPromotionBannerCreateWithoutMenuInput = {
    id?: string
    sortOrder?: number
    promotionBanner: PromotionBannerCreateNestedOneWithoutMenuAssignmentsInput
  }

  export type MenuPromotionBannerUncheckedCreateWithoutMenuInput = {
    id?: string
    promotionBannerId: string
    sortOrder?: number
  }

  export type MenuPromotionBannerCreateOrConnectWithoutMenuInput = {
    where: MenuPromotionBannerWhereUniqueInput
    create: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput>
  }

  export type MenuPromotionBannerCreateManyMenuInputEnvelope = {
    data: MenuPromotionBannerCreateManyMenuInput | MenuPromotionBannerCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutMenusInput = {
    update: XOR<LocationUpdateWithoutMenusInput, LocationUncheckedUpdateWithoutMenusInput>
    create: XOR<LocationCreateWithoutMenusInput, LocationUncheckedCreateWithoutMenusInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutMenusInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutMenusInput, LocationUncheckedUpdateWithoutMenusInput>
  }

  export type LocationUpdateWithoutMenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    users?: UserLocationUpdateManyWithoutLocationNestedInput
    coupons?: CouponUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutMenusInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserLocationUncheckedUpdateManyWithoutLocationNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type MenuItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutMenuInput, MenuItemUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutMenuInput, MenuItemUncheckedUpdateWithoutMenuInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutMenuInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: StringFilter<"MenuItem"> | string
    menuId?: StringFilter<"MenuItem"> | string
    dishId?: StringFilter<"MenuItem"> | string
    date?: DateTimeFilter<"MenuItem"> | Date | string
    available?: BoolFilter<"MenuItem"> | boolean
    price?: DecimalFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string
    maxOrders?: IntNullableFilter<"MenuItem"> | number | null
    currentOrders?: IntFilter<"MenuItem"> | number
    isPromotion?: BoolFilter<"MenuItem"> | boolean
    promotionPrice?: DecimalNullableFilter<"MenuItem"> | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type MenuPromotionBannerUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuPromotionBannerWhereUniqueInput
    update: XOR<MenuPromotionBannerUpdateWithoutMenuInput, MenuPromotionBannerUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuPromotionBannerCreateWithoutMenuInput, MenuPromotionBannerUncheckedCreateWithoutMenuInput>
  }

  export type MenuPromotionBannerUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuPromotionBannerWhereUniqueInput
    data: XOR<MenuPromotionBannerUpdateWithoutMenuInput, MenuPromotionBannerUncheckedUpdateWithoutMenuInput>
  }

  export type MenuPromotionBannerUpdateManyWithWhereWithoutMenuInput = {
    where: MenuPromotionBannerScalarWhereInput
    data: XOR<MenuPromotionBannerUpdateManyMutationInput, MenuPromotionBannerUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuPromotionBannerScalarWhereInput = {
    AND?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
    OR?: MenuPromotionBannerScalarWhereInput[]
    NOT?: MenuPromotionBannerScalarWhereInput | MenuPromotionBannerScalarWhereInput[]
    id?: StringFilter<"MenuPromotionBanner"> | string
    menuId?: StringFilter<"MenuPromotionBanner"> | string
    promotionBannerId?: StringFilter<"MenuPromotionBanner"> | string
    sortOrder?: IntFilter<"MenuPromotionBanner"> | number
  }

  export type CouponCreateWithoutPromotionBannersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutPromotionBannersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutPromotionBannersInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutPromotionBannersInput, CouponUncheckedCreateWithoutPromotionBannersInput>
  }

  export type MarketingTemplateCreateWithoutPromotionBannersInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutMarketingTemplatesInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUncheckedCreateWithoutPromotionBannersInput = {
    id?: string
    organizationId?: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateCreateOrConnectWithoutPromotionBannersInput = {
    where: MarketingTemplateWhereUniqueInput
    create: XOR<MarketingTemplateCreateWithoutPromotionBannersInput, MarketingTemplateUncheckedCreateWithoutPromotionBannersInput>
  }

  export type MenuPromotionBannerCreateWithoutPromotionBannerInput = {
    id?: string
    sortOrder?: number
    menu: MenuCreateNestedOneWithoutPromotionBannersInput
  }

  export type MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput = {
    id?: string
    menuId: string
    sortOrder?: number
  }

  export type MenuPromotionBannerCreateOrConnectWithoutPromotionBannerInput = {
    where: MenuPromotionBannerWhereUniqueInput
    create: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput>
  }

  export type MenuPromotionBannerCreateManyPromotionBannerInputEnvelope = {
    data: MenuPromotionBannerCreateManyPromotionBannerInput | MenuPromotionBannerCreateManyPromotionBannerInput[]
    skipDuplicates?: boolean
  }

  export type CouponUpsertWithoutPromotionBannersInput = {
    update: XOR<CouponUpdateWithoutPromotionBannersInput, CouponUncheckedUpdateWithoutPromotionBannersInput>
    create: XOR<CouponCreateWithoutPromotionBannersInput, CouponUncheckedCreateWithoutPromotionBannersInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutPromotionBannersInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutPromotionBannersInput, CouponUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type CouponUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type MarketingTemplateUpsertWithoutPromotionBannersInput = {
    update: XOR<MarketingTemplateUpdateWithoutPromotionBannersInput, MarketingTemplateUncheckedUpdateWithoutPromotionBannersInput>
    create: XOR<MarketingTemplateCreateWithoutPromotionBannersInput, MarketingTemplateUncheckedCreateWithoutPromotionBannersInput>
    where?: MarketingTemplateWhereInput
  }

  export type MarketingTemplateUpdateToOneWithWhereWithoutPromotionBannersInput = {
    where?: MarketingTemplateWhereInput
    data: XOR<MarketingTemplateUpdateWithoutPromotionBannersInput, MarketingTemplateUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type MarketingTemplateUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutMarketingTemplatesNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MenuPromotionBannerUpsertWithWhereUniqueWithoutPromotionBannerInput = {
    where: MenuPromotionBannerWhereUniqueInput
    update: XOR<MenuPromotionBannerUpdateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedUpdateWithoutPromotionBannerInput>
    create: XOR<MenuPromotionBannerCreateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedCreateWithoutPromotionBannerInput>
  }

  export type MenuPromotionBannerUpdateWithWhereUniqueWithoutPromotionBannerInput = {
    where: MenuPromotionBannerWhereUniqueInput
    data: XOR<MenuPromotionBannerUpdateWithoutPromotionBannerInput, MenuPromotionBannerUncheckedUpdateWithoutPromotionBannerInput>
  }

  export type MenuPromotionBannerUpdateManyWithWhereWithoutPromotionBannerInput = {
    where: MenuPromotionBannerScalarWhereInput
    data: XOR<MenuPromotionBannerUpdateManyMutationInput, MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerInput>
  }

  export type MenuCreateWithoutPromotionBannersInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenusInput
    menuItems?: MenuItemCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutPromotionBannersInput = {
    id?: string
    locationId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutPromotionBannersInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutPromotionBannersInput, MenuUncheckedCreateWithoutPromotionBannersInput>
  }

  export type PromotionBannerCreateWithoutMenuAssignmentsInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon?: CouponCreateNestedOneWithoutPromotionBannersInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPromotionBannersInput
  }

  export type PromotionBannerUncheckedCreateWithoutMenuAssignmentsInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    couponId?: string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionBannerCreateOrConnectWithoutMenuAssignmentsInput = {
    where: PromotionBannerWhereUniqueInput
    create: XOR<PromotionBannerCreateWithoutMenuAssignmentsInput, PromotionBannerUncheckedCreateWithoutMenuAssignmentsInput>
  }

  export type MenuUpsertWithoutPromotionBannersInput = {
    update: XOR<MenuUpdateWithoutPromotionBannersInput, MenuUncheckedUpdateWithoutPromotionBannersInput>
    create: XOR<MenuCreateWithoutPromotionBannersInput, MenuUncheckedCreateWithoutPromotionBannersInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutPromotionBannersInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutPromotionBannersInput, MenuUncheckedUpdateWithoutPromotionBannersInput>
  }

  export type MenuUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenusNestedInput
    menuItems?: MenuItemUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutPromotionBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type PromotionBannerUpsertWithoutMenuAssignmentsInput = {
    update: XOR<PromotionBannerUpdateWithoutMenuAssignmentsInput, PromotionBannerUncheckedUpdateWithoutMenuAssignmentsInput>
    create: XOR<PromotionBannerCreateWithoutMenuAssignmentsInput, PromotionBannerUncheckedCreateWithoutMenuAssignmentsInput>
    where?: PromotionBannerWhereInput
  }

  export type PromotionBannerUpdateToOneWithWhereWithoutMenuAssignmentsInput = {
    where?: PromotionBannerWhereInput
    data: XOR<PromotionBannerUpdateWithoutMenuAssignmentsInput, PromotionBannerUncheckedUpdateWithoutMenuAssignmentsInput>
  }

  export type PromotionBannerUpdateWithoutMenuAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneWithoutPromotionBannersNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPromotionBannersNestedInput
  }

  export type PromotionBannerUncheckedUpdateWithoutMenuAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateWithoutMenuItemsInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutMenusInput
    promotionBanners?: MenuPromotionBannerCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    locationId: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    promotionBanners?: MenuPromotionBannerUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuCreateOrConnectWithoutMenuItemsInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutMenuItemsInput, MenuUncheckedCreateWithoutMenuItemsInput>
  }

  export type DishCreateWithoutMenuItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponCreateNestedManyWithoutFreeItemDishInput
  }

  export type DishUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coupons?: CouponUncheckedCreateNestedManyWithoutFreeItemDishInput
  }

  export type DishCreateOrConnectWithoutMenuItemsInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutMenuItemsInput, DishUncheckedCreateWithoutMenuItemsInput>
  }

  export type OrderItemCreateWithoutMenuItemInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutMenuItemInput = {
    id?: string
    orderId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutMenuItemInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput>
  }

  export type OrderItemCreateManyMenuItemInputEnvelope = {
    data: OrderItemCreateManyMenuItemInput | OrderItemCreateManyMenuItemInput[]
    skipDuplicates?: boolean
  }

  export type MenuUpsertWithoutMenuItemsInput = {
    update: XOR<MenuUpdateWithoutMenuItemsInput, MenuUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<MenuCreateWithoutMenuItemsInput, MenuUncheckedCreateWithoutMenuItemsInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutMenuItemsInput, MenuUncheckedUpdateWithoutMenuItemsInput>
  }

  export type MenuUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutMenusNestedInput
    promotionBanners?: MenuPromotionBannerUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotionBanners?: MenuPromotionBannerUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type DishUpsertWithoutMenuItemsInput = {
    update: XOR<DishUpdateWithoutMenuItemsInput, DishUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<DishCreateWithoutMenuItemsInput, DishUncheckedCreateWithoutMenuItemsInput>
    where?: DishWhereInput
  }

  export type DishUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: DishWhereInput
    data: XOR<DishUpdateWithoutMenuItemsInput, DishUncheckedUpdateWithoutMenuItemsInput>
  }

  export type DishUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUpdateManyWithoutFreeItemDishNestedInput
  }

  export type DishUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupons?: CouponUncheckedUpdateManyWithoutFreeItemDishNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutMenuItemInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutMenuItemInput, OrderItemUncheckedUpdateWithoutMenuItemInput>
    create: XOR<OrderItemCreateWithoutMenuItemInput, OrderItemUncheckedCreateWithoutMenuItemInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutMenuItemInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutMenuItemInput, OrderItemUncheckedUpdateWithoutMenuItemInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutMenuItemInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutMenuItemInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    menuItemId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type MenuItemCreateWithoutDishInput = {
    id?: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutMenuItemsInput
    orderItems?: OrderItemCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemUncheckedCreateWithoutDishInput = {
    id?: string
    menuId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutMenuItemInput
  }

  export type MenuItemCreateOrConnectWithoutDishInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput>
  }

  export type MenuItemCreateManyDishInputEnvelope = {
    data: MenuItemCreateManyDishInput | MenuItemCreateManyDishInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutFreeItemDishInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutFreeItemDishInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutFreeItemDishInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput>
  }

  export type CouponCreateManyFreeItemDishInputEnvelope = {
    data: CouponCreateManyFreeItemDishInput | CouponCreateManyFreeItemDishInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemUpsertWithWhereUniqueWithoutDishInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutDishInput, MenuItemUncheckedUpdateWithoutDishInput>
    create: XOR<MenuItemCreateWithoutDishInput, MenuItemUncheckedCreateWithoutDishInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutDishInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutDishInput, MenuItemUncheckedUpdateWithoutDishInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutDishInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutDishInput>
  }

  export type CouponUpsertWithWhereUniqueWithoutFreeItemDishInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutFreeItemDishInput, CouponUncheckedUpdateWithoutFreeItemDishInput>
    create: XOR<CouponCreateWithoutFreeItemDishInput, CouponUncheckedCreateWithoutFreeItemDishInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutFreeItemDishInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutFreeItemDishInput, CouponUncheckedUpdateWithoutFreeItemDishInput>
  }

  export type CouponUpdateManyWithWhereWithoutFreeItemDishInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutFreeItemDishInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type LocationCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    menus?: MenuCreateNestedManyWithoutLocationInput
    users?: UserLocationCreateNestedManyWithoutLocationInput
    coupons?: CouponCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutOrdersInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutLocationInput
    users?: UserLocationUncheckedCreateNestedManyWithoutLocationInput
    coupons?: CouponUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutOrdersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    menuItem: MenuItemCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    menuItemId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CouponRedemptionCreateWithoutOrderInput = {
    id?: string
    redeemedAt?: Date | string
    coupon: CouponCreateNestedOneWithoutRedemptionsInput
    user: UserCreateNestedOneWithoutCouponRedemptionsInput
  }

  export type CouponRedemptionUncheckedCreateWithoutOrderInput = {
    id?: string
    couponId: string
    userId: string
    redeemedAt?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutOrderInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput>
  }

  export type CouponRedemptionCreateManyOrderInputEnvelope = {
    data: CouponRedemptionCreateManyOrderInput | CouponRedemptionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutOrdersInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeCreateNestedManyWithoutCompanyInput
    invoices?: CompanyInvoiceCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    contractNumber?: string | null
    isActive?: boolean
    subsidyType?: $Enums.SubsidyType
    subsidyValue?: Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: Decimal | DecimalJsLike | number | string | null
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: CompanyEmployeeUncheckedCreateNestedManyWithoutCompanyInput
    invoices?: CompanyInvoiceUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutOrdersInput, CompanyUncheckedCreateWithoutOrdersInput>
  }

  export type WalletTransactionCreateWithoutOrderInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletTransactionsInput
    performedBy?: UserCreateNestedOneWithoutPerformedWalletActionsInput
    incentiveGrant?: IncentiveGrantCreateNestedOneWithoutWalletTransactionInput
  }

  export type WalletTransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput>
  }

  export type WalletTransactionCreateManyOrderInputEnvelope = {
    data: WalletTransactionCreateManyOrderInput | WalletTransactionCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type LocationUpsertWithoutOrdersInput = {
    update: XOR<LocationUpdateWithoutOrdersInput, LocationUncheckedUpdateWithoutOrdersInput>
    create: XOR<LocationCreateWithoutOrdersInput, LocationUncheckedCreateWithoutOrdersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutOrdersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutOrdersInput, LocationUncheckedUpdateWithoutOrdersInput>
  }

  export type LocationUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    menus?: MenuUpdateManyWithoutLocationNestedInput
    users?: UserLocationUpdateManyWithoutLocationNestedInput
    coupons?: CouponUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserLocationUncheckedUpdateManyWithoutLocationNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutOrderInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutOrderInput, CouponRedemptionUncheckedUpdateWithoutOrderInput>
    create: XOR<CouponRedemptionCreateWithoutOrderInput, CouponRedemptionUncheckedCreateWithoutOrderInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutOrderInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutOrderInput, CouponRedemptionUncheckedUpdateWithoutOrderInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutOrderInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutOrderInput>
  }

  export type CompanyUpsertWithoutOrdersInput = {
    update: XOR<CompanyUpdateWithoutOrdersInput, CompanyUncheckedUpdateWithoutOrdersInput>
    create: XOR<CompanyCreateWithoutOrdersInput, CompanyUncheckedCreateWithoutOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutOrdersInput, CompanyUncheckedUpdateWithoutOrdersInput>
  }

  export type CompanyUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUpdateManyWithoutCompanyNestedInput
    invoices?: CompanyInvoiceUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subsidyType?: EnumSubsidyTypeFieldUpdateOperationsInput | $Enums.SubsidyType
    subsidyValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    subsidyMaxPerDay?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: CompanyEmployeeUncheckedUpdateManyWithoutCompanyNestedInput
    invoices?: CompanyInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutOrderInput, WalletTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<WalletTransactionCreateWithoutOrderInput, WalletTransactionUncheckedCreateWithoutOrderInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutOrderInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutOrderInput, WalletTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutOrderInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutOrderInput>
  }

  export type LocationCreateWithoutCouponsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutLocationsInput
    menus?: MenuCreateNestedManyWithoutLocationInput
    orders?: OrderCreateNestedManyWithoutLocationInput
    users?: UserLocationCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutCouponsInput = {
    id?: string
    organizationId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menus?: MenuUncheckedCreateNestedManyWithoutLocationInput
    orders?: OrderUncheckedCreateNestedManyWithoutLocationInput
    users?: UserLocationUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutCouponsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCouponsInput, LocationUncheckedCreateWithoutCouponsInput>
  }

  export type DishCreateWithoutCouponsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemCreateNestedManyWithoutDishInput
  }

  export type DishUncheckedCreateWithoutCouponsInput = {
    id?: string
    name: string
    description?: string | null
    imageUrl?: string | null
    category?: string | null
    calories?: number | null
    protein?: Decimal | DecimalJsLike | number | string | null
    carbs?: Decimal | DecimalJsLike | number | string | null
    fat?: Decimal | DecimalJsLike | number | string | null
    allergens?: DishCreateallergensInput | string[]
    dietTags?: DishCreatedietTagsInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutDishInput
  }

  export type DishCreateOrConnectWithoutCouponsInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutCouponsInput, DishUncheckedCreateWithoutCouponsInput>
  }

  export type CouponRedemptionCreateWithoutCouponInput = {
    id?: string
    redeemedAt?: Date | string
    user: UserCreateNestedOneWithoutCouponRedemptionsInput
    order: OrderCreateNestedOneWithoutCouponRedemptionsInput
  }

  export type CouponRedemptionUncheckedCreateWithoutCouponInput = {
    id?: string
    userId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type CouponRedemptionCreateOrConnectWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    create: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput>
  }

  export type CouponRedemptionCreateManyCouponInputEnvelope = {
    data: CouponRedemptionCreateManyCouponInput | CouponRedemptionCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type IncentiveGrantCreateWithoutCouponInput = {
    id?: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    segmentIncentive: SegmentIncentiveCreateNestedOneWithoutGrantsInput
    user: UserCreateNestedOneWithoutIncentiveGrantsInput
    walletTransaction?: WalletTransactionCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantUncheckedCreateWithoutCouponInput = {
    id?: string
    segmentIncentiveId: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    walletTransaction?: WalletTransactionUncheckedCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantCreateOrConnectWithoutCouponInput = {
    where: IncentiveGrantWhereUniqueInput
    create: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput>
  }

  export type IncentiveGrantCreateManyCouponInputEnvelope = {
    data: IncentiveGrantCreateManyCouponInput | IncentiveGrantCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type SegmentIncentiveCreateWithoutCouponInput = {
    id?: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentIncentivesInput
    segment: CustomerSegmentCreateNestedOneWithoutSegmentIncentivesInput
    grants?: IncentiveGrantCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveUncheckedCreateWithoutCouponInput = {
    id?: string
    organizationId: string
    segmentId: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grants?: IncentiveGrantUncheckedCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveCreateOrConnectWithoutCouponInput = {
    where: SegmentIncentiveWhereUniqueInput
    create: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput>
  }

  export type SegmentIncentiveCreateManyCouponInputEnvelope = {
    data: SegmentIncentiveCreateManyCouponInput | SegmentIncentiveCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type PromotionBannerCreateWithoutCouponInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPromotionBannersInput
    menuAssignments?: MenuPromotionBannerCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerUncheckedCreateWithoutCouponInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    menuAssignments?: MenuPromotionBannerUncheckedCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerCreateOrConnectWithoutCouponInput = {
    where: PromotionBannerWhereUniqueInput
    create: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput>
  }

  export type PromotionBannerCreateManyCouponInputEnvelope = {
    data: PromotionBannerCreateManyCouponInput | PromotionBannerCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutCouponsInput = {
    update: XOR<LocationUpdateWithoutCouponsInput, LocationUncheckedUpdateWithoutCouponsInput>
    create: XOR<LocationCreateWithoutCouponsInput, LocationUncheckedCreateWithoutCouponsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutCouponsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutCouponsInput, LocationUncheckedUpdateWithoutCouponsInput>
  }

  export type LocationUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutLocationsNestedInput
    menus?: MenuUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    users?: UserLocationUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserLocationUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type DishUpsertWithoutCouponsInput = {
    update: XOR<DishUpdateWithoutCouponsInput, DishUncheckedUpdateWithoutCouponsInput>
    create: XOR<DishCreateWithoutCouponsInput, DishUncheckedCreateWithoutCouponsInput>
    where?: DishWhereInput
  }

  export type DishUpdateToOneWithWhereWithoutCouponsInput = {
    where?: DishWhereInput
    data: XOR<DishUpdateWithoutCouponsInput, DishUncheckedUpdateWithoutCouponsInput>
  }

  export type DishUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    calories?: NullableIntFieldUpdateOperationsInput | number | null
    protein?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    carbs?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fat?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allergens?: DishUpdateallergensInput | string[]
    dietTags?: DishUpdatedietTagsInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutDishNestedInput
  }

  export type CouponRedemptionUpsertWithWhereUniqueWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    update: XOR<CouponRedemptionUpdateWithoutCouponInput, CouponRedemptionUncheckedUpdateWithoutCouponInput>
    create: XOR<CouponRedemptionCreateWithoutCouponInput, CouponRedemptionUncheckedCreateWithoutCouponInput>
  }

  export type CouponRedemptionUpdateWithWhereUniqueWithoutCouponInput = {
    where: CouponRedemptionWhereUniqueInput
    data: XOR<CouponRedemptionUpdateWithoutCouponInput, CouponRedemptionUncheckedUpdateWithoutCouponInput>
  }

  export type CouponRedemptionUpdateManyWithWhereWithoutCouponInput = {
    where: CouponRedemptionScalarWhereInput
    data: XOR<CouponRedemptionUpdateManyMutationInput, CouponRedemptionUncheckedUpdateManyWithoutCouponInput>
  }

  export type IncentiveGrantUpsertWithWhereUniqueWithoutCouponInput = {
    where: IncentiveGrantWhereUniqueInput
    update: XOR<IncentiveGrantUpdateWithoutCouponInput, IncentiveGrantUncheckedUpdateWithoutCouponInput>
    create: XOR<IncentiveGrantCreateWithoutCouponInput, IncentiveGrantUncheckedCreateWithoutCouponInput>
  }

  export type IncentiveGrantUpdateWithWhereUniqueWithoutCouponInput = {
    where: IncentiveGrantWhereUniqueInput
    data: XOR<IncentiveGrantUpdateWithoutCouponInput, IncentiveGrantUncheckedUpdateWithoutCouponInput>
  }

  export type IncentiveGrantUpdateManyWithWhereWithoutCouponInput = {
    where: IncentiveGrantScalarWhereInput
    data: XOR<IncentiveGrantUpdateManyMutationInput, IncentiveGrantUncheckedUpdateManyWithoutCouponInput>
  }

  export type SegmentIncentiveUpsertWithWhereUniqueWithoutCouponInput = {
    where: SegmentIncentiveWhereUniqueInput
    update: XOR<SegmentIncentiveUpdateWithoutCouponInput, SegmentIncentiveUncheckedUpdateWithoutCouponInput>
    create: XOR<SegmentIncentiveCreateWithoutCouponInput, SegmentIncentiveUncheckedCreateWithoutCouponInput>
  }

  export type SegmentIncentiveUpdateWithWhereUniqueWithoutCouponInput = {
    where: SegmentIncentiveWhereUniqueInput
    data: XOR<SegmentIncentiveUpdateWithoutCouponInput, SegmentIncentiveUncheckedUpdateWithoutCouponInput>
  }

  export type SegmentIncentiveUpdateManyWithWhereWithoutCouponInput = {
    where: SegmentIncentiveScalarWhereInput
    data: XOR<SegmentIncentiveUpdateManyMutationInput, SegmentIncentiveUncheckedUpdateManyWithoutCouponInput>
  }

  export type PromotionBannerUpsertWithWhereUniqueWithoutCouponInput = {
    where: PromotionBannerWhereUniqueInput
    update: XOR<PromotionBannerUpdateWithoutCouponInput, PromotionBannerUncheckedUpdateWithoutCouponInput>
    create: XOR<PromotionBannerCreateWithoutCouponInput, PromotionBannerUncheckedCreateWithoutCouponInput>
  }

  export type PromotionBannerUpdateWithWhereUniqueWithoutCouponInput = {
    where: PromotionBannerWhereUniqueInput
    data: XOR<PromotionBannerUpdateWithoutCouponInput, PromotionBannerUncheckedUpdateWithoutCouponInput>
  }

  export type PromotionBannerUpdateManyWithWhereWithoutCouponInput = {
    where: PromotionBannerScalarWhereInput
    data: XOR<PromotionBannerUpdateManyMutationInput, PromotionBannerUncheckedUpdateManyWithoutCouponInput>
  }

  export type PromotionBannerScalarWhereInput = {
    AND?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
    OR?: PromotionBannerScalarWhereInput[]
    NOT?: PromotionBannerScalarWhereInput | PromotionBannerScalarWhereInput[]
    id?: StringFilter<"PromotionBanner"> | string
    title?: StringFilter<"PromotionBanner"> | string
    subtitle?: StringNullableFilter<"PromotionBanner"> | string | null
    imageUrl?: StringNullableFilter<"PromotionBanner"> | string | null
    couponId?: StringNullableFilter<"PromotionBanner"> | string | null
    isActive?: BoolFilter<"PromotionBanner"> | boolean
    marketingTemplateId?: StringNullableFilter<"PromotionBanner"> | string | null
    templateSnapshot?: JsonNullableFilter<"PromotionBanner">
    createdAt?: DateTimeFilter<"PromotionBanner"> | Date | string
    updatedAt?: DateTimeFilter<"PromotionBanner"> | Date | string
  }

  export type CouponCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutRedemptionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutRedemptionsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
  }

  export type UserCreateWithoutCouponRedemptionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCouponRedemptionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCouponRedemptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCouponRedemptionsInput, UserUncheckedCreateWithoutCouponRedemptionsInput>
  }

  export type OrderCreateWithoutCouponRedemptionsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    location: LocationCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCouponRedemptionsInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCouponRedemptionsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCouponRedemptionsInput, OrderUncheckedCreateWithoutCouponRedemptionsInput>
  }

  export type CouponUpsertWithoutRedemptionsInput = {
    update: XOR<CouponUpdateWithoutRedemptionsInput, CouponUncheckedUpdateWithoutRedemptionsInput>
    create: XOR<CouponCreateWithoutRedemptionsInput, CouponUncheckedCreateWithoutRedemptionsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutRedemptionsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutRedemptionsInput, CouponUncheckedUpdateWithoutRedemptionsInput>
  }

  export type CouponUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type UserUpsertWithoutCouponRedemptionsInput = {
    update: XOR<UserUpdateWithoutCouponRedemptionsInput, UserUncheckedUpdateWithoutCouponRedemptionsInput>
    create: XOR<UserCreateWithoutCouponRedemptionsInput, UserUncheckedCreateWithoutCouponRedemptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCouponRedemptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCouponRedemptionsInput, UserUncheckedUpdateWithoutCouponRedemptionsInput>
  }

  export type UserUpdateWithoutCouponRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCouponRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type OrderUpsertWithoutCouponRedemptionsInput = {
    update: XOR<OrderUpdateWithoutCouponRedemptionsInput, OrderUncheckedUpdateWithoutCouponRedemptionsInput>
    create: XOR<OrderCreateWithoutCouponRedemptionsInput, OrderUncheckedCreateWithoutCouponRedemptionsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutCouponRedemptionsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutCouponRedemptionsInput, OrderUncheckedUpdateWithoutCouponRedemptionsInput>
  }

  export type OrderUpdateWithoutCouponRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCouponRedemptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    user: UserCreateNestedOneWithoutOrdersInput
    location: LocationCreateNestedOneWithoutOrdersInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutOrderInput
    employerCompany?: CompanyCreateNestedOneWithoutOrdersInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutOrderInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type MenuItemCreateWithoutOrderItemsInput = {
    id?: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutMenuItemsInput
    dish: DishCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    menuId: string
    dishId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemCreateOrConnectWithoutOrderItemsInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutOrderItemsInput, MenuItemUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MenuItemUpsertWithoutOrderItemsInput = {
    update: XOR<MenuItemUpdateWithoutOrderItemsInput, MenuItemUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MenuItemCreateWithoutOrderItemsInput, MenuItemUncheckedCreateWithoutOrderItemsInput>
    where?: MenuItemWhereInput
  }

  export type MenuItemUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: MenuItemWhereInput
    data: XOR<MenuItemUpdateWithoutOrderItemsInput, MenuItemUncheckedUpdateWithoutOrderItemsInput>
  }

  export type MenuItemUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutMenuItemsNestedInput
    dish?: DishUpdateOneRequiredWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSegmentsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSegmentsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSegmentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSegmentsInput, OrganizationUncheckedCreateWithoutSegmentsInput>
  }

  export type InAppMessageCreateWithoutSegmentInput = {
    id?: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInAppMessagesInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutInAppMessagesInput
    readBy?: InAppMessageReadCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageUncheckedCreateWithoutSegmentInput = {
    id?: string
    organizationId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    readBy?: InAppMessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageCreateOrConnectWithoutSegmentInput = {
    where: InAppMessageWhereUniqueInput
    create: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput>
  }

  export type InAppMessageCreateManySegmentInputEnvelope = {
    data: InAppMessageCreateManySegmentInput | InAppMessageCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type MarketingWorkflowCreateWithoutSegmentInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput
    executionLogs?: WorkflowExecutionLogCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowUncheckedCreateWithoutSegmentInput = {
    id?: string
    organizationId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    executionLogs?: WorkflowExecutionLogUncheckedCreateNestedManyWithoutWorkflowInput
  }

  export type MarketingWorkflowCreateOrConnectWithoutSegmentInput = {
    where: MarketingWorkflowWhereUniqueInput
    create: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput>
  }

  export type MarketingWorkflowCreateManySegmentInputEnvelope = {
    data: MarketingWorkflowCreateManySegmentInput | MarketingWorkflowCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type SegmentIncentiveCreateWithoutSegmentInput = {
    id?: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentIncentivesInput
    coupon?: CouponCreateNestedOneWithoutSegmentIncentivesInput
    grants?: IncentiveGrantCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveUncheckedCreateWithoutSegmentInput = {
    id?: string
    organizationId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    grants?: IncentiveGrantUncheckedCreateNestedManyWithoutSegmentIncentiveInput
  }

  export type SegmentIncentiveCreateOrConnectWithoutSegmentInput = {
    where: SegmentIncentiveWhereUniqueInput
    create: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput>
  }

  export type SegmentIncentiveCreateManySegmentInputEnvelope = {
    data: SegmentIncentiveCreateManySegmentInput | SegmentIncentiveCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutSegmentInput = {
    id?: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPushNotificationsInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPushNotificationsInput
    logs?: PushNotificationLogCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationUncheckedCreateWithoutSegmentInput = {
    id?: string
    organizationId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: PushNotificationLogUncheckedCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationCreateOrConnectWithoutSegmentInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput>
  }

  export type PushNotificationCreateManySegmentInputEnvelope = {
    data: PushNotificationCreateManySegmentInput | PushNotificationCreateManySegmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutSegmentsInput = {
    update: XOR<OrganizationUpdateWithoutSegmentsInput, OrganizationUncheckedUpdateWithoutSegmentsInput>
    create: XOR<OrganizationCreateWithoutSegmentsInput, OrganizationUncheckedCreateWithoutSegmentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSegmentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSegmentsInput, OrganizationUncheckedUpdateWithoutSegmentsInput>
  }

  export type OrganizationUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSegmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type InAppMessageUpsertWithWhereUniqueWithoutSegmentInput = {
    where: InAppMessageWhereUniqueInput
    update: XOR<InAppMessageUpdateWithoutSegmentInput, InAppMessageUncheckedUpdateWithoutSegmentInput>
    create: XOR<InAppMessageCreateWithoutSegmentInput, InAppMessageUncheckedCreateWithoutSegmentInput>
  }

  export type InAppMessageUpdateWithWhereUniqueWithoutSegmentInput = {
    where: InAppMessageWhereUniqueInput
    data: XOR<InAppMessageUpdateWithoutSegmentInput, InAppMessageUncheckedUpdateWithoutSegmentInput>
  }

  export type InAppMessageUpdateManyWithWhereWithoutSegmentInput = {
    where: InAppMessageScalarWhereInput
    data: XOR<InAppMessageUpdateManyMutationInput, InAppMessageUncheckedUpdateManyWithoutSegmentInput>
  }

  export type MarketingWorkflowUpsertWithWhereUniqueWithoutSegmentInput = {
    where: MarketingWorkflowWhereUniqueInput
    update: XOR<MarketingWorkflowUpdateWithoutSegmentInput, MarketingWorkflowUncheckedUpdateWithoutSegmentInput>
    create: XOR<MarketingWorkflowCreateWithoutSegmentInput, MarketingWorkflowUncheckedCreateWithoutSegmentInput>
  }

  export type MarketingWorkflowUpdateWithWhereUniqueWithoutSegmentInput = {
    where: MarketingWorkflowWhereUniqueInput
    data: XOR<MarketingWorkflowUpdateWithoutSegmentInput, MarketingWorkflowUncheckedUpdateWithoutSegmentInput>
  }

  export type MarketingWorkflowUpdateManyWithWhereWithoutSegmentInput = {
    where: MarketingWorkflowScalarWhereInput
    data: XOR<MarketingWorkflowUpdateManyMutationInput, MarketingWorkflowUncheckedUpdateManyWithoutSegmentInput>
  }

  export type SegmentIncentiveUpsertWithWhereUniqueWithoutSegmentInput = {
    where: SegmentIncentiveWhereUniqueInput
    update: XOR<SegmentIncentiveUpdateWithoutSegmentInput, SegmentIncentiveUncheckedUpdateWithoutSegmentInput>
    create: XOR<SegmentIncentiveCreateWithoutSegmentInput, SegmentIncentiveUncheckedCreateWithoutSegmentInput>
  }

  export type SegmentIncentiveUpdateWithWhereUniqueWithoutSegmentInput = {
    where: SegmentIncentiveWhereUniqueInput
    data: XOR<SegmentIncentiveUpdateWithoutSegmentInput, SegmentIncentiveUncheckedUpdateWithoutSegmentInput>
  }

  export type SegmentIncentiveUpdateManyWithWhereWithoutSegmentInput = {
    where: SegmentIncentiveScalarWhereInput
    data: XOR<SegmentIncentiveUpdateManyMutationInput, SegmentIncentiveUncheckedUpdateManyWithoutSegmentInput>
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutSegmentInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutSegmentInput, PushNotificationUncheckedUpdateWithoutSegmentInput>
    create: XOR<PushNotificationCreateWithoutSegmentInput, PushNotificationUncheckedCreateWithoutSegmentInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutSegmentInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutSegmentInput, PushNotificationUncheckedUpdateWithoutSegmentInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutSegmentInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutSegmentInput>
  }

  export type OrganizationCreateWithoutInAppMessagesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutInAppMessagesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutInAppMessagesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutInAppMessagesInput, OrganizationUncheckedCreateWithoutInAppMessagesInput>
  }

  export type CustomerSegmentCreateWithoutInAppMessagesInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentsInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateWithoutInAppMessagesInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentCreateOrConnectWithoutInAppMessagesInput = {
    where: CustomerSegmentWhereUniqueInput
    create: XOR<CustomerSegmentCreateWithoutInAppMessagesInput, CustomerSegmentUncheckedCreateWithoutInAppMessagesInput>
  }

  export type MarketingTemplateCreateWithoutInAppMessagesInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutMarketingTemplatesInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUncheckedCreateWithoutInAppMessagesInput = {
    id?: string
    organizationId?: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutMarketingTemplateInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateCreateOrConnectWithoutInAppMessagesInput = {
    where: MarketingTemplateWhereUniqueInput
    create: XOR<MarketingTemplateCreateWithoutInAppMessagesInput, MarketingTemplateUncheckedCreateWithoutInAppMessagesInput>
  }

  export type InAppMessageReadCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type InAppMessageReadUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type InAppMessageReadCreateOrConnectWithoutMessageInput = {
    where: InAppMessageReadWhereUniqueInput
    create: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput>
  }

  export type InAppMessageReadCreateManyMessageInputEnvelope = {
    data: InAppMessageReadCreateManyMessageInput | InAppMessageReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutInAppMessagesInput = {
    update: XOR<OrganizationUpdateWithoutInAppMessagesInput, OrganizationUncheckedUpdateWithoutInAppMessagesInput>
    create: XOR<OrganizationCreateWithoutInAppMessagesInput, OrganizationUncheckedCreateWithoutInAppMessagesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutInAppMessagesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutInAppMessagesInput, OrganizationUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type OrganizationUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerSegmentUpsertWithoutInAppMessagesInput = {
    update: XOR<CustomerSegmentUpdateWithoutInAppMessagesInput, CustomerSegmentUncheckedUpdateWithoutInAppMessagesInput>
    create: XOR<CustomerSegmentCreateWithoutInAppMessagesInput, CustomerSegmentUncheckedCreateWithoutInAppMessagesInput>
    where?: CustomerSegmentWhereInput
  }

  export type CustomerSegmentUpdateToOneWithWhereWithoutInAppMessagesInput = {
    where?: CustomerSegmentWhereInput
    data: XOR<CustomerSegmentUpdateWithoutInAppMessagesInput, CustomerSegmentUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type CustomerSegmentUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentsNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type MarketingTemplateUpsertWithoutInAppMessagesInput = {
    update: XOR<MarketingTemplateUpdateWithoutInAppMessagesInput, MarketingTemplateUncheckedUpdateWithoutInAppMessagesInput>
    create: XOR<MarketingTemplateCreateWithoutInAppMessagesInput, MarketingTemplateUncheckedCreateWithoutInAppMessagesInput>
    where?: MarketingTemplateWhereInput
  }

  export type MarketingTemplateUpdateToOneWithWhereWithoutInAppMessagesInput = {
    where?: MarketingTemplateWhereInput
    data: XOR<MarketingTemplateUpdateWithoutInAppMessagesInput, MarketingTemplateUncheckedUpdateWithoutInAppMessagesInput>
  }

  export type MarketingTemplateUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutMarketingTemplatesNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateWithoutInAppMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type InAppMessageReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: InAppMessageReadWhereUniqueInput
    update: XOR<InAppMessageReadUpdateWithoutMessageInput, InAppMessageReadUncheckedUpdateWithoutMessageInput>
    create: XOR<InAppMessageReadCreateWithoutMessageInput, InAppMessageReadUncheckedCreateWithoutMessageInput>
  }

  export type InAppMessageReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: InAppMessageReadWhereUniqueInput
    data: XOR<InAppMessageReadUpdateWithoutMessageInput, InAppMessageReadUncheckedUpdateWithoutMessageInput>
  }

  export type InAppMessageReadUpdateManyWithWhereWithoutMessageInput = {
    where: InAppMessageReadScalarWhereInput
    data: XOR<InAppMessageReadUpdateManyMutationInput, InAppMessageReadUncheckedUpdateManyWithoutMessageInput>
  }

  export type InAppMessageReadScalarWhereInput = {
    AND?: InAppMessageReadScalarWhereInput | InAppMessageReadScalarWhereInput[]
    OR?: InAppMessageReadScalarWhereInput[]
    NOT?: InAppMessageReadScalarWhereInput | InAppMessageReadScalarWhereInput[]
    id?: StringFilter<"InAppMessageRead"> | string
    messageId?: StringFilter<"InAppMessageRead"> | string
    userId?: StringFilter<"InAppMessageRead"> | string
    readAt?: DateTimeFilter<"InAppMessageRead"> | Date | string
  }

  export type InAppMessageCreateWithoutReadByInput = {
    id?: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInAppMessagesInput
    segment: CustomerSegmentCreateNestedOneWithoutInAppMessagesInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutInAppMessagesInput
  }

  export type InAppMessageUncheckedCreateWithoutReadByInput = {
    id?: string
    organizationId: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InAppMessageCreateOrConnectWithoutReadByInput = {
    where: InAppMessageWhereUniqueInput
    create: XOR<InAppMessageCreateWithoutReadByInput, InAppMessageUncheckedCreateWithoutReadByInput>
  }

  export type InAppMessageUpsertWithoutReadByInput = {
    update: XOR<InAppMessageUpdateWithoutReadByInput, InAppMessageUncheckedUpdateWithoutReadByInput>
    create: XOR<InAppMessageCreateWithoutReadByInput, InAppMessageUncheckedCreateWithoutReadByInput>
    where?: InAppMessageWhereInput
  }

  export type InAppMessageUpdateToOneWithWhereWithoutReadByInput = {
    where?: InAppMessageWhereInput
    data: XOR<InAppMessageUpdateWithoutReadByInput, InAppMessageUncheckedUpdateWithoutReadByInput>
  }

  export type InAppMessageUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInAppMessagesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutInAppMessagesNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutInAppMessagesNestedInput
  }

  export type InAppMessageUncheckedUpdateWithoutReadByInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutWorkflowsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutWorkflowsInput, OrganizationUncheckedCreateWithoutWorkflowsInput>
  }

  export type CustomerSegmentCreateWithoutWorkflowsInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentsInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateWithoutWorkflowsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentCreateOrConnectWithoutWorkflowsInput = {
    where: CustomerSegmentWhereUniqueInput
    create: XOR<CustomerSegmentCreateWithoutWorkflowsInput, CustomerSegmentUncheckedCreateWithoutWorkflowsInput>
  }

  export type WorkflowExecutionLogCreateWithoutWorkflowInput = {
    id?: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput = {
    id?: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogCreateOrConnectWithoutWorkflowInput = {
    where: WorkflowExecutionLogWhereUniqueInput
    create: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowExecutionLogCreateManyWorkflowInputEnvelope = {
    data: WorkflowExecutionLogCreateManyWorkflowInput | WorkflowExecutionLogCreateManyWorkflowInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutWorkflowsInput = {
    update: XOR<OrganizationUpdateWithoutWorkflowsInput, OrganizationUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<OrganizationCreateWithoutWorkflowsInput, OrganizationUncheckedCreateWithoutWorkflowsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutWorkflowsInput, OrganizationUncheckedUpdateWithoutWorkflowsInput>
  }

  export type OrganizationUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerSegmentUpsertWithoutWorkflowsInput = {
    update: XOR<CustomerSegmentUpdateWithoutWorkflowsInput, CustomerSegmentUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<CustomerSegmentCreateWithoutWorkflowsInput, CustomerSegmentUncheckedCreateWithoutWorkflowsInput>
    where?: CustomerSegmentWhereInput
  }

  export type CustomerSegmentUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: CustomerSegmentWhereInput
    data: XOR<CustomerSegmentUpdateWithoutWorkflowsInput, CustomerSegmentUncheckedUpdateWithoutWorkflowsInput>
  }

  export type CustomerSegmentUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentsNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateWithoutWorkflowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type WorkflowExecutionLogUpsertWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionLogWhereUniqueInput
    update: XOR<WorkflowExecutionLogUpdateWithoutWorkflowInput, WorkflowExecutionLogUncheckedUpdateWithoutWorkflowInput>
    create: XOR<WorkflowExecutionLogCreateWithoutWorkflowInput, WorkflowExecutionLogUncheckedCreateWithoutWorkflowInput>
  }

  export type WorkflowExecutionLogUpdateWithWhereUniqueWithoutWorkflowInput = {
    where: WorkflowExecutionLogWhereUniqueInput
    data: XOR<WorkflowExecutionLogUpdateWithoutWorkflowInput, WorkflowExecutionLogUncheckedUpdateWithoutWorkflowInput>
  }

  export type WorkflowExecutionLogUpdateManyWithWhereWithoutWorkflowInput = {
    where: WorkflowExecutionLogScalarWhereInput
    data: XOR<WorkflowExecutionLogUpdateManyMutationInput, WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowInput>
  }

  export type WorkflowExecutionLogScalarWhereInput = {
    AND?: WorkflowExecutionLogScalarWhereInput | WorkflowExecutionLogScalarWhereInput[]
    OR?: WorkflowExecutionLogScalarWhereInput[]
    NOT?: WorkflowExecutionLogScalarWhereInput | WorkflowExecutionLogScalarWhereInput[]
    id?: StringFilter<"WorkflowExecutionLog"> | string
    workflowId?: StringFilter<"WorkflowExecutionLog"> | string
    executedAt?: DateTimeFilter<"WorkflowExecutionLog"> | Date | string
    status?: StringFilter<"WorkflowExecutionLog"> | string
    message?: StringNullableFilter<"WorkflowExecutionLog"> | string | null
    details?: JsonNullableFilter<"WorkflowExecutionLog">
  }

  export type MarketingWorkflowCreateWithoutExecutionLogsInput = {
    id?: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutWorkflowsInput
    segment: CustomerSegmentCreateNestedOneWithoutWorkflowsInput
  }

  export type MarketingWorkflowUncheckedCreateWithoutExecutionLogsInput = {
    id?: string
    organizationId: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingWorkflowCreateOrConnectWithoutExecutionLogsInput = {
    where: MarketingWorkflowWhereUniqueInput
    create: XOR<MarketingWorkflowCreateWithoutExecutionLogsInput, MarketingWorkflowUncheckedCreateWithoutExecutionLogsInput>
  }

  export type MarketingWorkflowUpsertWithoutExecutionLogsInput = {
    update: XOR<MarketingWorkflowUpdateWithoutExecutionLogsInput, MarketingWorkflowUncheckedUpdateWithoutExecutionLogsInput>
    create: XOR<MarketingWorkflowCreateWithoutExecutionLogsInput, MarketingWorkflowUncheckedCreateWithoutExecutionLogsInput>
    where?: MarketingWorkflowWhereInput
  }

  export type MarketingWorkflowUpdateToOneWithWhereWithoutExecutionLogsInput = {
    where?: MarketingWorkflowWhereInput
    data: XOR<MarketingWorkflowUpdateWithoutExecutionLogsInput, MarketingWorkflowUncheckedUpdateWithoutExecutionLogsInput>
  }

  export type MarketingWorkflowUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateWithoutExecutionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateWithoutSegmentIncentivesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSegmentIncentivesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSegmentIncentivesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSegmentIncentivesInput, OrganizationUncheckedCreateWithoutSegmentIncentivesInput>
  }

  export type CustomerSegmentCreateWithoutSegmentIncentivesInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentsInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateWithoutSegmentIncentivesInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentCreateOrConnectWithoutSegmentIncentivesInput = {
    where: CustomerSegmentWhereUniqueInput
    create: XOR<CustomerSegmentCreateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedCreateWithoutSegmentIncentivesInput>
  }

  export type CouponCreateWithoutSegmentIncentivesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutSegmentIncentivesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutSegmentIncentivesInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutSegmentIncentivesInput, CouponUncheckedCreateWithoutSegmentIncentivesInput>
  }

  export type IncentiveGrantCreateWithoutSegmentIncentiveInput = {
    id?: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    user: UserCreateNestedOneWithoutIncentiveGrantsInput
    coupon?: CouponCreateNestedOneWithoutIncentiveGrantsInput
    walletTransaction?: WalletTransactionCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput = {
    id?: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
    walletTransaction?: WalletTransactionUncheckedCreateNestedOneWithoutIncentiveGrantInput
  }

  export type IncentiveGrantCreateOrConnectWithoutSegmentIncentiveInput = {
    where: IncentiveGrantWhereUniqueInput
    create: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput>
  }

  export type IncentiveGrantCreateManySegmentIncentiveInputEnvelope = {
    data: IncentiveGrantCreateManySegmentIncentiveInput | IncentiveGrantCreateManySegmentIncentiveInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutSegmentIncentivesInput = {
    update: XOR<OrganizationUpdateWithoutSegmentIncentivesInput, OrganizationUncheckedUpdateWithoutSegmentIncentivesInput>
    create: XOR<OrganizationCreateWithoutSegmentIncentivesInput, OrganizationUncheckedCreateWithoutSegmentIncentivesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutSegmentIncentivesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutSegmentIncentivesInput, OrganizationUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type OrganizationUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerSegmentUpsertWithoutSegmentIncentivesInput = {
    update: XOR<CustomerSegmentUpdateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedUpdateWithoutSegmentIncentivesInput>
    create: XOR<CustomerSegmentCreateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedCreateWithoutSegmentIncentivesInput>
    where?: CustomerSegmentWhereInput
  }

  export type CustomerSegmentUpdateToOneWithWhereWithoutSegmentIncentivesInput = {
    where?: CustomerSegmentWhereInput
    data: XOR<CustomerSegmentUpdateWithoutSegmentIncentivesInput, CustomerSegmentUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type CustomerSegmentUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentsNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type CouponUpsertWithoutSegmentIncentivesInput = {
    update: XOR<CouponUpdateWithoutSegmentIncentivesInput, CouponUncheckedUpdateWithoutSegmentIncentivesInput>
    create: XOR<CouponCreateWithoutSegmentIncentivesInput, CouponUncheckedCreateWithoutSegmentIncentivesInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutSegmentIncentivesInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutSegmentIncentivesInput, CouponUncheckedUpdateWithoutSegmentIncentivesInput>
  }

  export type CouponUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutSegmentIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type IncentiveGrantUpsertWithWhereUniqueWithoutSegmentIncentiveInput = {
    where: IncentiveGrantWhereUniqueInput
    update: XOR<IncentiveGrantUpdateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedUpdateWithoutSegmentIncentiveInput>
    create: XOR<IncentiveGrantCreateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedCreateWithoutSegmentIncentiveInput>
  }

  export type IncentiveGrantUpdateWithWhereUniqueWithoutSegmentIncentiveInput = {
    where: IncentiveGrantWhereUniqueInput
    data: XOR<IncentiveGrantUpdateWithoutSegmentIncentiveInput, IncentiveGrantUncheckedUpdateWithoutSegmentIncentiveInput>
  }

  export type IncentiveGrantUpdateManyWithWhereWithoutSegmentIncentiveInput = {
    where: IncentiveGrantScalarWhereInput
    data: XOR<IncentiveGrantUpdateManyMutationInput, IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveInput>
  }

  export type OrganizationCreateWithoutMarketingTemplatesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMarketingTemplatesInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMarketingTemplatesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMarketingTemplatesInput, OrganizationUncheckedCreateWithoutMarketingTemplatesInput>
  }

  export type InAppMessageCreateWithoutMarketingTemplateInput = {
    id?: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutInAppMessagesInput
    segment: CustomerSegmentCreateNestedOneWithoutInAppMessagesInput
    readBy?: InAppMessageReadCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageUncheckedCreateWithoutMarketingTemplateInput = {
    id?: string
    organizationId: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    readBy?: InAppMessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type InAppMessageCreateOrConnectWithoutMarketingTemplateInput = {
    where: InAppMessageWhereUniqueInput
    create: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type InAppMessageCreateManyMarketingTemplateInputEnvelope = {
    data: InAppMessageCreateManyMarketingTemplateInput | InAppMessageCreateManyMarketingTemplateInput[]
    skipDuplicates?: boolean
  }

  export type PromotionBannerCreateWithoutMarketingTemplateInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    coupon?: CouponCreateNestedOneWithoutPromotionBannersInput
    menuAssignments?: MenuPromotionBannerCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerUncheckedCreateWithoutMarketingTemplateInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    couponId?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    menuAssignments?: MenuPromotionBannerUncheckedCreateNestedManyWithoutPromotionBannerInput
  }

  export type PromotionBannerCreateOrConnectWithoutMarketingTemplateInput = {
    where: PromotionBannerWhereUniqueInput
    create: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type PromotionBannerCreateManyMarketingTemplateInputEnvelope = {
    data: PromotionBannerCreateManyMarketingTemplateInput | PromotionBannerCreateManyMarketingTemplateInput[]
    skipDuplicates?: boolean
  }

  export type PushNotificationCreateWithoutMarketingTemplateInput = {
    id?: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPushNotificationsInput
    segment: CustomerSegmentCreateNestedOneWithoutPushNotificationsInput
    logs?: PushNotificationLogCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationUncheckedCreateWithoutMarketingTemplateInput = {
    id?: string
    organizationId: string
    segmentId: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: PushNotificationLogUncheckedCreateNestedManyWithoutPushNotificationInput
  }

  export type PushNotificationCreateOrConnectWithoutMarketingTemplateInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type PushNotificationCreateManyMarketingTemplateInputEnvelope = {
    data: PushNotificationCreateManyMarketingTemplateInput | PushNotificationCreateManyMarketingTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutMarketingTemplatesInput = {
    update: XOR<OrganizationUpdateWithoutMarketingTemplatesInput, OrganizationUncheckedUpdateWithoutMarketingTemplatesInput>
    create: XOR<OrganizationCreateWithoutMarketingTemplatesInput, OrganizationUncheckedCreateWithoutMarketingTemplatesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMarketingTemplatesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMarketingTemplatesInput, OrganizationUncheckedUpdateWithoutMarketingTemplatesInput>
  }

  export type OrganizationUpdateWithoutMarketingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMarketingTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type InAppMessageUpsertWithWhereUniqueWithoutMarketingTemplateInput = {
    where: InAppMessageWhereUniqueInput
    update: XOR<InAppMessageUpdateWithoutMarketingTemplateInput, InAppMessageUncheckedUpdateWithoutMarketingTemplateInput>
    create: XOR<InAppMessageCreateWithoutMarketingTemplateInput, InAppMessageUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type InAppMessageUpdateWithWhereUniqueWithoutMarketingTemplateInput = {
    where: InAppMessageWhereUniqueInput
    data: XOR<InAppMessageUpdateWithoutMarketingTemplateInput, InAppMessageUncheckedUpdateWithoutMarketingTemplateInput>
  }

  export type InAppMessageUpdateManyWithWhereWithoutMarketingTemplateInput = {
    where: InAppMessageScalarWhereInput
    data: XOR<InAppMessageUpdateManyMutationInput, InAppMessageUncheckedUpdateManyWithoutMarketingTemplateInput>
  }

  export type PromotionBannerUpsertWithWhereUniqueWithoutMarketingTemplateInput = {
    where: PromotionBannerWhereUniqueInput
    update: XOR<PromotionBannerUpdateWithoutMarketingTemplateInput, PromotionBannerUncheckedUpdateWithoutMarketingTemplateInput>
    create: XOR<PromotionBannerCreateWithoutMarketingTemplateInput, PromotionBannerUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type PromotionBannerUpdateWithWhereUniqueWithoutMarketingTemplateInput = {
    where: PromotionBannerWhereUniqueInput
    data: XOR<PromotionBannerUpdateWithoutMarketingTemplateInput, PromotionBannerUncheckedUpdateWithoutMarketingTemplateInput>
  }

  export type PromotionBannerUpdateManyWithWhereWithoutMarketingTemplateInput = {
    where: PromotionBannerScalarWhereInput
    data: XOR<PromotionBannerUpdateManyMutationInput, PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateInput>
  }

  export type PushNotificationUpsertWithWhereUniqueWithoutMarketingTemplateInput = {
    where: PushNotificationWhereUniqueInput
    update: XOR<PushNotificationUpdateWithoutMarketingTemplateInput, PushNotificationUncheckedUpdateWithoutMarketingTemplateInput>
    create: XOR<PushNotificationCreateWithoutMarketingTemplateInput, PushNotificationUncheckedCreateWithoutMarketingTemplateInput>
  }

  export type PushNotificationUpdateWithWhereUniqueWithoutMarketingTemplateInput = {
    where: PushNotificationWhereUniqueInput
    data: XOR<PushNotificationUpdateWithoutMarketingTemplateInput, PushNotificationUncheckedUpdateWithoutMarketingTemplateInput>
  }

  export type PushNotificationUpdateManyWithWhereWithoutMarketingTemplateInput = {
    where: PushNotificationScalarWhereInput
    data: XOR<PushNotificationUpdateManyMutationInput, PushNotificationUncheckedUpdateManyWithoutMarketingTemplateInput>
  }

  export type OrganizationCreateWithoutPushNotificationsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPushNotificationsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    paymentConfigs?: PaymentProviderConfigUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPushNotificationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPushNotificationsInput, OrganizationUncheckedCreateWithoutPushNotificationsInput>
  }

  export type CustomerSegmentCreateWithoutPushNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentsInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentUncheckedCreateWithoutPushNotificationsInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutSegmentInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutSegmentInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutSegmentInput
  }

  export type CustomerSegmentCreateOrConnectWithoutPushNotificationsInput = {
    where: CustomerSegmentWhereUniqueInput
    create: XOR<CustomerSegmentCreateWithoutPushNotificationsInput, CustomerSegmentUncheckedCreateWithoutPushNotificationsInput>
  }

  export type MarketingTemplateCreateWithoutPushNotificationsInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutMarketingTemplatesInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateUncheckedCreateWithoutPushNotificationsInput = {
    id?: string
    organizationId?: string | null
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutMarketingTemplateInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutMarketingTemplateInput
  }

  export type MarketingTemplateCreateOrConnectWithoutPushNotificationsInput = {
    where: MarketingTemplateWhereUniqueInput
    create: XOR<MarketingTemplateCreateWithoutPushNotificationsInput, MarketingTemplateUncheckedCreateWithoutPushNotificationsInput>
  }

  export type PushNotificationLogCreateWithoutPushNotificationInput = {
    id?: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
    user: UserCreateNestedOneWithoutPushNotificationLogsInput
  }

  export type PushNotificationLogUncheckedCreateWithoutPushNotificationInput = {
    id?: string
    userId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushNotificationLogCreateOrConnectWithoutPushNotificationInput = {
    where: PushNotificationLogWhereUniqueInput
    create: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput>
  }

  export type PushNotificationLogCreateManyPushNotificationInputEnvelope = {
    data: PushNotificationLogCreateManyPushNotificationInput | PushNotificationLogCreateManyPushNotificationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutPushNotificationsInput = {
    update: XOR<OrganizationUpdateWithoutPushNotificationsInput, OrganizationUncheckedUpdateWithoutPushNotificationsInput>
    create: XOR<OrganizationCreateWithoutPushNotificationsInput, OrganizationUncheckedCreateWithoutPushNotificationsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPushNotificationsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPushNotificationsInput, OrganizationUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type OrganizationUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    paymentConfigs?: PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CustomerSegmentUpsertWithoutPushNotificationsInput = {
    update: XOR<CustomerSegmentUpdateWithoutPushNotificationsInput, CustomerSegmentUncheckedUpdateWithoutPushNotificationsInput>
    create: XOR<CustomerSegmentCreateWithoutPushNotificationsInput, CustomerSegmentUncheckedCreateWithoutPushNotificationsInput>
    where?: CustomerSegmentWhereInput
  }

  export type CustomerSegmentUpdateToOneWithWhereWithoutPushNotificationsInput = {
    where?: CustomerSegmentWhereInput
    data: XOR<CustomerSegmentUpdateWithoutPushNotificationsInput, CustomerSegmentUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type CustomerSegmentUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentsNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type MarketingTemplateUpsertWithoutPushNotificationsInput = {
    update: XOR<MarketingTemplateUpdateWithoutPushNotificationsInput, MarketingTemplateUncheckedUpdateWithoutPushNotificationsInput>
    create: XOR<MarketingTemplateCreateWithoutPushNotificationsInput, MarketingTemplateUncheckedCreateWithoutPushNotificationsInput>
    where?: MarketingTemplateWhereInput
  }

  export type MarketingTemplateUpdateToOneWithWhereWithoutPushNotificationsInput = {
    where?: MarketingTemplateWhereInput
    data: XOR<MarketingTemplateUpdateWithoutPushNotificationsInput, MarketingTemplateUncheckedUpdateWithoutPushNotificationsInput>
  }

  export type MarketingTemplateUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutMarketingTemplatesNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateWithoutPushNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type PushNotificationLogUpsertWithWhereUniqueWithoutPushNotificationInput = {
    where: PushNotificationLogWhereUniqueInput
    update: XOR<PushNotificationLogUpdateWithoutPushNotificationInput, PushNotificationLogUncheckedUpdateWithoutPushNotificationInput>
    create: XOR<PushNotificationLogCreateWithoutPushNotificationInput, PushNotificationLogUncheckedCreateWithoutPushNotificationInput>
  }

  export type PushNotificationLogUpdateWithWhereUniqueWithoutPushNotificationInput = {
    where: PushNotificationLogWhereUniqueInput
    data: XOR<PushNotificationLogUpdateWithoutPushNotificationInput, PushNotificationLogUncheckedUpdateWithoutPushNotificationInput>
  }

  export type PushNotificationLogUpdateManyWithWhereWithoutPushNotificationInput = {
    where: PushNotificationLogScalarWhereInput
    data: XOR<PushNotificationLogUpdateManyMutationInput, PushNotificationLogUncheckedUpdateManyWithoutPushNotificationInput>
  }

  export type PushNotificationCreateWithoutLogsInput = {
    id?: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutPushNotificationsInput
    segment: CustomerSegmentCreateNestedOneWithoutPushNotificationsInput
    marketingTemplate?: MarketingTemplateCreateNestedOneWithoutPushNotificationsInput
  }

  export type PushNotificationUncheckedCreateWithoutLogsInput = {
    id?: string
    organizationId: string
    segmentId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushNotificationCreateOrConnectWithoutLogsInput = {
    where: PushNotificationWhereUniqueInput
    create: XOR<PushNotificationCreateWithoutLogsInput, PushNotificationUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutPushNotificationLogsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutPushNotificationLogsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPushNotificationLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushNotificationLogsInput, UserUncheckedCreateWithoutPushNotificationLogsInput>
  }

  export type PushNotificationUpsertWithoutLogsInput = {
    update: XOR<PushNotificationUpdateWithoutLogsInput, PushNotificationUncheckedUpdateWithoutLogsInput>
    create: XOR<PushNotificationCreateWithoutLogsInput, PushNotificationUncheckedCreateWithoutLogsInput>
    where?: PushNotificationWhereInput
  }

  export type PushNotificationUpdateToOneWithWhereWithoutLogsInput = {
    where?: PushNotificationWhereInput
    data: XOR<PushNotificationUpdateWithoutLogsInput, PushNotificationUncheckedUpdateWithoutLogsInput>
  }

  export type PushNotificationUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPushNotificationsNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutPushNotificationsNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPushNotificationsNestedInput
  }

  export type PushNotificationUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutPushNotificationLogsInput = {
    update: XOR<UserUpdateWithoutPushNotificationLogsInput, UserUncheckedUpdateWithoutPushNotificationLogsInput>
    create: XOR<UserCreateWithoutPushNotificationLogsInput, UserUncheckedCreateWithoutPushNotificationLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushNotificationLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushNotificationLogsInput, UserUncheckedUpdateWithoutPushNotificationLogsInput>
  }

  export type UserUpdateWithoutPushNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPushNotificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
  }

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
    create: XOR<UserCreateWithoutPushSubscriptionsInput, UserUncheckedCreateWithoutPushSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionsInput, UserUncheckedUpdateWithoutPushSubscriptionsInput>
  }

  export type UserUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type OrganizationCreateWithoutPaymentConfigsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutPaymentConfigsInput = {
    id?: string
    name: string
    slug: string
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    segments?: CustomerSegmentUncheckedCreateNestedManyWithoutOrganizationInput
    inAppMessages?: InAppMessageUncheckedCreateNestedManyWithoutOrganizationInput
    workflows?: MarketingWorkflowUncheckedCreateNestedManyWithoutOrganizationInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutOrganizationInput
    marketingTemplates?: MarketingTemplateUncheckedCreateNestedManyWithoutOrganizationInput
    pushNotifications?: PushNotificationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutPaymentConfigsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutPaymentConfigsInput, OrganizationUncheckedCreateWithoutPaymentConfigsInput>
  }

  export type UserCreateWithoutPaymentConfigChangesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentConfigChangesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    incentiveGrants?: IncentiveGrantUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentConfigChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentConfigChangesInput, UserUncheckedCreateWithoutPaymentConfigChangesInput>
  }

  export type OrganizationUpsertWithoutPaymentConfigsInput = {
    update: XOR<OrganizationUpdateWithoutPaymentConfigsInput, OrganizationUncheckedUpdateWithoutPaymentConfigsInput>
    create: XOR<OrganizationCreateWithoutPaymentConfigsInput, OrganizationUncheckedCreateWithoutPaymentConfigsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutPaymentConfigsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutPaymentConfigsInput, OrganizationUncheckedUpdateWithoutPaymentConfigsInput>
  }

  export type OrganizationUpdateWithoutPaymentConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutPaymentConfigsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    segments?: CustomerSegmentUncheckedUpdateManyWithoutOrganizationNestedInput
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutOrganizationNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutOrganizationNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutOrganizationNestedInput
    marketingTemplates?: MarketingTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutPaymentConfigChangesInput = {
    update: XOR<UserUpdateWithoutPaymentConfigChangesInput, UserUncheckedUpdateWithoutPaymentConfigChangesInput>
    create: XOR<UserCreateWithoutPaymentConfigChangesInput, UserUncheckedCreateWithoutPaymentConfigChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentConfigChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentConfigChangesInput, UserUncheckedUpdateWithoutPaymentConfigChangesInput>
  }

  export type UserUpdateWithoutPaymentConfigChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentConfigChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SegmentIncentiveCreateWithoutGrantsInput = {
    id?: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutSegmentIncentivesInput
    segment: CustomerSegmentCreateNestedOneWithoutSegmentIncentivesInput
    coupon?: CouponCreateNestedOneWithoutSegmentIncentivesInput
  }

  export type SegmentIncentiveUncheckedCreateWithoutGrantsInput = {
    id?: string
    organizationId: string
    segmentId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentIncentiveCreateOrConnectWithoutGrantsInput = {
    where: SegmentIncentiveWhereUniqueInput
    create: XOR<SegmentIncentiveCreateWithoutGrantsInput, SegmentIncentiveUncheckedCreateWithoutGrantsInput>
  }

  export type UserCreateWithoutIncentiveGrantsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    locations?: UserLocationCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutIncentiveGrantsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    organizationId?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: UserLocationUncheckedCreateNestedManyWithoutUserInput
    companyEmployees?: CompanyEmployeeUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    couponRedemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    walletTransactions?: WalletTransactionUncheckedCreateNestedManyWithoutUserInput
    performedWalletActions?: WalletTransactionUncheckedCreateNestedManyWithoutPerformedByInput
    pushNotificationLogs?: PushNotificationLogUncheckedCreateNestedManyWithoutUserInput
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutIncentiveGrantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncentiveGrantsInput, UserUncheckedCreateWithoutIncentiveGrantsInput>
  }

  export type CouponCreateWithoutIncentiveGrantsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutCouponsInput
    freeItemDish?: DishCreateNestedOneWithoutCouponsInput
    redemptions?: CouponRedemptionCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutIncentiveGrantsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    redemptions?: CouponRedemptionUncheckedCreateNestedManyWithoutCouponInput
    segmentIncentives?: SegmentIncentiveUncheckedCreateNestedManyWithoutCouponInput
    promotionBanners?: PromotionBannerUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutIncentiveGrantsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutIncentiveGrantsInput, CouponUncheckedCreateWithoutIncentiveGrantsInput>
  }

  export type WalletTransactionCreateWithoutIncentiveGrantInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletTransactionsInput
    order?: OrderCreateNestedOneWithoutWalletTransactionsInput
    performedBy?: UserCreateNestedOneWithoutPerformedWalletActionsInput
  }

  export type WalletTransactionUncheckedCreateWithoutIncentiveGrantInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    performedById?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutIncentiveGrantInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
  }

  export type SegmentIncentiveUpsertWithoutGrantsInput = {
    update: XOR<SegmentIncentiveUpdateWithoutGrantsInput, SegmentIncentiveUncheckedUpdateWithoutGrantsInput>
    create: XOR<SegmentIncentiveCreateWithoutGrantsInput, SegmentIncentiveUncheckedCreateWithoutGrantsInput>
    where?: SegmentIncentiveWhereInput
  }

  export type SegmentIncentiveUpdateToOneWithWhereWithoutGrantsInput = {
    where?: SegmentIncentiveWhereInput
    data: XOR<SegmentIncentiveUpdateWithoutGrantsInput, SegmentIncentiveUncheckedUpdateWithoutGrantsInput>
  }

  export type SegmentIncentiveUpdateWithoutGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    coupon?: CouponUpdateOneWithoutSegmentIncentivesNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateWithoutGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutIncentiveGrantsInput = {
    update: XOR<UserUpdateWithoutIncentiveGrantsInput, UserUncheckedUpdateWithoutIncentiveGrantsInput>
    create: XOR<UserCreateWithoutIncentiveGrantsInput, UserUncheckedCreateWithoutIncentiveGrantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncentiveGrantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncentiveGrantsInput, UserUncheckedUpdateWithoutIncentiveGrantsInput>
  }

  export type UserUpdateWithoutIncentiveGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutIncentiveGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type CouponUpsertWithoutIncentiveGrantsInput = {
    update: XOR<CouponUpdateWithoutIncentiveGrantsInput, CouponUncheckedUpdateWithoutIncentiveGrantsInput>
    create: XOR<CouponCreateWithoutIncentiveGrantsInput, CouponUncheckedCreateWithoutIncentiveGrantsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutIncentiveGrantsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutIncentiveGrantsInput, CouponUncheckedUpdateWithoutIncentiveGrantsInput>
  }

  export type CouponUpdateWithoutIncentiveGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutIncentiveGrantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type WalletTransactionUpsertWithoutIncentiveGrantInput = {
    update: XOR<WalletTransactionUpdateWithoutIncentiveGrantInput, WalletTransactionUncheckedUpdateWithoutIncentiveGrantInput>
    create: XOR<WalletTransactionCreateWithoutIncentiveGrantInput, WalletTransactionUncheckedCreateWithoutIncentiveGrantInput>
    where?: WalletTransactionWhereInput
  }

  export type WalletTransactionUpdateToOneWithWhereWithoutIncentiveGrantInput = {
    where?: WalletTransactionWhereInput
    data: XOR<WalletTransactionUpdateWithoutIncentiveGrantInput, WalletTransactionUncheckedUpdateWithoutIncentiveGrantInput>
  }

  export type WalletTransactionUpdateWithoutIncentiveGrantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
    performedBy?: UserUpdateOneWithoutPerformedWalletActionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutIncentiveGrantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyOrganizationInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationCreateworkingDaysInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    image?: string | null
    marketingEmailConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerSegmentCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    rulesCombination?: string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InAppMessageCreateManyOrganizationInput = {
    id?: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingWorkflowCreateManyOrganizationInput = {
    id?: string
    segmentId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentIncentiveCreateManyOrganizationInput = {
    id?: string
    segmentId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTemplateCreateManyOrganizationInput = {
    id?: string
    name: string
    type: $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MarketingTemplateStatus
    isStarter?: boolean
    isFavorite?: boolean
    thumbnailUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushNotificationCreateManyOrganizationInput = {
    id?: string
    segmentId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentProviderConfigCreateManyOrganizationInput = {
    id?: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
    updatedById?: string | null
  }

  export type LocationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUpdateManyWithoutLocationNestedInput
    orders?: OrderUpdateManyWithoutLocationNestedInput
    users?: UserLocationUpdateManyWithoutLocationNestedInput
    coupons?: CouponUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menus?: MenuUncheckedUpdateManyWithoutLocationNestedInput
    orders?: OrderUncheckedUpdateManyWithoutLocationNestedInput
    users?: UserLocationUncheckedUpdateManyWithoutLocationNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    openingHours?: NullableJsonNullValueInput | InputJsonValue
    workingDays?: LocationUpdateworkingDaysInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: UserLocationUncheckedUpdateManyWithoutUserNestedInput
    companyEmployees?: CompanyEmployeeUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutUserNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutUserNestedInput
    performedWalletActions?: WalletTransactionUncheckedUpdateManyWithoutPerformedByNestedInput
    pushNotificationLogs?: PushNotificationLogUncheckedUpdateManyWithoutUserNestedInput
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    paymentConfigChanges?: PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    image?: NullableStringFieldUpdateOperationsInput | string | null
    marketingEmailConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerSegmentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutSegmentNestedInput
    workflows?: MarketingWorkflowUncheckedUpdateManyWithoutSegmentNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutSegmentNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutSegmentNestedInput
  }

  export type CustomerSegmentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rulesCombination?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: CustomerSegmentUpdateOneRequiredWithoutInAppMessagesNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutInAppMessagesNestedInput
    readBy?: InAppMessageReadUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readBy?: InAppMessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingWorkflowUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: CustomerSegmentUpdateOneRequiredWithoutWorkflowsNestedInput
    executionLogs?: WorkflowExecutionLogUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionLogs?: WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentIncentiveUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: CustomerSegmentUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    coupon?: CouponUpdateOneWithoutSegmentIncentivesNestedInput
    grants?: IncentiveGrantUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grants?: IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTemplateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inAppMessages?: InAppMessageUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateNestedInput
    pushNotifications?: PushNotificationUncheckedUpdateManyWithoutMarketingTemplateNestedInput
  }

  export type MarketingTemplateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumMarketingTemplateTypeFieldUpdateOperationsInput | $Enums.MarketingTemplateType
    content?: JsonNullValueInput | InputJsonValue
    status?: EnumMarketingTemplateStatusFieldUpdateOperationsInput | $Enums.MarketingTemplateStatus
    isStarter?: BoolFieldUpdateOperationsInput | boolean
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    segment?: CustomerSegmentUpdateOneRequiredWithoutPushNotificationsNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPushNotificationsNestedInput
    logs?: PushNotificationLogUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: PushNotificationLogUncheckedUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutPaymentConfigChangesNestedInput
  }

  export type PaymentProviderConfigUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyEmployeeCreateManyCompanyInput = {
    id?: string
    userId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyEmployerCompanyInput = {
    id?: string
    userId: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
  }

  export type CompanyInvoiceCreateManyCompanyInput = {
    id?: string
    year: number
    month: number
    status?: string
    totalAmount: Decimal | DecimalJsLike | number | string
    invoicedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyEmployeeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompanyEmployeesNestedInput
  }

  export type CompanyEmployeeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutEmployerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutEmployerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutEmployerCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CompanyInvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CompanyInvoiceItemUpdateManyWithoutCompanyInvoiceNestedInput
  }

  export type CompanyInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CompanyInvoiceItemUncheckedUpdateManyWithoutCompanyInvoiceNestedInput
  }

  export type CompanyInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoicedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyInvoiceItemCreateManyCompanyInvoiceInput = {
    id?: string
    orderId: string
    orderNumber: string
    orderDate: Date | string
    employeeName: string
    amount: Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUpdateWithoutCompanyInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUncheckedUpdateWithoutCompanyInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CompanyInvoiceItemUncheckedUpdateManyWithoutCompanyInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeName?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MenuCreateManyLocationInput = {
    id?: string
    weekNumber: number
    year: number
    startDate: Date | string
    endDate: Date | string
    isPublished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyLocationInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
  }

  export type UserLocationCreateManyLocationInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CouponCreateManyLocationInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUpdateManyWithoutMenuNestedInput
    promotionBanners?: MenuPromotionBannerUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItems?: MenuItemUncheckedUpdateManyWithoutMenuNestedInput
    promotionBanners?: MenuPromotionBannerUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLocationUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type UserLocationUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    freeItemDish?: DishUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    freeItemDishId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationCreateManyUserInput = {
    id?: string
    locationId: string
    createdAt?: Date | string
  }

  export type CompanyEmployeeCreateManyUserInput = {
    id?: string
    companyId: string
    employeeNumber?: string | null
    department?: string | null
    isActive?: boolean
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    createdAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    locationId: string
    status?: $Enums.OrderStatus
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentStatus?: $Enums.PaymentStatus
    paymentMethod?: string | null
    paymentIntentId?: string | null
    pickupCode: string
    pickupDate: Date | string
    pickupTimeSlot?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickedUpAt?: Date | string | null
    couponCode?: string | null
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type CouponRedemptionCreateManyUserInput = {
    id?: string
    couponId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type IncentiveGrantCreateManyUserInput = {
    id?: string
    segmentIncentiveId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
  }

  export type WalletTransactionCreateManyUserInput = {
    id?: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateManyPerformedByInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    orderId?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type PushNotificationLogCreateManyUserInput = {
    id?: string
    pushNotificationId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dhKey: string
    authKey: string
    createdAt?: Date | string
  }

  export type PaymentProviderConfigCreateManyUpdatedByInput = {
    id?: string
    organizationId: string
    provider: string
    isEnabled?: boolean
    configJson: string
    updatedAt?: Date | string
  }

  export type UserLocationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserLocationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLocationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type CompanyEmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyEmployeeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    location?: LocationUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUpdateManyWithoutOrderNestedInput
    employerCompany?: CompanyUpdateOneWithoutOrdersNestedInput
    walletTransactions?: WalletTransactionUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    couponRedemptions?: CouponRedemptionUncheckedUpdateManyWithoutOrderNestedInput
    walletTransactions?: WalletTransactionUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupCode?: StringFieldUpdateOperationsInput | string
    pickupDate?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupTimeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickedUpAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerSubsidyAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    employerCompanyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CouponRedemptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutRedemptionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCouponRedemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveGrantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    segmentIncentive?: SegmentIncentiveUpdateOneRequiredWithoutGrantsNestedInput
    coupon?: CouponUpdateOneWithoutIncentiveGrantsNestedInput
    walletTransaction?: WalletTransactionUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransaction?: WalletTransactionUncheckedUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
    performedBy?: UserUpdateOneWithoutPerformedWalletActionsNestedInput
    incentiveGrant?: IncentiveGrantUpdateOneWithoutWalletTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletTransactionsNestedInput
    order?: OrderUpdateOneWithoutWalletTransactionsNestedInput
    incentiveGrant?: IncentiveGrantUpdateOneWithoutWalletTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutPerformedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushNotification?: PushNotificationUpdateOneRequiredWithoutLogsNestedInput
  }

  export type PushNotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotificationId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotificationId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dhKey?: StringFieldUpdateOperationsInput | string
    authKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPaymentConfigsNestedInput
  }

  export type PaymentProviderConfigUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentProviderConfigUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    configJson?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyMenuInput = {
    id?: string
    dishId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuPromotionBannerCreateManyMenuInput = {
    id?: string
    promotionBannerId: string
    sortOrder?: number
  }

  export type MenuItemUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dish?: DishUpdateOneRequiredWithoutMenuItemsNestedInput
    orderItems?: OrderItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuPromotionBannerUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    promotionBanner?: PromotionBannerUpdateOneRequiredWithoutMenuAssignmentsNestedInput
  }

  export type MenuPromotionBannerUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionBannerId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuPromotionBannerUncheckedUpdateManyWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    promotionBannerId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuPromotionBannerCreateManyPromotionBannerInput = {
    id?: string
    menuId: string
    sortOrder?: number
  }

  export type MenuPromotionBannerUpdateWithoutPromotionBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    menu?: MenuUpdateOneRequiredWithoutPromotionBannersNestedInput
  }

  export type MenuPromotionBannerUncheckedUpdateWithoutPromotionBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyMenuItemInput = {
    id?: string
    orderId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutMenuItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutMenuItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutMenuItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyDishInput = {
    id?: string
    menuId: string
    date: Date | string
    available?: boolean
    price: Decimal | DecimalJsLike | number | string
    maxOrders?: number | null
    currentOrders?: number
    isPromotion?: boolean
    promotionPrice?: Decimal | DecimalJsLike | number | string | null
    promotionLabel?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateManyFreeItemDishInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: $Enums.CouponType
    discountValue?: Decimal | DecimalJsLike | number | string | null
    locationId?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    maxUses?: number | null
    maxUsesPerUser?: number
    currentUses?: number
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateWithoutDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutMenuItemsNestedInput
    orderItems?: OrderItemUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutMenuItemNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxOrders?: NullableIntFieldUpdateOperationsInput | number | null
    currentOrders?: IntFieldUpdateOperationsInput | number
    isPromotion?: BoolFieldUpdateOperationsInput | boolean
    promotionPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    promotionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutFreeItemDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutCouponsNestedInput
    redemptions?: CouponRedemptionUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutFreeItemDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redemptions?: CouponRedemptionUncheckedUpdateManyWithoutCouponNestedInput
    incentiveGrants?: IncentiveGrantUncheckedUpdateManyWithoutCouponNestedInput
    segmentIncentives?: SegmentIncentiveUncheckedUpdateManyWithoutCouponNestedInput
    promotionBanners?: PromotionBannerUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutFreeItemDishInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCouponTypeFieldUpdateOperationsInput | $Enums.CouponType
    discountValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locationId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    maxUsesPerUser?: IntFieldUpdateOperationsInput | number
    currentUses?: IntFieldUpdateOperationsInput | number
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    menuItemId: string
    quantity?: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CouponRedemptionCreateManyOrderInput = {
    id?: string
    couponId: string
    userId: string
    redeemedAt?: Date | string
  }

  export type WalletTransactionCreateManyOrderInput = {
    id?: string
    userId: string
    type: $Enums.WalletTransactionType
    amount: Decimal | DecimalJsLike | number | string
    balanceBefore: Decimal | DecimalJsLike | number | string
    balanceAfter: Decimal | DecimalJsLike | number | string
    description?: string | null
    performedById?: string | null
    incentiveGrantId?: string | null
    paymentProvider?: string | null
    externalPaymentId?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuItem?: MenuItemUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuItemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneRequiredWithoutRedemptionsNestedInput
    user?: UserUpdateOneRequiredWithoutCouponRedemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    couponId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletTransactionsNestedInput
    performedBy?: UserUpdateOneWithoutPerformedWalletActionsNestedInput
    incentiveGrant?: IncentiveGrantUpdateOneWithoutWalletTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumWalletTransactionTypeFieldUpdateOperationsInput | $Enums.WalletTransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveGrantId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionCreateManyCouponInput = {
    id?: string
    userId: string
    orderId: string
    redeemedAt?: Date | string
  }

  export type IncentiveGrantCreateManyCouponInput = {
    id?: string
    segmentIncentiveId: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
  }

  export type SegmentIncentiveCreateManyCouponInput = {
    id?: string
    organizationId: string
    segmentId: string
    name?: string | null
    incentiveType: string
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionBannerCreateManyCouponInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponRedemptionUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCouponRedemptionsNestedInput
    order?: OrderUpdateOneRequiredWithoutCouponRedemptionsNestedInput
  }

  export type CouponRedemptionUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponRedemptionUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    redeemedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveGrantUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    segmentIncentive?: SegmentIncentiveUpdateOneRequiredWithoutGrantsNestedInput
    user?: UserUpdateOneRequiredWithoutIncentiveGrantsNestedInput
    walletTransaction?: WalletTransactionUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransaction?: WalletTransactionUncheckedUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    segmentIncentiveId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SegmentIncentiveUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    grants?: IncentiveGrantUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grants?: IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionBannerUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPromotionBannersNestedInput
    menuAssignments?: MenuPromotionBannerUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuAssignments?: MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageCreateManySegmentInput = {
    id?: string
    organizationId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingWorkflowCreateManySegmentInput = {
    id?: string
    organizationId: string
    name: string
    triggerType: string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType: string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SegmentIncentiveCreateManySegmentInput = {
    id?: string
    organizationId: string
    name?: string | null
    incentiveType: string
    couponId?: string | null
    personaliseCoupon?: boolean
    walletAmount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string
    endDate?: Date | string | null
    maxGrantsPerUser?: number
    displayChannel?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushNotificationCreateManySegmentInput = {
    id?: string
    organizationId: string
    marketingTemplateId?: string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InAppMessageUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInAppMessagesNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutInAppMessagesNestedInput
    readBy?: InAppMessageReadUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readBy?: InAppMessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingWorkflowUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutWorkflowsNestedInput
    executionLogs?: WorkflowExecutionLogUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executionLogs?: WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowNestedInput
  }

  export type MarketingWorkflowUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerType?: StringFieldUpdateOperationsInput | string
    triggerConfig?: JsonNullValueInput | InputJsonValue
    actionType?: StringFieldUpdateOperationsInput | string
    actionConfig?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SegmentIncentiveUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutSegmentIncentivesNestedInput
    coupon?: CouponUpdateOneWithoutSegmentIncentivesNestedInput
    grants?: IncentiveGrantUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grants?: IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveNestedInput
  }

  export type SegmentIncentiveUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    incentiveType?: StringFieldUpdateOperationsInput | string
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    personaliseCoupon?: BoolFieldUpdateOperationsInput | boolean
    walletAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxGrantsPerUser?: IntFieldUpdateOperationsInput | number
    displayChannel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPushNotificationsNestedInput
    marketingTemplate?: MarketingTemplateUpdateOneWithoutPushNotificationsNestedInput
    logs?: PushNotificationLogUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: PushNotificationLogUncheckedUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateManyWithoutSegmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    marketingTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadCreateManyMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type InAppMessageReadUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InAppMessageReadUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkflowExecutionLogCreateManyWorkflowInput = {
    id?: string
    executedAt?: Date | string
    status: string
    message?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type WorkflowExecutionLogUncheckedUpdateManyWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    executedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IncentiveGrantCreateManySegmentIncentiveInput = {
    id?: string
    userId: string
    grantedAt?: Date | string
    couponCode?: string | null
    couponId?: string | null
    walletTransactionId?: string | null
    redeemedAt?: Date | string | null
    redeemedOrderId?: string | null
  }

  export type IncentiveGrantUpdateWithoutSegmentIncentiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutIncentiveGrantsNestedInput
    coupon?: CouponUpdateOneWithoutIncentiveGrantsNestedInput
    walletTransaction?: WalletTransactionUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateWithoutSegmentIncentiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransaction?: WalletTransactionUncheckedUpdateOneWithoutIncentiveGrantNestedInput
  }

  export type IncentiveGrantUncheckedUpdateManyWithoutSegmentIncentiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    couponCode?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    walletTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    redeemedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    redeemedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InAppMessageCreateManyMarketingTemplateInput = {
    id?: string
    organizationId: string
    segmentId: string
    title?: string | null
    body: string
    linkUrl?: string | null
    displayPlace?: string
    displayType?: string
    slotId?: string | null
    startDate?: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionBannerCreateManyMarketingTemplateInput = {
    id?: string
    title: string
    subtitle?: string | null
    imageUrl?: string | null
    couponId?: string | null
    isActive?: boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PushNotificationCreateManyMarketingTemplateInput = {
    id?: string
    organizationId: string
    segmentId: string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle: string
    pushBody: string
    deepLink?: string | null
    status?: $Enums.PushNotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    totalRecipients?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InAppMessageUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutInAppMessagesNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutInAppMessagesNestedInput
    readBy?: InAppMessageReadUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readBy?: InAppMessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InAppMessageUncheckedUpdateManyWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    displayPlace?: StringFieldUpdateOperationsInput | string
    displayType?: StringFieldUpdateOperationsInput | string
    slotId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionBannerUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coupon?: CouponUpdateOneWithoutPromotionBannersNestedInput
    menuAssignments?: MenuPromotionBannerUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerUncheckedUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menuAssignments?: MenuPromotionBannerUncheckedUpdateManyWithoutPromotionBannerNestedInput
  }

  export type PromotionBannerUncheckedUpdateManyWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutPushNotificationsNestedInput
    segment?: CustomerSegmentUpdateOneRequiredWithoutPushNotificationsNestedInput
    logs?: PushNotificationLogUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: PushNotificationLogUncheckedUpdateManyWithoutPushNotificationNestedInput
  }

  export type PushNotificationUncheckedUpdateManyWithoutMarketingTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    segmentId?: StringFieldUpdateOperationsInput | string
    templateSnapshot?: NullableJsonNullValueInput | InputJsonValue
    pushTitle?: StringFieldUpdateOperationsInput | string
    pushBody?: StringFieldUpdateOperationsInput | string
    deepLink?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPushNotificationStatusFieldUpdateOperationsInput | $Enums.PushNotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalRecipients?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogCreateManyPushNotificationInput = {
    id?: string
    userId: string
    status: $Enums.PushDeliveryStatus
    sentAt?: Date | string
  }

  export type PushNotificationLogUpdateWithoutPushNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushNotificationLogsNestedInput
  }

  export type PushNotificationLogUncheckedUpdateWithoutPushNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushNotificationLogUncheckedUpdateManyWithoutPushNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPushDeliveryStatusFieldUpdateOperationsInput | $Enums.PushDeliveryStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyInvoiceCountOutputTypeDefaultArgs instead
     */
    export type CompanyInvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyInvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationCountOutputTypeDefaultArgs instead
     */
    export type LocationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuCountOutputTypeDefaultArgs instead
     */
    export type MenuCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionBannerCountOutputTypeDefaultArgs instead
     */
    export type PromotionBannerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionBannerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuItemCountOutputTypeDefaultArgs instead
     */
    export type MenuItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DishCountOutputTypeDefaultArgs instead
     */
    export type DishCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DishCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponCountOutputTypeDefaultArgs instead
     */
    export type CouponCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerSegmentCountOutputTypeDefaultArgs instead
     */
    export type CustomerSegmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerSegmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InAppMessageCountOutputTypeDefaultArgs instead
     */
    export type InAppMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InAppMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketingWorkflowCountOutputTypeDefaultArgs instead
     */
    export type MarketingWorkflowCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketingWorkflowCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SegmentIncentiveCountOutputTypeDefaultArgs instead
     */
    export type SegmentIncentiveCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SegmentIncentiveCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketingTemplateCountOutputTypeDefaultArgs instead
     */
    export type MarketingTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketingTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushNotificationCountOutputTypeDefaultArgs instead
     */
    export type PushNotificationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushNotificationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyInvoiceDefaultArgs instead
     */
    export type CompanyInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyInvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyInvoiceItemDefaultArgs instead
     */
    export type CompanyInvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyInvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyEmployeeDefaultArgs instead
     */
    export type CompanyEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyEmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationDefaultArgs instead
     */
    export type LocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletDefaultArgs instead
     */
    export type WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletTransactionDefaultArgs instead
     */
    export type WalletTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserLocationDefaultArgs instead
     */
    export type UserLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserLocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuDefaultArgs instead
     */
    export type MenuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionBannerDefaultArgs instead
     */
    export type PromotionBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionBannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuPromotionBannerDefaultArgs instead
     */
    export type MenuPromotionBannerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuPromotionBannerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MenuItemDefaultArgs instead
     */
    export type MenuItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MenuItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DishDefaultArgs instead
     */
    export type DishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DishDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponDefaultArgs instead
     */
    export type CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponRedemptionDefaultArgs instead
     */
    export type CouponRedemptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponRedemptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetadataDefaultArgs instead
     */
    export type MetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerSegmentDefaultArgs instead
     */
    export type CustomerSegmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerSegmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InAppMessageDefaultArgs instead
     */
    export type InAppMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InAppMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InAppMessageReadDefaultArgs instead
     */
    export type InAppMessageReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InAppMessageReadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketingWorkflowDefaultArgs instead
     */
    export type MarketingWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketingWorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkflowExecutionLogDefaultArgs instead
     */
    export type WorkflowExecutionLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkflowExecutionLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SegmentIncentiveDefaultArgs instead
     */
    export type SegmentIncentiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SegmentIncentiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketingTemplateDefaultArgs instead
     */
    export type MarketingTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketingTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushNotificationDefaultArgs instead
     */
    export type PushNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushNotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushNotificationLogDefaultArgs instead
     */
    export type PushNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushNotificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PushSubscriptionDefaultArgs instead
     */
    export type PushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PushSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentProviderConfigDefaultArgs instead
     */
    export type PaymentProviderConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentProviderConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncentiveGrantDefaultArgs instead
     */
    export type IncentiveGrantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncentiveGrantDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}